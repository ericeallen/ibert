{"source": "ibis/conftest.py::data_dir", "docstring": "Return the test data directory.\n\nReturns\n-------\nPath\n    Test data directory", "type": "function"}
{"source": "ibis/config.py::SQL", "docstring": "SQL-related options.\n\nAttributes\n----------\nfuse_selects : bool\n    Whether to fuse consecutive select queries into a single query where\n    possible.\ndefault_limit : int | None\n    Number of rows to be retrieved for a table expression without an\n    explicit limit. [](`None`) means no limit.\ndefault_dialect : str\n    Dialect to use for printing SQL when the backend cannot be determined.", "type": "class"}
{"source": "ibis/config.py::Interactive", "docstring": "Options controlling the interactive repr.\n\nAttributes\n----------\nmax_rows : int\n    Maximum rows to pretty print.\nmax_columns : int | None\n    The maximum number of columns to pretty print. If 0 (the default), the\n    number of columns will be inferred from output console size. Set to\n    `None` for no limit.\nmax_length : int\n    Maximum length for pretty-printed arrays and maps.\nmax_string : int\n    Maximum length for pretty-printed strings.\nmax_depth : int\n    Maximum depth for nested data types.\nshow_types : bool\n    Show the inferred type of value expressions in the interactive repr.", "type": "class"}
{"source": "ibis/config.py::Repr", "docstring": "Expression printing options.\n\nAttributes\n----------\ndepth : int\n    The maximum number of expression nodes to print when repring.\ntable_columns : int\n    The number of columns to show in leaf table expressions.\ntable_rows : int\n    The number of rows to show for in memory tables.\nquery_text_length : int\n    The maximum number of characters to show in the `query` field repr of\n    SQLQueryResult operations.\nshow_types : bool\n    Show the inferred type of value expressions in the repr.\nshow_variables : bool\n    Show the variables in the repr instead of generated names. This is\n    an advanced option and may not work in all scenarios.\ninteractive : bool\n    Options controlling the interactive repr.", "type": "class"}
{"source": "ibis/config.py::Options", "docstring": "Ibis configuration options.\n\nAttributes\n----------\ninteractive : bool\n    Show the first few rows of computing an expression when in a repl.\nrepr : Repr\n    Options controlling expression printing.\nverbose : bool\n    Run in verbose mode if [](`True`)\nverbose_log: Callable[[str], None] | None\n    A callable to use when logging.\ngraphviz_repr : bool\n    Render expressions as GraphViz PNGs when running in a Jupyter notebook.\ndefault_backend : Optional[ibis.backends.BaseBackend]\n    The default backend to use for execution, defaults to DuckDB if not\n    set.\nsql: SQL\n    SQL-related options.\nclickhouse : Config | None\n    Clickhouse specific options.\nimpala : Config | None\n    Impala specific options.\npandas : Config | None\n    Pandas specific options.\npyspark : Config | None\n    PySpark specific options.", "type": "class"}
{"source": "ibis/util.py::guid", "docstring": "Return a uuid4 hexadecimal value.", "type": "function"}
{"source": "ibis/util.py::indent", "docstring": "Apply an indentation using the given spaces into the given text.\n\nParameters\n----------\ntext\n    Text to indent\nspaces\n    Number of leading spaces per line\n\nReturns\n-------\nstr\n    Indented text", "type": "function"}
{"source": "ibis/util.py::is_one_of", "docstring": "Check if the type of each value is the same of the given type.\n\nParameters\n----------\nvalues\n    Input values\nt\n    Type to check against\n\nReturns\n-------\ntuple", "type": "function"}
{"source": "ibis/util.py::promote_list", "docstring": "Ensure that the value is a list.\n\nParameters\n----------\nval\n    Value to promote\n\nReturns\n-------\nlist", "type": "function"}
{"source": "ibis/util.py::promote_tuple", "docstring": "Ensure that the value is a tuple.\n\nParameters\n----------\nval\n    Value to promote\n\nReturns\n-------\ntuple", "type": "function"}
{"source": "ibis/util.py::is_function", "docstring": "Check if the given object is a function.\n\nReturns\n-------\nbool\n    Whether `v` is a function", "type": "function"}
{"source": "ibis/util.py::log", "docstring": "Log `msg` using `options.verbose_log` if set, otherwise `print`.", "type": "function"}
{"source": "ibis/util.py::is_iterable", "docstring": "Return whether `o` is iterable and not a :class:`str` or :class:`bytes`.\n\nParameters\n----------\no : object\n    Any python object\n\nReturns\n-------\nbool\n\nExamples\n--------\n>>> is_iterable(\"1\")\nFalse\n>>> is_iterable(b\"1\")\nFalse\n>>> is_iterable(iter(\"1\"))\nTrue\n>>> is_iterable(i for i in range(1))\nTrue\n>>> is_iterable(1)\nFalse\n>>> is_iterable([])\nTrue", "type": "function"}
{"source": "ibis/util.py::convert_unit", "docstring": "Convert a value between different units.\n\nConvert `value`, is assumed to be in units of `unit`, to units of `to`.\nIf `floor` is true, then use floor division on `value` if necessary.\n\nParameters\n----------\nvalue\n    Number or numeric ibis expression\nunit\n    Unit of `value`\nto\n    Unit to convert to\nfloor\n    Whether or not to use floor division on `value` if necessary.\n\nReturns\n-------\nUnion[numbers.Integral, ibis.expr.types.NumericValue]\n    Integer converted unit\n\nExamples\n--------\n>>> one_second = 1000\n>>> x = convert_unit(one_second, \"ms\", \"s\")\n>>> x\n1\n>>> one_second = 1\n>>> x = convert_unit(one_second, \"s\", \"ms\")\n>>> x\n1000\n>>> x = convert_unit(one_second, \"s\", \"s\")\n>>> x\n1\n>>> x = convert_unit(one_second, \"s\", \"M\")\nTraceback (most recent call last):\n    ...\nValueError: Cannot convert to or from unit ... to unit ...", "type": "function"}
{"source": "ibis/util.py::consume", "docstring": "Advance `iterator` n-steps ahead. If `n` is `None`, consume entirely.", "type": "function"}
{"source": "ibis/util.py::flatten_iterable", "docstring": "Recursively flatten the iterable `iterable`.", "type": "function"}
{"source": "ibis/util.py::warn_deprecated", "docstring": "Warn about deprecated usage.\n\nThe message includes a stacktrace and what to do instead.", "type": "function"}
{"source": "ibis/util.py::append_admonition", "docstring": "Append a `kind` admonition with `msg` to `func`'s docstring.", "type": "function"}
{"source": "ibis/util.py::deprecated", "docstring": "Decorate to warn of deprecated usage and what to do instead.", "type": "function"}
{"source": "ibis/util.py::backend_sensitive", "docstring": "Indicate that an API may be sensitive to a backend.", "type": "function"}
{"source": "ibis/util.py::experimental", "docstring": "Decorate a callable to add warning about API instability in docstring.", "type": "function"}
{"source": "ibis/util.py::backend_entry_points", "docstring": "Get the list of installed `ibis.backend` entrypoints.", "type": "function"}
{"source": "ibis/util.py::import_object", "docstring": "Attempt to import an object given its full qualname.\n\nExamples\n--------\n>>> ex = import_object(\"ibis.examples\")\n\nIs the same as\n\n>>> from ibis import examples as ex", "type": "function"}
{"source": "ibis/util.py::gen_name", "docstring": "Create a unique identifier.", "type": "function"}
{"source": "ibis/util.py::slice_to_limit_offset", "docstring": "Convert a Python [`slice`](slice) to a `limit`, `offset` pair.\n\nParameters\n----------\nwhat\n    The slice to convert\ncount\n    The total number of rows in the table as an expression\n\nReturns\n-------\ntuple[int | ir.IntegerScalar, int | ir.IntegerScalar]\n    The offset and limit to use in a `Table.limit` call\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table(dict(a=\"int\", b=\"string\"), name=\"t\")\n\nFirst 10 rows\n>>> count = t.count()\n>>> what = slice(0, 10)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit\n10\n>>> offset\n0\n\nLast 10 rows\n>>> what = slice(-10, None)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit\n10\n>>> offset\nr0 := UnboundTable: t\n  a int64\n  b string\n<BLANKLINE>\nAdd(CountStar(t), -10): CountStar(r0) + -10\n\nFrom 5th row to 10th row\n>>> what = slice(5, 10)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit, offset\n(5, 5)", "type": "function"}
{"source": "ibis/util.py::Namespace", "docstring": "Convenience class for creating patterns for various types from a module.\n\nUseful to reduce boilerplate when creating patterns for various types from\na module.\n\nParameters\n----------\nfactory\n    The pattern to construct with the looked up types.\nmodule\n    The module object or name to look up the types.", "type": "class"}
{"source": "ibis/util.py::PseudoHashable", "docstring": "A wrapper that provides a best effort precomputed hash.", "type": "class"}
{"source": "ibis/util.py::chunks", "docstring": "Return an iterator of chunk start and end indices.\n\nParameters\n----------\nn\n    The total number of elements.\nchunk_size\n    The size of each chunk.\n\nReturns\n-------\nint\n    THE start and end indices of each chunk.\n\nExamples\n--------\n>>> list(chunks(10, chunk_size=3))\n[(0, 3), (3, 6), (6, 9), (9, 10)]\n>>> list(chunks(10, chunk_size=4))\n[(0, 4), (4, 8), (8, 10)]", "type": "function"}
{"source": "ibis/util.py::get_subclasses", "docstring": "Recursively compute all subclasses of `obj`.\n\n::: {.callout-note}\n## The resulting iterator does **not** include the input type object.\n:::\n\nParameters\n----------\nobj\n    Any type object\n\nExamples\n--------\n>>> class Base: ...\n>>> class Subclass1(Base): ...\n>>> class Subclass2(Base): ...\n>>> class TransitiveSubclass(Subclass2): ...\n\nEverything inherits `Base` (directly or transitively)\n\n>>> list(get_subclasses(Base))\n[<class 'ibis.util.Subclass1'>, <class 'ibis.util.Subclass2'>, <class 'ibis.util.TransitiveSubclass'>]\n\nNothing inherits from `Subclass1`\n\n>>> list(get_subclasses(Subclass1))\n[]\n\nOnly `TransitiveSubclass` inherits from `Subclass2`\n\n>>> list(get_subclasses(Subclass2))\n[<class 'ibis.util.TransitiveSubclass'>]\n\nNothing inherits from `TransitiveSubclass`\n\n>>> list(get_subclasses(TransitiveSubclass))\n[]", "type": "function"}
{"source": "ibis/__init__.py::__dir__", "docstring": "Adds tab completion for ibis backends to the top-level module.", "type": "function"}
{"source": "ibis/__init__.py::load_backend", "docstring": "Load backends in a lazy way with `ibis.<backend-name>`.\n\nThis also registers the backend options.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.sqlite.connect(...)\n\nWhen accessing the `sqlite` attribute of the `ibis` module, this function\nis called, and a backend with the `sqlite` name is tried to load from\nthe `ibis.backends` entrypoints. If successful, the `ibis.sqlite`\nattribute is \"cached\", so this function is only called the first time.", "type": "function"}
{"source": "ibis/selectors.py::where", "docstring": "Select columns that satisfy `predicate`.\n\nUse this selector when one of the other selectors does not meet your needs.\n\nParameters\n----------\npredicate\n    A callable that accepts an ibis value expression and returns a `bool`\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(a=\"float32\"), name=\"t\")\n>>> expr = t.select(s.where(lambda col: col.get_name() == \"a\"))\n>>> expr.columns\n('a',)", "type": "function"}
{"source": "ibis/selectors.py::numeric", "docstring": "Return numeric columns.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(a=\"int\", b=\"string\", c=\"array<string>\"), name=\"t\")\n>>> t.columns\n('a', 'b', 'c')\n>>> expr = t.select(s.numeric())  # `a` has integer type, so it's numeric\n>>> expr.columns\n('a',)\n\nSee Also\n--------\n[`of_type`](#ibis.selectors.of_type)", "type": "function"}
{"source": "ibis/selectors.py::of_type", "docstring": "Select columns of type `dtype`.\n\nParameters\n----------\ndtype\n    `DataType` instance, `str` or `DataType` class\n\nExamples\n--------\nSelect according to a specific `DataType` instance\n\n>>> import ibis\n>>> import ibis.expr.datatypes as dt\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(name=\"string\", siblings=\"array<string>\", parents=\"array<int64>\"))\n>>> expr = t.select(s.of_type(dt.Array(dt.string)))\n>>> expr.columns\n('siblings',)\n\nStrings are also accepted\n\n>>> expr = t.select(s.of_type(\"array<string>\"))\n>>> expr.columns\n('siblings',)\n\nAbstract/unparametrized types may also be specified by their string name\n(e.g. \"integer\" for any integer type), or by passing in a `DataType` class\ninstead. The following options are equivalent.\n\n>>> expr1 = t.select(s.of_type(\"array\"))\n>>> expr2 = t.select(s.of_type(dt.Array))\n>>> expr1.equals(expr2)\nTrue\n>>> expr2.columns\n('siblings', 'parents')\n\nSee Also\n--------\n[`numeric`](#ibis.selectors.numeric)", "type": "function"}
{"source": "ibis/selectors.py::startswith", "docstring": "Select columns whose name starts with one of `prefixes`.\n\nParameters\n----------\nprefixes\n    Prefixes to compare column names against\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(apples=\"int\", oranges=\"float\", bananas=\"bool\"), name=\"t\")\n>>> expr = t.select(s.startswith((\"a\", \"b\")))\n>>> expr.columns\n('apples', 'bananas')\n\nSee Also\n--------\n[`endswith`](#ibis.selectors.endswith)", "type": "function"}
{"source": "ibis/selectors.py::endswith", "docstring": "Select columns whose name ends with one of `suffixes`.\n\nParameters\n----------\nsuffixes\n    Suffixes to compare column names against\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.endswith(\"id\"))\n>>> expr.columns\n('model_id', 'user_id')\n\nSee Also\n--------\n[`startswith`](#ibis.selectors.startswith)", "type": "function"}
{"source": "ibis/selectors.py::contains", "docstring": "Return columns whose name contains `needles`.\n\nParameters\n----------\nneedles\n    One or more strings to search for in column names\nhow\n    A boolean reduction to allow the configuration of how `needles` are summarized.\n\nExamples\n--------\nSelect columns that contain either `\"a\"` or `\"b\"`\n\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(\n...     dict(a=\"int64\", b=\"string\", c=\"float\", d=\"array<int16>\", ab=\"struct<x: int>\")\n... )\n>>> expr = t.select(s.contains((\"a\", \"b\")))\n>>> expr.columns\n('a', 'b', 'ab')\n\nSelect columns that contain all of `\"a\"` and `\"b\"`, that is, both `\"a\"` and\n`\"b\"` must be in each column's name to match.\n\n>>> expr = t.select(s.contains((\"a\", \"b\"), how=all))\n>>> expr.columns\n('ab',)\n\nSee Also\n--------\n[`matches`](#ibis.selectors.matches)", "type": "function"}
{"source": "ibis/selectors.py::matches", "docstring": "Return columns whose name matches the regular expression `regex`.\n\nParameters\n----------\nregex\n    A string or `re.Pattern` object\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(ab=\"string\", abc=\"int\", be=\"array<string>\"))\n>>> expr = t.select(s.matches(r\"ab+\"))\n>>> expr.columns\n('ab', 'abc')\n\nSee Also\n--------\n[`contains`](#ibis.selectors.contains)", "type": "function"}
{"source": "ibis/selectors.py::any_of", "docstring": "Include columns satisfying any of `predicates`.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.any_of(s.endswith(\"id\"), s.startswith(\"m\")))\n>>> expr.columns\n('model_id', 'model_name', 'user_id')", "type": "function"}
{"source": "ibis/selectors.py::all_of", "docstring": "Include columns satisfying all of `predicates`.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.all_of(s.endswith(\"id\"), s.startswith(\"m\")))\n>>> expr.columns\n('model_id',)", "type": "function"}
{"source": "ibis/selectors.py::cols", "docstring": "Select specific column names.\n\nParameters\n----------\nnames\n    The column names to select\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table({\"a\": \"int\", \"b\": \"int\", \"c\": \"int\"})\n>>> expr = t.select(s.cols(\"a\", \"b\"))\n>>> expr.columns\n('a', 'b')\n\nSee Also\n--------\n[`index`](#ibis.selectors.cols)", "type": "function"}
{"source": "ibis/selectors.py::across", "docstring": "Apply data transformations across multiple columns.\n\nParameters\n----------\nselector\n    An expression that selects columns on which the transformation function\n    will be applied, an iterable of `str` column names or a single `str`\n    column name.\nfunc\n    A function (or dictionary of functions) to use to transform the data.\nnames\n    A lambda function or a format string to name the columns created by the\n    transformation function.\n\nReturns\n-------\nAcross\n    An `Across` selector object\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from ibis import _, selectors as s\n>>> t = ibis.examples.penguins.fetch()\n>>> t.select(s.startswith(\"bill\")).mutate(\n...     s.across(s.numeric(), dict(centered=_ - _.mean()), names=\"{fn}_{col}\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503 bill_depth_mm \u2503 centered_bill_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502 float64       \u2502 float64                 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502           39.1 \u2502          18.7 \u2502                -4.82193 \u2502 \u2026 \u2502\n\u2502           39.5 \u2502          17.4 \u2502                -4.42193 \u2502 \u2026 \u2502\n\u2502           40.3 \u2502          18.0 \u2502                -3.62193 \u2502 \u2026 \u2502\n\u2502           NULL \u2502          NULL \u2502                    NULL \u2502 \u2026 \u2502\n\u2502           36.7 \u2502          19.3 \u2502                -7.22193 \u2502 \u2026 \u2502\n\u2502           39.3 \u2502          20.6 \u2502                -4.62193 \u2502 \u2026 \u2502\n\u2502           38.9 \u2502          17.8 \u2502                -5.02193 \u2502 \u2026 \u2502\n\u2502           39.2 \u2502          19.6 \u2502                -4.72193 \u2502 \u2026 \u2502\n\u2502           34.1 \u2502          18.1 \u2502                -9.82193 \u2502 \u2026 \u2502\n\u2502           42.0 \u2502          20.2 \u2502                -1.92193 \u2502 \u2026 \u2502\n\u2502              \u2026 \u2502             \u2026 \u2502                       \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/selectors.py::if_any", "docstring": "Return the **disjunction** of `predicate` applied on all `selector` columns.\n\nParameters\n----------\nselector\n    A column selector\npredicate\n    A callable or deferred object defining a predicate to apply to each\n    column from `selector`.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import selectors as s, _\n>>> ibis.options.interactive = True\n>>> penguins = ibis.examples.penguins.fetch().mutate(idx=ibis.row_number().over())\n>>> cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n>>> expr = penguins.mutate(cols).filter(s.if_any(s.endswith(\"_mm\"), _.abs() > 2))\n>>> expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() > 2)\n...     | (_.bill_depth_mm.abs() > 2)\n...     | (_.flipper_length_mm.abs() > 2)\n... )\n>>> expr.equals(expr_by_hand)\nTrue\n>>> expr.order_by(_.idx)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 float64           \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502      -0.974787 \u2502      2.050255 \u2502         -0.705121 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502       0.380628 \u2502      2.202170 \u2502         -0.491775 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Biscoe    \u2502      -1.103002 \u2502      0.733662 \u2502         -2.056307 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502      -0.297079 \u2502      2.050255 \u2502         -0.705121 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502      -2.165354 \u2502     -0.836123 \u2502         -0.918466 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       0.398944 \u2502     -2.000802 \u2502          0.717181 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.113285 \u2502     -0.431017 \u2502          2.068368 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502      -0.187181 \u2502     -2.051440 \u2502          1.001641 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       2.871660 \u2502     -0.076550 \u2502          2.068368 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.900890 \u2502     -0.734846 \u2502          2.139483 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/selectors.py::if_all", "docstring": "Return the **conjunction** of `predicate` applied on all `selector` columns.\n\nParameters\n----------\nselector\n    A column selector\npredicate\n    A callable or deferred object defining a predicate to apply to each\n    column from `selector`.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import selectors as s, _\n>>> ibis.options.interactive = True\n>>> penguins = ibis.examples.penguins.fetch()\n>>> cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n>>> expr = penguins.mutate(cols).filter(s.if_all(s.endswith(\"_mm\"), _.abs() > 1))\n>>> expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() > 1)\n...     & (_.bill_depth_mm.abs() > 1)\n...     & (_.flipper_length_mm.abs() > 1)\n... )\n>>> expr.equals(expr_by_hand)\nTrue\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 float64           \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Dream     \u2502      -1.157951 \u2502      1.088129 \u2502         -1.416272 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502      -1.231217 \u2502      1.138768 \u2502         -1.202926 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.149917 \u2502     -1.443781 \u2502          1.214987 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.040019 \u2502     -1.089314 \u2502          1.072757 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.131601 \u2502     -1.089314 \u2502          1.712792 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.241499 \u2502     -1.089314 \u2502          1.570562 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.351398 \u2502     -1.494420 \u2502          1.214987 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/selectors.py::first", "docstring": "Return the first column of a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.first())\n>>> expr.columns\n('model_id',)", "type": "function"}
{"source": "ibis/selectors.py::last", "docstring": "Return the last column of a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.last())\n>>> expr.columns\n('user_id',)", "type": "function"}
{"source": "ibis/selectors.py::all", "docstring": "Return every column from a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.all())\n>>> expr.columns\n('model_id', 'model_name', 'user_id')", "type": "function"}
{"source": "ibis/selectors.py::none", "docstring": "Return no columns.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"color\": [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Blue\"],\n...     }\n... )\n\n`s.none()` results in an empty expansion.\n\n>>> s.none().expand(t)\n[]\n\nThis can be useful when you want to pivot a table without identifying unique\nobservations.\n\n>>> t.pivot_wider(\n...     id_cols=s.none(),\n...     names_from=\"color\",\n...     values_from=\"color\",\n...     values_agg=\"count\",\n...     names_sort=True,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Blue  \u2503 Green \u2503 Red   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3 \u2502     1 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/selectors.py::_to_selector", "docstring": "Convert an object to a `Selector`.", "type": "function"}
{"source": ".github/workflows/algolia/upload-algolia-api.py::_grab_qmd_functions", "docstring": "Quartodoc generated files have top-level function headers that look like.\n\n      # connect { #ibis.connect }\n\n     `ibis.connect(resource, **kwargs)`\n\n      Connect to `resource`, inferring the backend automatically.\n\nor similar. These don't get scraped by `quarto` (yet) because it doesn't\nknow about `quartodoc`.\n\nWe grab the functions using a regex, then grab the text between that\nfunction line and the next `#` sign and take that as the \"content\" of the\nrecord. This is a rough heuristic, but it works better than the previous\nnothing.", "type": "function"}
{"source": ".github/workflows/algolia/upload-algolia-api.py::adjust_backend_custom_attributes", "docstring": "Adjusts attributes of the Algolia records.\n\nTwo custom attribute changes:\n    One is the name of the backend, which we can possibly use for grouping\n    or filtering results.\n\n    The other is a marker of whether the record is part of the core\n    expression API, which we can use to sort results so that generic table\n    expressions appear above backend-specific ones in the case of\n    name-collisions.\n\nWe also strip out the \"text\" attribute if it's empty", "type": "function"}
{"source": "ibis/streamlit/__init__.py::_connect", "docstring": "Connect to the backend and return a client object.\n\nThis method is invoked when `st.connection` is called and pulls\ninformation from streamlit secrets. `_connect` is part of the streamlit\nconnection API to be implemented by developers of specific connection\ntypes.\n\nHere's an example not-so-secret configuration:\n\n```toml\n[connections.ch]\nurl = \"clickhouse://play:clickhouse@play.clickhouse.com:9440/?secure=1\"\n```\n\nAlternatively, you can specify individual arguments under a connection\nwhose name matches the backend type. For example:\n\n```toml\n[connections.clickhouse]\nuser = \"play\"\npassword = \"clickhouse\"\nhost = \"play.clickhouse.com\"\nport = 9440\nsecure = 1\n```\n\nThis file can be placed at `~/.streamlit/secrets.toml`.\n\nYou can then connect to the backend using:\n\n```python\nimport streamlit as st\n\nfrom ibis.streamlit import IbisConnection\n\ncon = st.connection(\"ch\", type=IbisConnection)\n\n# Now you can use `con` as if it were an ibis backend\ncon.list_tables()\n```", "type": "function"}
{"source": "ibis/formats/pyarrow.py::to_ibis", "docstring": "Convert a pyarrow type to an ibis type.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::from_ibis", "docstring": "Convert an ibis type to a pyarrow type.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::from_ibis", "docstring": "Convert a schema to a pyarrow schema.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::to_ibis", "docstring": "Convert a pyarrow schema to a schema.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::infer_scalar", "docstring": "Infer the ibis type of a scalar.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::infer_column", "docstring": "Infer the ibis type of a sequence.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::infer_table", "docstring": "Infer the schema of a table.", "type": "function"}
{"source": "ibis/formats/pyarrow.py::to_pyarrow_dataset", "docstring": "Return the dataset object itself.\n\nUse with backends that can perform pushdowns into dataset objects.", "type": "function"}
{"source": "ibis/formats/__init__.py::from_ibis", "docstring": "Convert an Ibis DataType to a format-specific type object.\n\nParameters\n----------\ndtype\n    The Ibis DataType to convert.\n\nReturns\n-------\nFormat-specific type object.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_ibis", "docstring": "Convert a format-specific type object to an Ibis DataType.\n\nParameters\n----------\ntyp\n    The format-specific type object to convert.\nnullable\n    Whether the Ibis DataType should be nullable.\n\nReturns\n-------\nIbis DataType.", "type": "function"}
{"source": "ibis/formats/__init__.py::from_string", "docstring": "Convert a backend-specific string representation into an Ibis DataType.\n\nParameters\n----------\ntext\n    The backend-specific string representation to convert.\nnullable\n    Whether the Ibis DataType should be nullable.\n\nReturns\n-------\nIbis DataType.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_string", "docstring": "Convert `dtype` into a backend-specific string representation.\n\nParameters\n----------\ndtype\n    The Ibis DataType to convert.\n\nReturns\n-------\nBackend-specific string representation.", "type": "function"}
{"source": "ibis/formats/__init__.py::from_ibis", "docstring": "Convert an Ibis Schema to a format-specific schema object.\n\nParameters\n----------\nschema\n    The Ibis Schema to convert.\n\nReturns\n-------\nFormat-specific schema object.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_ibis", "docstring": "Convert a format-specific schema object to an Ibis Schema.\n\nParameters\n----------\nobj\n    The format-specific schema object to convert.\n\nReturns\n-------\nIbis Schema.", "type": "function"}
{"source": "ibis/formats/__init__.py::convert_scalar", "docstring": "Convert a format-specific scalar to the given ibis datatype.\n\nParameters\n----------\nobj\n    The format-specific scalar value to convert.\ndtype\n    The Ibis datatype to convert to.\n\nReturns\n-------\nFormat specific scalar corresponding to the given Ibis datatype.", "type": "function"}
{"source": "ibis/formats/__init__.py::convert_column", "docstring": "Convert a format-specific column to the given ibis datatype.\n\nParameters\n----------\nobj\n    The format-specific column value to convert.\ndtype\n    The Ibis datatype to convert to.\n\nReturns\n-------\nFormat specific column corresponding to the given Ibis datatype.", "type": "function"}
{"source": "ibis/formats/__init__.py::convert_table", "docstring": "Convert a format-specific table to the given ibis schema.\n\nParameters\n----------\nobj\n    The format-specific table-like object to convert.\nschema\n    The Ibis schema to convert to.\n\nReturns\n-------\nFormat specific table-like object corresponding to the given Ibis schema.", "type": "function"}
{"source": "ibis/formats/__init__.py::infer_scalar", "docstring": "Infer the Ibis datatype of a format-specific scalar.\n\nParameters\n----------\nobj\n    The format-specific scalar to infer the Ibis datatype of.\n\nReturns\n-------\nIbis datatype corresponding to the given format-specific scalar.", "type": "function"}
{"source": "ibis/formats/__init__.py::infer_column", "docstring": "Infer the Ibis datatype of a format-specific column.\n\nParameters\n----------\nobj\n    The format-specific column to infer the Ibis datatype of.\n\nReturns\n-------\nIbis datatype corresponding to the given format-specific column.", "type": "function"}
{"source": "ibis/formats/__init__.py::infer_table", "docstring": "Infer the Ibis schema of a format-specific table.\n\nParameters\n----------\nobj\n    The format-specific table to infer the Ibis schema of.\n\nReturns\n-------\nIbis schema corresponding to the given format-specific table.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_frame", "docstring": "Convert this input to a pandas DataFrame.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_pyarrow", "docstring": "Convert this input to a PyArrow Table.", "type": "function"}
{"source": "ibis/formats/__init__.py::to_polars", "docstring": "Convert this input to a Polars DataFrame.", "type": "function"}
{"source": "ibis/formats/polars.py::to_ibis", "docstring": "Convert a polars type to an ibis type.", "type": "function"}
{"source": "ibis/formats/polars.py::from_ibis", "docstring": "Convert an ibis type to a polars type.", "type": "function"}
{"source": "ibis/formats/polars.py::from_ibis", "docstring": "Convert a schema to a polars schema.", "type": "function"}
{"source": "ibis/formats/polars.py::to_ibis", "docstring": "Convert a polars schema to a schema.", "type": "function"}
{"source": "ibis/formats/polars.py::infer_scalar", "docstring": "Infer the ibis type of a scalar.", "type": "function"}
{"source": "ibis/formats/polars.py::infer_column", "docstring": "Infer the ibis type of a sequence.", "type": "function"}
{"source": "ibis/formats/polars.py::infer_table", "docstring": "Infer the schema of a table.", "type": "function"}
{"source": "ibis/backends/conftest.py::_get_backend_conf", "docstring": "Convert a backend string to the test class for the backend.", "type": "function"}
{"source": "ibis/backends/conftest.py::_get_backend_from_parts", "docstring": "Return the backend part of a test file's path parts.\n\nExamples\n--------\n>>> _get_backend_from_parts((\"/\", \"ibis\", \"backends\", \"sqlite\", \"tests\"))\n\"sqlite\"", "type": "function"}
{"source": "ibis/backends/conftest.py::_get_backends_to_test", "docstring": "Get a list of `TestConf` classes of the backends to test.", "type": "function"}
{"source": "ibis/backends/conftest.py::pytest_runtest_call", "docstring": "Dynamically add various custom markers.", "type": "function"}
{"source": "ibis/backends/conftest.py::_get_backend_cls", "docstring": "Convert a backend string to the test class for the backend.", "type": "function"}
{"source": "ibis/backends/conftest.py::backend_cls", "docstring": "Return the uninstantiated backend class, unconnected.\n\nThis is used for signature checking and nothing should be executed.", "type": "function"}
{"source": "ibis/backends/conftest.py::backend", "docstring": "Return an instance of BackendTest, loaded with data.", "type": "function"}
{"source": "ibis/backends/conftest.py::con", "docstring": "Instance of a backend client.", "type": "function"}
{"source": "ibis/backends/conftest.py::backend_no_data", "docstring": "Return an instance of BackendTest, with no data loaded.", "type": "function"}
{"source": "ibis/backends/conftest.py::con_no_data", "docstring": "Return an Ibis backend instance, with no data loaded.", "type": "function"}
{"source": "ibis/backends/conftest.py::ddl_backend", "docstring": "Set up the backends that are SQL-based.", "type": "function"}
{"source": "ibis/backends/conftest.py::ddl_con", "docstring": "Instance of Client, already connected to the db (if applies).", "type": "function"}
{"source": "ibis/backends/conftest.py::udf_backend", "docstring": "Runs the UDF-supporting backends.", "type": "function"}
{"source": "ibis/backends/conftest.py::temp_table", "docstring": "Return a temporary table name.\n\nParameters\n----------\ncon : ibis.backends.Client\n\nYields\n------\nname : string\n    Random table name for a temporary usage.", "type": "function"}
{"source": "ibis/backends/conftest.py::temp_view", "docstring": "Return a temporary view name.\n\nParameters\n----------\nddl_con : backend connection\n\nYields\n------\nname : string\n    Random view name for a temporary usage.", "type": "function"}
{"source": "ibis/backends/__init__.py::TablesAccessor", "docstring": "A mapping-like object for accessing tables off a backend.\n\nTables may be accessed by name using either index or attribute access:\n\nExamples\n--------\n>>> con = ibis.sqlite.connect(\"example.db\")\n>>> people = con.tables[\"people\"]  # access via index\n>>> people = con.tables.people  # access via attribute", "type": "class"}
{"source": "ibis/backends/__init__.py::HasCurrentCatalog", "docstring": "Has a `current_catalog` property.", "type": "class"}
{"source": "ibis/backends/__init__.py::HasCurrentDatabase", "docstring": "Has a `current_database` property.", "type": "class"}
{"source": "ibis/backends/__init__.py::CacheHandler", "docstring": "A mixin for handling `.cache()`/`CachedTable` operations.", "type": "class"}
{"source": "ibis/backends/__init__.py::BaseBackend", "docstring": "Base backend class.\n\nAll Ibis backends must subclass this class and implement all the\nrequired methods.", "type": "class"}
{"source": "ibis/backends/__init__.py::_get_backend_names", "docstring": "Return the set of known backend names.\n\nParameters\n----------\nexclude\n    Exclude these backend names from the result\n\nNotes\n-----\nThis function returns a frozenset to prevent cache pollution.\n\nIf a `set` is used, then any in-place modifications to the set\nare visible to every caller of this function.", "type": "function"}
{"source": "ibis/backends/__init__.py::connect", "docstring": "Connect to `resource`, inferring the backend automatically.\n\nThe general pattern for `ibis.connect` is\n\n```python\ncon = ibis.connect(\"backend://connection-parameters\")\n```\n\nWith many backends that looks like\n\n```python\ncon = ibis.connect(\"backend://user:password@host:port/database\")\n```\n\nSee the connection syntax for each backend for details about URL connection\nrequirements.\n\nParameters\n----------\nresource\n    A URL or path to the resource to be connected to.\nkwargs\n    Backend specific keyword arguments\n\nExamples\n--------\nConnect to an in-memory DuckDB database:\n\n>>> import ibis\n>>> con = ibis.connect(\"duckdb://\")\n\nConnect to an on-disk SQLite database:\n\n>>> con = ibis.connect(\"sqlite://relative.db\")\n>>> con = ibis.connect(\n...     \"sqlite:///absolute/path/to/data.db\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nConnect to a PostgreSQL server:\n\n>>> con = ibis.connect(\n...     \"postgres://user:password@hostname:5432\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nConnect to BigQuery:\n\n>>> con = ibis.connect(\n...     \"bigquery://my-project/my-dataset\"\n... )  # quartodoc: +SKIP # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/__init__.py::to_pandas", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\n::: {.callout-note}\nThis method is a wrapper around `execute`.\n:::\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "type": "function"}
{"source": "ibis/backends/__init__.py::to_pandas_batches", "docstring": "Execute an Ibis expression and return an iterator of pandas `DataFrame`s.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nchunk_size\n    Maximum number of rows in each returned `DataFrame` batch. This may have\n    no effect depending on the backend.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nIterator[pd.DataFrame]\n    An iterator of pandas `DataFrame`s.", "type": "function"}
{"source": "ibis/backends/__init__.py::to_pyarrow", "docstring": "Execute expression to a pyarrow object.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresult\n    If the passed expression is a Table, a pyarrow table is returned.\n    If the passed expression is a Column, a pyarrow array is returned.\n    If the passed expression is a Scalar, a pyarrow scalar is returned.", "type": "function"}
{"source": "ibis/backends/__init__.py::to_polars", "docstring": "Execute expression and return results in as a polars DataFrame.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to polars.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\ndataframe\n    A polars DataFrame holding the results of the executed expression.", "type": "function"}
{"source": "ibis/backends/__init__.py::to_pyarrow_batches", "docstring": "Execute expression and return a RecordBatchReader.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nchunk_size\n    Maximum number of rows in each returned record batch.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresults\n    RecordBatchReader", "type": "function"}
{"source": "ibis/backends/__init__.py::to_torch", "docstring": "Execute an expression and return results as a dictionary of torch tensors.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Parameters to substitute into the expression.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nkwargs\n    Keyword arguments passed into the backend's `to_torch` implementation.\n\nReturns\n-------\ndict[str, torch.Tensor]\n    A dictionary of torch tensors, keyed by column name.", "type": "function"}
{"source": "ibis/backends/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/__init__.py::read_csv", "docstring": "Register a CSV file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source. A string or Path to the CSV file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/__init__.py::read_json", "docstring": "Register a JSON file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source. A string or Path to the JSON file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/__init__.py::read_delta", "docstring": "Register a Delta Lake table in the current database.\n\nParameters\n----------\npath\n    The data source. Must be a directory containing a Delta Lake table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the underlying backend or library.\n\nReturns\n-------\nir.Table\n    The just-registered table.", "type": "function"}
{"source": "ibis/backends/__init__.py::to_parquet", "docstring": "Write the results of executing the given expression to a parquet file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\npath\n    The data source. A string or Path to the parquet file.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.parquet.ParquetWriter\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetWriter.html", "type": "function"}
{"source": "ibis/backends/__init__.py::to_parquet_dir", "docstring": "Write the results of executing the given expression to a parquet file in a directory.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\ndirectory\n    The data source. A string or Path to the directory where the parquet file will be written.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.dataset.write_dataset\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.dataset.write_dataset.html", "type": "function"}
{"source": "ibis/backends/__init__.py::to_csv", "docstring": "Write the results of executing the given expression to a CSV file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to CSV.\npath\n    The data source. A string or Path to the CSV file.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments passed to pyarrow.csv.CSVWriter\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.csv.CSVWriter.html", "type": "function"}
{"source": "ibis/backends/__init__.py::to_delta", "docstring": "Write the results of executing the given expression to a Delta Lake table.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to Delta Lake table.\npath\n    The data source. A string or Path to the Delta Lake table.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments passed to deltalake.writer.write_deltalake method", "type": "function"}
{"source": "ibis/backends/__init__.py::to_json", "docstring": "Write the results of `expr` to a json file of [{column -> value}, ...] objects.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to Delta Lake table.\npath\n    The data source. A string or Path to the Delta Lake table.\nkwargs\n    Additional, backend-specifc keyword arguments.", "type": "function"}
{"source": "ibis/backends/__init__.py::current_catalog", "docstring": "The name of the current catalog in the backend.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n\nReturns\n-------\nstr\n    The name of the current catalog.", "type": "function"}
{"source": "ibis/backends/__init__.py::current_database", "docstring": "The name of the current database in the backend.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n\nReturns\n-------\nstr\n    The name of the current database.", "type": "function"}
{"source": "ibis/backends/__init__.py::list_catalogs", "docstring": "List existing catalogs in the current connection.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nlike\n    A pattern in Python's regex format to filter returned catalog names.\n\nReturns\n-------\nlist[str]\n    The catalog names that exist in the current connection, that match\n    the `like` pattern if provided.", "type": "function"}
{"source": "ibis/backends/__init__.py::create_catalog", "docstring": "Create a new catalog.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the new catalog.\nforce\n    If `False`, an exception is raised if the catalog already exists.", "type": "function"}
{"source": "ibis/backends/__init__.py::drop_catalog", "docstring": "Drop a catalog with name `name`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Catalog to drop.\nforce\n    If `False`, an exception is raised if the catalog does not exist.", "type": "function"}
{"source": "ibis/backends/__init__.py::list_databases", "docstring": "List existing databases in the current connection.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nlike\n    A pattern in Python's regex format to filter returned database\n    names.\ncatalog\n    The catalog to list databases from. If `None`, the current catalog\n    is searched.\n\nReturns\n-------\nlist[str]\n    The database names that exist in the current connection, that match\n    the `like` pattern if provided.", "type": "function"}
{"source": "ibis/backends/__init__.py::create_database", "docstring": "Create a database named `name` in `catalog`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the database to create.\ncatalog\n    Name of the catalog in which to create the database. If `None`, the\n    current catalog is used.\nforce\n    If `False`, an exception is raised if the database exists.", "type": "function"}
{"source": "ibis/backends/__init__.py::drop_database", "docstring": "Drop the database with `name` in `catalog`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the schema to drop.\ncatalog\n    Name of the catalog to drop the database from.\n    If `None`, the current catalog is used.\nforce\n    If `False`, an exception is raised if the database does not exist.", "type": "function"}
{"source": "ibis/backends/__init__.py::_cached_table", "docstring": "Convert a Table to a CachedTable.\n\nParameters\n----------\ntable\n    Table expression to cache\n\nReturns\n-------\nTable\n    Cached table", "type": "function"}
{"source": "ibis/backends/__init__.py::_finalize_cached_table", "docstring": "Release a cached table given its name.\n\nThis is a no-op if the cached table is already released.\n\nParameters\n----------\nname\n    The name of the cached table.", "type": "function"}
{"source": "ibis/backends/__init__.py::dialect", "docstring": "The sqlglot dialect for this backend, where applicable.\n\nReturns None if the backend is not a SQL backend.", "type": "function"}
{"source": "ibis/backends/__init__.py::db_identity", "docstring": "Return the identity of the database.\n\nMultiple connections to the same\ndatabase will return the same value for `db_identity`.\n\nThe default implementation assumes connection parameters uniquely\nspecify the database.\n\nReturns\n-------\nHashable\n    Database identity", "type": "function"}
{"source": "ibis/backends/__init__.py::connect", "docstring": "Connect to the database.\n\nParameters\n----------\n*args\n    Mandatory connection parameters, see the docstring of `do_connect`\n    for details.\n**kwargs\n    Extra connection parameters, see the docstring of `do_connect` for\n    details.\n\nNotes\n-----\nThis creates a new backend instance with saved `args` and `kwargs`,\nthen calls `reconnect` and finally returns the newly created and\nconnected backend instance.\n\nReturns\n-------\nBaseBackend\n    An instance of the backend", "type": "function"}
{"source": "ibis/backends/__init__.py::disconnect", "docstring": "Close the connection to the backend.", "type": "function"}
{"source": "ibis/backends/__init__.py::_convert_kwargs", "docstring": "Manipulate keyword arguments to `.connect` method.", "type": "function"}
{"source": "ibis/backends/__init__.py::reconnect", "docstring": "Reconnect to the database already configured with connect.", "type": "function"}
{"source": "ibis/backends/__init__.py::do_connect", "docstring": "Connect to database specified by `args` and `kwargs`.", "type": "function"}
{"source": "ibis/backends/__init__.py::_filter_with_like", "docstring": "Filter names with a `like` pattern (regex).\n\nThe methods `list_databases` and `list_tables` accept a `like`\nargument, which filters the returned tables with tables that match the\nprovided pattern.\n\nWe provide this method in the base backend, so backends can use it\ninstead of reinventing the wheel.\n\nParameters\n----------\nvalues\n    Iterable of strings to filter\nlike\n    Pattern to use for filtering names\n\nReturns\n-------\nlist[str]\n    Names filtered by the `like` pattern.", "type": "function"}
{"source": "ibis/backends/__init__.py::list_tables", "docstring": "The table names that match `like` in the given `database`.\n\nFor some backends, the tables may be files in a directory,\nor other equivalent entities in a SQL database.\n\nParameters\n----------\nlike\n    A pattern in Python's regex format.\ndatabase\n    The database, or (catalog, database) from which to list tables.\n\n    For backends that support a single-level table hierarchy,\n    you can pass in a string like `\"bar\"`.\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.\n    If not provided, the current database\n    (and catalog, if applicable for this backend) is used.\n\n    See the\n    [Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\n    for more info.\n\nReturns\n-------\nlist[str]\n    The list of the table names that match the pattern `like`.\n\nExamples\n--------\nThis example uses the DuckDB backend, but the list_tables API\nworks the same for other backends.\n\n>>> import ibis\n>>> con = ibis.duckdb.connect()\n>>> foo = con.create_table(\"foo\", schema=ibis.schema(dict(a=\"int\")))\n>>> con.list_tables()\n['foo']\n>>> bar = con.create_view(\"bar\", foo)\n>>> con.list_tables()\n['bar', 'foo']\n>>> con.create_database(\"my_database\")\n>>> con.list_tables(database=\"my_database\")\n[]\n>>> con.raw_sql(\"CREATE TABLE my_database.baz (a INTEGER)\")  # doctest: +ELLIPSIS\n<duckdb.duckdb.DuckDBPyConnection object at 0x...>\n>>> con.list_tables(database=\"my_database\")\n['baz']", "type": "function"}
{"source": "ibis/backends/__init__.py::table", "docstring": "Construct a table expression from the corresponding table in the backend.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    The database, or (catalog, database) from which to get the table.\n\n    For backends that support a single-level table hierarchy,\n    you can pass in a string like `\"bar\"`.\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.\n    If not provided, the current database\n    (and catalog, if applicable for this backend) is used.\n\n    See the\n    [Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\n    for more info.\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> import ibis\n>>> backend = ibis.duckdb.connect()\n\nGet the \"foo\" table from the current database\n(and catalog, if applicable for this backend):\n\n>>> backend.table(\"foo\")  # doctest: +SKIP\n\nGet the \"foo\" table from the \"bar\" database\n(in DuckDB's language they would say the \"bar\" schema,\nin SQL this would be `\"bar\".\"foo\"`)\n\n>>> backend.table(\"foo\", database=\"bar\")  # doctest: +SKIP\n\nGet the \"foo\" table from the \"bar\" database, within the \"baz\" catalog\n(in DuckDB's language they would say the \"bar\" schema, and \"baz\" database,\nin SQL this would be `\"baz\".\"bar\".\"foo\"`)\n\n>>> backend.table(\"foo\", database=(\"baz\", \"bar\"))  # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/__init__.py::tables", "docstring": "An accessor for tables in the database.\n\nTables may be accessed by name using either index or attribute access:\n\nExamples\n--------\n>>> con = ibis.sqlite.connect(\"example.db\")\n>>> people = con.tables[\"people\"]  # access via index\n>>> people = con.tables.people  # access via attribute", "type": "function"}
{"source": "ibis/backends/__init__.py::version", "docstring": "Return the version of the backend engine.\n\nFor database servers, return the server version.\n\nFor others such as SQLite and pandas return the version of the\nunderlying library or application.\n\nReturns\n-------\nstr\n    The backend version", "type": "function"}
{"source": "ibis/backends/__init__.py::register_options", "docstring": "Register custom backend options.", "type": "function"}
{"source": "ibis/backends/__init__.py::_register_udfs", "docstring": "Register UDFs contained in `expr` with the backend.", "type": "function"}
{"source": "ibis/backends/__init__.py::_register_in_memory_table", "docstring": "Register an in-memory table associated with `op`.", "type": "function"}
{"source": "ibis/backends/__init__.py::_make_memtable_finalizer", "docstring": "Make a finalizer for an in-memory table.", "type": "function"}
{"source": "ibis/backends/__init__.py::_run_pre_execute_hooks", "docstring": "Backend-specific hooks to run before an expression is executed.", "type": "function"}
{"source": "ibis/backends/__init__.py::compile", "docstring": "Compile `expr` to a SQL string (for SQL backends) or a LazyFrame (for the polars backend).\n\nParameters\n----------\nexpr\n    An ibis expression to compile.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments", "type": "function"}
{"source": "ibis/backends/__init__.py::execute", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "type": "function"}
{"source": "ibis/backends/__init__.py::create_table", "docstring": "Create a new table.\n\nParameters\n----------\nname\n    Name of the new table.\nobj\n    An Ibis table expression or pandas table that will be used to\n    extract the schema and the data of the new table. If not provided,\n    `schema` must be given.\nschema\n    The schema for the new table. Only one of `schema` or `obj` can be\n    provided.\ndatabase\n    Name of the database where the table will be created, if not the\n    default.\ntemp\n    Whether a table is temporary or not\noverwrite\n    Whether to clobber existing data\n\nReturns\n-------\nTable\n    The table that was created.", "type": "function"}
{"source": "ibis/backends/__init__.py::drop_table", "docstring": "Drop a table.\n\nParameters\n----------\nname\n    Name of the table to drop.\ndatabase\n    Name of the database where the table exists, if not the default.\nforce\n    If `False`, an exception is raised if the table does not exist.", "type": "function"}
{"source": "ibis/backends/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "type": "function"}
{"source": "ibis/backends/__init__.py::create_view", "docstring": "Create a new view from an expression.\n\nParameters\n----------\nname\n    Name of the new view.\nobj\n    An Ibis table expression that will be used to create the view.\ndatabase\n    Name of the database where the view will be created, if not\n    provided the database's default is used.\noverwrite\n    Whether to clobber an existing view with the same name\n\nReturns\n-------\nir.Table\n    The view that was created.", "type": "function"}
{"source": "ibis/backends/__init__.py::drop_view", "docstring": "Drop a view.\n\nParameters\n----------\nname\n    Name of the view to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\nforce\n    If `False`, an exception is raised if the view does not exist.", "type": "function"}
{"source": "ibis/backends/__init__.py::has_operation", "docstring": "Return whether the backend implements support for `operation`.\n\nParameters\n----------\noperation\n    A class corresponding to an operation.\n\nReturns\n-------\nbool\n    Whether the backend implements the operation.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.expr.operations as ops\n>>> ibis.sqlite.has_operation(ops.ArrayIndex)\nFalse\n>>> ibis.postgres.has_operation(ops.ArrayIndex)\nTrue", "type": "function"}
{"source": "ibis/backends/__init__.py::_load_parquet", "docstring": "Load an example Apache Parquet file.", "type": "function"}
{"source": "ibis/backends/__init__.py::_load_csv", "docstring": "Load an example CSV file.", "type": "function"}
{"source": "ibis/backends/__init__.py::_from_url", "docstring": "Connect to a backend using a URL `url`.\n\nParameters\n----------\nurl\n    URL with which to connect to a backend.\nkwargs\n    Additional keyword arguments\n\nReturns\n-------\nBaseBackend\n    A backend instance", "type": "function"}
{"source": "ibis/backends/__init__.py::_from_url", "docstring": "Connect to the backend with empty url.\n\nParameters\n----------\nurl : str\n    The URL with which to connect to the backend. This parameter is not used\n    in this method but is kept for consistency.\nkwargs\n    Additional keyword arguments.\n\nReturns\n-------\nBaseBackend\n    A backend instance", "type": "function"}
{"source": "ibis/backends/__init__.py::_make_memtable_finalizer", "docstring": "No-op because temporary tables are automatically cleaned up.", "type": "function"}
{"source": "ibis/tests/util.py::assert_equal", "docstring": "Assert that two ibis objects are equal.", "type": "function"}
{"source": "ibis/tests/util.py::assert_pickle_roundtrip", "docstring": "Assert that an ibis object remains the same after pickling and\nunpickling.", "type": "function"}
{"source": "ibis/tests/util.py::assert_decompile_roundtrip", "docstring": "Assert that an ibis expression remains the same after decompilation.\n\nParameters\n----------\nexpr\n    The expression to decompile.\nsnapshot\n    A snapshot fixture.\neq\n    A callable that returns whether two Ibis expressions are equal.\n    Defaults to `ibis.expr.types.Expr.equals`. Use this to adjust\n    comparison behavior for expressions that contain `SelfReference`\n    operations from table.view() calls, or other relations whose equality\n    is difficult to roundtrip.", "type": "function"}
{"source": "ibis/expr/builders.py::_finish_searched_case", "docstring": "Finish constructing a SearchedCase expression.\n\nThis is split out into a separate function to allow for deferred arguments\nto resolve.", "type": "function"}
{"source": "ibis/expr/builders.py::SearchedCaseBuilder", "docstring": "A case builder, used for constructing `ibis.case()` expressions.", "type": "class"}
{"source": "ibis/expr/builders.py::SimpleCaseBuilder", "docstring": "A case builder, used for constructing `Column.case()` expressions.", "type": "class"}
{"source": "ibis/expr/builders.py::WindowBuilder", "docstring": "An unbound window frame specification.\n\nNotes\n-----\nThis class is patterned after SQL window frame clauses.\n\nUsing `None` for `preceding` or `following` indicates an unbounded frame.\n\nUse 0 for `CURRENT ROW`.", "type": "class"}
{"source": "ibis/expr/builders.py::when", "docstring": "Add a new condition and result to the `CASE` expression.\n\nParameters\n----------\ncase_expr\n    Predicate expression to use for this case.\nresult_expr\n    Value when the case predicate evaluates to true.", "type": "function"}
{"source": "ibis/expr/builders.py::else_", "docstring": "Add a default value for the `CASE` expression.\n\nParameters\n----------\nresult_expr\n    Value to use when all case predicates evaluate to false.", "type": "function"}
{"source": "ibis/expr/builders.py::end", "docstring": "Finish the `CASE` expression.", "type": "function"}
{"source": "ibis/expr/builders.py::when", "docstring": "Add a new condition and result to the `CASE` expression.\n\nParameters\n----------\ncase_expr\n    Expression to equality-compare with base expression. Must be\n    comparable with the base.\nresult_expr\n    Value when the case predicate evaluates to true.", "type": "function"}
{"source": "ibis/expr/builders.py::else_", "docstring": "Add a default value for the `CASE` expression.\n\nParameters\n----------\nresult_expr\n    Value to use when all case predicates evaluate to false.", "type": "function"}
{"source": "ibis/expr/builders.py::end", "docstring": "Finish the `CASE` expression.", "type": "function"}
{"source": "ibis/expr/rewrites.py::DerefMap", "docstring": "Trace and replace fields from earlier relations in the hierarchy.\n\nIn order to provide a nice user experience, we need to allow expressions\nfrom earlier relations in the hierarchy. Consider the following example:\n\nt = ibis.table([('a', 'int64'), ('b', 'string')], name='t')\nt1 = t.select([t.a, t.b])\nt2 = t1.filter(t.a > 0)  # note that not t1.a is referenced here\nt3 = t2.select(t.a)  # note that not t2.a is referenced here\n\nHowever the relational operations in the IR are strictly enforcing that\nthe expressions are referencing the immediate parent only. So we need to\ntrack fields upwards the hierarchy to replace `t.a` with `t1.a` and `t2.a`\nin the example above. This is called dereferencing.\n\nWhether we can treat or not a field of a relation semantically equivalent\nwith a field of an earlier relation in the hierarchy depends on the\n`.values` mapping of the relation. Leaf relations, like `t` in the example\nabove, have an empty `.values` mapping, so we cannot dereference fields\nfrom them. On the other hand a projection, like `t1` in the example above,\nhas a `.values` mapping like `{'a': t.a, 'b': t.b}`, so we can deduce that\n`t1.a` is semantically equivalent with `t.a` and so on.", "type": "class"}
{"source": "ibis/expr/rewrites.py::flatten_predicates", "docstring": "Yield the expressions corresponding to the `And` nodes of a predicate.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table([(\"a\", \"int64\"), (\"b\", \"string\")], name=\"t\")\n>>> filt = (t.a == 1) & (t.b == \"foo\")\n>>> predicates = flatten_predicates(filt.op())\n>>> len(predicates)\n2\n>>> predicates[0].to_expr().name(\"left\")\nr0 := UnboundTable: t\n  a int64\n  b string\nleft: r0.a == 1\n>>> predicates[1].to_expr().name(\"right\")\nr0 := UnboundTable: t\n  a int64\n  b string\nright: r0.b == 'foo'", "type": "function"}
{"source": "ibis/expr/rewrites.py::replace_parameter", "docstring": "Replace scalar parameters with their values.", "type": "function"}
{"source": "ibis/expr/rewrites.py::lower_stringslice", "docstring": "Rewrite StringSlice in terms of Substring.", "type": "function"}
{"source": "ibis/expr/rewrites.py::from_targets", "docstring": "Create a dereference map from a list of target relations.\n\nUsually a single relation is passed except for joins where multiple\nrelations are involved.\n\nParameters\n----------\nrels\n    The target relations to dereference to.\nextra\n    Extra substitutions to be added to the dereference map.\n\nReturns\n-------\nDerefMap", "type": "function"}
{"source": "ibis/expr/rewrites.py::backtrack", "docstring": "Backtrack the field in the relation hierarchy.\n\nThe field is traced back until no modification is made, so only follow\nops.Field nodes not arbitrary values.\n\nParameters\n----------\nvalue : ops.Value\n    The value to backtrack.\n\nYields\n------\ntuple[ops.Field, int]\n    The value node and the distance from the original value.", "type": "function"}
{"source": "ibis/expr/rewrites.py::dereference", "docstring": "Dereference values to target relations.\n\nAlso check for ambiguous field references. If a field reference is found\nwhich is marked as ambiguous, then raise an error.\n\nParameters\n----------\nvalues\n    Expression values to dereference.\n\nReturns\n-------\ntuple[ops.Value]\n    The dereferenced values.", "type": "function"}
{"source": "ibis/expr/format.py::type_info", "docstring": "Format `datatype` for display next to a column.", "type": "function"}
{"source": "ibis/expr/format.py::pretty", "docstring": "Pretty print an expression.\n\nParameters\n----------\nnode\n    The graph node to pretty print.\nscope\n    A dictionary of expression to name mappings used to intermediate\n    assignments. If not provided aliases will be generated for each\n    relation.\n\nReturns\n-------\nstr\n    A pretty printed representation of the expression.", "type": "function"}
{"source": "ibis/expr/rules.py::highest_precedence_dtype", "docstring": "Return the highest precedence type from the passed expressions.\n\nAlso verifies that there are valid implicit casts between any of the types\nand the selected highest precedence type.\nThis is a thin wrapper around datatypes highest precedence check.\n\nParameters\n----------\nnodes : Iterable[ops.Value]\n  A sequence of Expressions\n\nReturns\n-------\ndtype: DataType\n  The highest precedence datatype", "type": "function"}
{"source": "ibis/expr/rules.py::castable", "docstring": "Return whether source ir type is implicitly castable to target.\n\nBased on the underlying datatypes and the value in case of Literals", "type": "function"}
{"source": "ibis/expr/rules.py::ValueOf", "docstring": "Match a value of a specific type **instance**.\n\nThis is different from the Value[T] annotations which construct\nGenericCoercedTo(Value[T]) validators working with datatype types\nrather than instances.\n\nParameters\n----------\ndtype : DataType | None\n    The datatype the constructed Value instance should conform to.", "type": "class"}
{"source": "ibis/expr/api.py::param", "docstring": "Create a deferred parameter of a given type.\n\nParameters\n----------\ntype\n    The type of the unbound parameter, e.g., double, int64, date, etc.\n\nReturns\n-------\nScalar\n    A scalar expression backend by a parameter\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> start = ibis.param(\"date\")\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [date(2013, 1, 1), date(2013, 1, 2), date(2013, 1, 3)],\n...         \"value\": [1.0, 2.0, 3.0],\n...     },\n... )\n>>> expr = t.filter(t.date_col >= start).value.sum()\n>>> expr.execute(params={start: date(2013, 1, 1)})\n6.0\n>>> expr.execute(params={start: date(2013, 1, 2)})\n5.0\n>>> expr.execute(params={start: date(2013, 1, 3)})\n3.0", "type": "function"}
{"source": "ibis/expr/api.py::schema", "docstring": "Validate and return a [`Schema`](./schemas.qmd#ibis.expr.schema.Schema) object.\n\nParameters\n----------\npairs\n    List or dictionary of name, type pairs. Mutually exclusive with `names`\n    and `types` arguments.\nnames\n    Field names. Mutually exclusive with `pairs`.\ntypes\n    Field types. Mutually exclusive with `pairs`.\n\nReturns\n-------\nSchema\n    An ibis schema\n\nExamples\n--------\n>>> from ibis import schema, Schema\n>>> sc = schema([(\"foo\", \"string\"), (\"bar\", \"int64\"), (\"baz\", \"boolean\")])\n>>> sc = schema(names=[\"foo\", \"bar\", \"baz\"], types=[\"string\", \"int64\", \"boolean\"])\n>>> sc = schema({\"nullable-str\": \"string\", \"non-nullable-str\": \"!string\"})\n>>> sc = schema(dict(foo=\"string\"))\n>>> sc = schema(Schema(dict(foo=\"string\")))  # no-op", "type": "function"}
{"source": "ibis/expr/api.py::table", "docstring": "Create a table literal or an abstract table without data.\n\nIbis uses the word database to refer to a collection of tables, and the word\ncatalog to refer to a collection of databases. You can use a combination of\n`catalog` and `database` to specify a hierarchical location for table.\n\nParameters\n----------\nschema\n    A schema for the table\nname\n    Name for the table. One is generated if this value is `None`.\ncatalog\n    A collection of database.\ndatabase\n    A collection of tables. Required if catalog is not `None`.\n\nReturns\n-------\nTable\n    A table expression\n\nExamples\n--------\nCreate a table with no data backing it\n\n>>> import ibis\n>>> ibis.options.interactive = False\n>>> t = ibis.table(schema=dict(a=\"int\", b=\"string\"), name=\"t\")\n>>> t\nUnboundTable: t\n  a int64\n  b string\n\n\nCreate a table with no data backing it in a specific location\n\n>>> import ibis\n>>> ibis.options.interactive = False\n>>> t = ibis.table(schema=dict(a=\"int\"), name=\"t\", catalog=\"cat\", database=\"db\")\n>>> t\nUnboundTable: cat.db.t\n  a int64", "type": "function"}
{"source": "ibis/expr/api.py::memtable", "docstring": "Construct an ibis table expression from in-memory data.\n\nParameters\n----------\ndata\n    A table-like object (`pandas.DataFrame`, `pyarrow.Table`, or\n    `polars.DataFrame`), or any data accepted by the `pandas.DataFrame`\n    constructor (e.g. a list of dicts).\n\n    Note that ibis objects (e.g. `MapValue`) may not be passed in as part\n    of `data` and will result in an error.\n\n    Do not depend on the underlying storage type (e.g., pyarrow.Table),\n    it's subject to change across non-major releases.\ncolumns\n    Optional [](`typing.Iterable`) of [](`str`) column names. If provided,\n    must match the number of columns in `data`.\nschema\n    Optional [`Schema`](./schemas.qmd#ibis.expr.schema.Schema).\n    The functions use `data` to infer a schema if not passed.\n\nReturns\n-------\nTable\n    A table expression backed by in-memory data.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.memtable([{\"a\": 1}, {\"a\": 2}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a\n      0  1\n      1  2\n\n>>> t = ibis.memtable([{\"a\": 1, \"b\": \"foo\"}, {\"a\": 2, \"b\": \"baz\"}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n\nCreate a table literal without column names embedded in the data and pass\n`columns`\n\n>>> t = ibis.memtable([(1, \"foo\"), (2, \"baz\")], columns=[\"a\", \"b\"])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n\nCreate a table literal without column names embedded in the data. Ibis\ngenerates column names if none are provided.\n\n>>> t = ibis.memtable([(1, \"foo\"), (2, \"baz\")])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         col0 col1\n      0     1  foo\n      1     2  baz", "type": "function"}
{"source": "ibis/expr/api.py::desc", "docstring": "Create a descending sort key from `expr` or column name.\n\nParameters\n----------\nexpr\n    The expression or column name to use for sorting\nnulls_first\n    Bool to indicate whether to put NULL values first or not.\n\nSee Also\n--------\n[`Value.desc()`](./expression-generic.qmd#ibis.expr.types.generic.Value.desc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(ibis.desc(\"year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nir.ValueExpr\n    An expression", "type": "function"}
{"source": "ibis/expr/api.py::asc", "docstring": "Create a ascending sort key from `asc` or column name.\n\nParameters\n----------\nexpr\n    The expression or column name to use for sorting\nnulls_first\n    Bool to indicate whether to put NULL values first or not.\n\nSee Also\n--------\n[`Value.asc()`](./expression-generic.qmd#ibis.expr.types.generic.Value.asc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(ibis.asc(\"year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nir.ValueExpr\n    An expression", "type": "function"}
{"source": "ibis/expr/api.py::and_", "docstring": "Combine multiple predicates using `&`.\n\nParameters\n----------\npredicates\n    Boolean value expressions\n\nReturns\n-------\nBooleanValue\n    A new predicate that evaluates to True if all composing predicates are\n    True. If no predicates were provided, returns True.", "type": "function"}
{"source": "ibis/expr/api.py::or_", "docstring": "Combine multiple predicates using `|`.\n\nParameters\n----------\npredicates\n    Boolean value expressions\n\nReturns\n-------\nBooleanValue\n    A new predicate that evaluates to True if any composing predicates are\n    True. If no predicates were provided, returns False.", "type": "function"}
{"source": "ibis/expr/api.py::random", "docstring": "Return a random floating point number in the range [0.0, 1.0).\n\nSimilar to [](`random.random`) in the Python standard library.\n\n::: {.callout-note}\n## Repeated use of `random`\n\n`ibis.random()` will generate a column of distinct random numbers even if\nthe same instance of `ibis.random()` is reused.\n\nWhen Ibis compiles an expression to SQL, each place where `random` is used\nwill render as a separate call to the given backend's random number\ngenerator.\n\n```python\n>>> from ibis.interactive import *\n>>> t = ibis.memtable({\"a\": range(5)})\n>>> r_a = ibis.random()\n>>> t.mutate(random_1=r_a, random_2=r_a)  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 random_1 \u2503 random_2 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502 0.191130 \u2502 0.098715 \u2502\n\u2502     1 \u2502 0.255262 \u2502 0.828454 \u2502\n\u2502     2 \u2502 0.011804 \u2502 0.392275 \u2502\n\u2502     3 \u2502 0.309941 \u2502 0.347300 \u2502\n\u2502     4 \u2502 0.482783 \u2502 0.095562 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n:::\n\nReturns\n-------\nFloatingScalar\n    Random float value expression", "type": "function"}
{"source": "ibis/expr/api.py::uuid", "docstring": "Return or generate a UUID value.\n\nParameters\n----------\nvalue\n    A `uuid.UUID` object or a UUID str such as\n    'b41c7dfd-1513-4358-917e-9ea322b0d3c5'.\n    If `None`, a random UUIDv4 is generated, similar to\n    [`uuid.uuid4()`](https://docs.python.org/3/library/uuid.html#uuid.uuid4)\n    from the Python standard library.\n\nExamples\n--------\n>>> from ibis.interactive import *\n>>> ibis.uuid()  # doctest: +SKIP\nUUID('e57e927b-aed2-483b-9140-dc32a26cad95')\n>>> ibis.uuid(\"b41c7dfd-1513-4358-917e-9ea322b0d3c5\")  # doctest: +SKIP\nUUID('b41c7dfd-1513-4358-917e-9ea322b0d3c5')\n\nReturns\n-------\nUUIDScalar\n    Random UUID value expression", "type": "function"}
{"source": "ibis/expr/api.py::timestamp", "docstring": "Construct a timestamp scalar or column.\n\nParameters\n----------\nvalue_or_year\n    Either a string value or `datetime.datetime` to coerce to a timestamp,\n    or an integral value representing the timestamp year component.\nmonth\n    The timestamp month component; required if `value_or_year` is a year.\nday\n    The timestamp day component; required if `value_or_year` is a year.\nhour\n    The timestamp hour component; required if `value_or_year` is a year.\nminute\n    The timestamp minute component; required if `value_or_year` is a year.\nsecond\n    The timestamp second component; required if `value_or_year` is a year.\ntimezone\n    The timezone name, or none for a timezone-naive timestamp.\n\nReturns\n-------\nTimestampValue\n    A timestamp expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a timestamp scalar from a string\n\n>>> ibis.timestamp(\"2023-01-02T03:04:05\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 03:04:05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a timestamp scalar from components\n\n>>> ibis.timestamp(2023, 1, 2, 3, 4, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 03:04:05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a timestamp column from components\n\n>>> t = ibis.memtable({\"y\": [2001, 2002], \"m\": [1, 4], \"d\": [2, 5], \"h\": [3, 6]})\n>>> ibis.timestamp(t.y, t.m, t.d, t.h, 0, 0).name(\"timestamp\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2001-01-02 03:00:00 \u2502\n\u2502 2002-04-05 06:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::date", "docstring": "Construct a date scalar or column.\n\nParameters\n----------\nvalue_or_year\n    Either a string value or `datetime.date` to coerce to a date, or\n    an integral value representing the date year component.\nmonth\n    The date month component; required if `value_or_year` is a year.\nday\n    The date day component; required if `value_or_year` is a year.\n\nReturns\n-------\nDateValue\n    A date expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a date scalar from a string\n\n>>> ibis.date(\"2023-01-02\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a date scalar from year, month, and day\n\n>>> ibis.date(2023, 1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a date column from year, month, and day\n\n>>> t = ibis.memtable(dict(year=[2001, 2002], month=[1, 3], day=[2, 4]))\n>>> ibis.date(t.year, t.month, t.day).name(\"my_date\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 my_date    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2001-01-02 \u2502\n\u2502 2002-03-04 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::time", "docstring": "Return a time literal if `value` is coercible to a time.\n\nParameters\n----------\nvalue_or_hour\n    Either a string value or `datetime.time` to coerce to a time, or\n    an integral value representing the time hour component.\nminute\n    The time minute component; required if `value_or_hour` is an hour.\nsecond\n    The time second component; required if `value_or_hour` is an hour.\n\nReturns\n-------\nTimeValue\n    A time expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a time scalar from a string\n\n>>> ibis.time(\"01:02:03\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 01:02:03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a time scalar from hour, minute, and second\n\n>>> ibis.time(1, 2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 01:02:03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a time column from hour, minute, and second\n\n>>> t = ibis.memtable({\"h\": [1, 4], \"m\": [2, 5], \"s\": [3, 6]})\n>>> ibis.time(t.h, t.m, t.s).name(\"time\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 time     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 time     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 01:02:03 \u2502\n\u2502 04:05:06 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::interval", "docstring": "Return an interval literal expression.\n\nParameters\n----------\nvalue\n    Interval value.\nunit\n    Unit of `value`\nyears\n    Number of years\nquarters\n    Number of quarters\nmonths\n    Number of months\nweeks\n    Number of weeks\ndays\n    Number of days\nhours\n    Number of hours\nminutes\n    Number of minutes\nseconds\n    Number of seconds\nmilliseconds\n    Number of milliseconds\nmicroseconds\n    Number of microseconds\nnanoseconds\n    Number of nanoseconds\n\nReturns\n-------\nIntervalScalar\n    An interval expression\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"timestamp_col\": [\n...             datetime(2020, 10, 5, 8, 0, 0),\n...             datetime(2020, 11, 10, 10, 2, 15),\n...             datetime(2020, 12, 15, 12, 4, 30),\n...         ]\n...     },\n... )\n\nAdd and subtract ten days from a timestamp column.\n\n>>> ten_days = ibis.interval(days=10)\n>>> ten_days\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MonthDayNano(months=0, days=10, nanoseconds=0) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(\n...     plus_ten_days=t.timestamp_col + ten_days,\n...     minus_ten_days=t.timestamp_col - ten_days,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp_col       \u2503 plus_ten_days       \u2503 minus_ten_days      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10-05 08:00:00 \u2502 2020-10-15 08:00:00 \u2502 2020-09-25 08:00:00 \u2502\n\u2502 2020-11-10 10:02:15 \u2502 2020-11-20 10:02:15 \u2502 2020-10-31 10:02:15 \u2502\n\u2502 2020-12-15 12:04:30 \u2502 2020-12-25 12:04:30 \u2502 2020-12-05 12:04:30 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIntervals provide more granularity with date arithmetic.\n\n>>> t.mutate(\n...     added_interval=t.timestamp_col\n...     + ibis.interval(weeks=1, days=2, hours=3, minutes=4, seconds=5)\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp_col       \u2503 added_interval      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10-05 08:00:00 \u2502 2020-10-14 11:04:05 \u2502\n\u2502 2020-11-10 10:02:15 \u2502 2020-11-19 13:06:20 \u2502\n\u2502 2020-12-15 12:04:30 \u2502 2020-12-24 15:08:35 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::cases", "docstring": "Create a multi-branch if-else expression.\n\nEquivalent to a SQL `CASE` statement.\n\n::: {.callout-note title=\"Added in version 10.0.0\"}\n:::\n\nParameters\n----------\nbranch\n    First (`condition`, `result`) pair. Required.\nbranches\n    Additional (`condition`, `result`) pairs. We look through the test\n    values in order and return the result corresponding to the first\n    test value that matches `self`. If none match, we return `else_`.\nelse_\n    Value to return if none of the case conditions evaluate to `True`.\n    Defaults to `NULL`.\n\nReturns\n-------\nValue\n    A value expression\n\nSee Also\n--------\n[`Value.cases()`](./expression-generic.qmd#ibis.expr.types.generic.Value.cases)\n[`Value.substitute()`](./expression-generic.qmd#ibis.expr.types.generic.Value.substitute)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> v = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2, 4]}).values\n>>> ibis.cases((v == 1, \"a\"), (v > 2, \"b\"), else_=\"unk\").name(\"cases\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cases  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502\n\u2502 unk    \u2502\n\u2502 a      \u2502\n\u2502 unk    \u2502\n\u2502 b      \u2502\n\u2502 unk    \u2502\n\u2502 b      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.cases(\n...     (v % 2 == 0, \"divisible by 2\"),\n...     (v % 3 == 0, \"divisible by 3\"),\n...     (v % 4 == 0, \"shadowed by the 2 case\"),\n... ).name(\"cases\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cases          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL           \u2502\n\u2502 divisible by 2 \u2502\n\u2502 NULL           \u2502\n\u2502 divisible by 2 \u2502\n\u2502 divisible by 3 \u2502\n\u2502 divisible by 2 \u2502\n\u2502 divisible by 2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::now", "docstring": "Return an expression that will compute the current timestamp.\n\nReturns\n-------\nTimestampScalar\n    An expression representing the current timestamp.", "type": "function"}
{"source": "ibis/expr/api.py::today", "docstring": "Return an expression that will compute the current date.\n\nReturns\n-------\nDateScalar\n    An expression representing the current date.", "type": "function"}
{"source": "ibis/expr/api.py::rank", "docstring": "Compute position of first element within each equal-value group in sorted order.\n\nEquivalent to SQL's `RANK()` window function.\n\nReturns\n-------\nInt64Column\n    The min rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=ibis.rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      3 \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::dense_rank", "docstring": "Position of first element within each group of equal values.\n\nValues are returned in sorted order and duplicate values are ignored.\n\nEquivalent to SQL's `DENSE_RANK()`.\n\nReturns\n-------\nIntegerColumn\n    The rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=ibis.dense_rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      3 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::percent_rank", "docstring": "Return the relative rank of the values in the column.\n\nReturns\n-------\nFloatingColumn\n    The percent rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(pct_rank=ibis.percent_rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 pct_rank \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502      0.0 \u2502\n\u2502      1 \u2502      0.0 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      3 \u2502      1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::cume_dist", "docstring": "Return the cumulative distribution over a window.\n\nReturns\n-------\nFloatingColumn\n    The cumulative distribution\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(dist=ibis.cume_dist().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 dist     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502 0.333333 \u2502\n\u2502      1 \u2502 0.333333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      3 \u2502 1.000000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::ntile", "docstring": "Return the integer number of a partitioning of the column values.\n\nParameters\n----------\nbuckets\n    Number of buckets to partition into\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(ntile=ibis.ntile(2).over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 ntile \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      3 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::row_number", "docstring": "Return an analytic function expression for the current row number.\n\n::: {.callout-note}\n`row_number` is normalized across backends to start at 0\n:::\n\nReturns\n-------\nIntegerColumn\n    A column expression enumerating rows\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rownum=ibis.row_number())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rownum \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502      0 \u2502\n\u2502      2 \u2502      1 \u2502\n\u2502      1 \u2502      2 \u2502\n\u2502      2 \u2502      3 \u2502\n\u2502      3 \u2502      4 \u2502\n\u2502      2 \u2502      5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::read_csv", "docstring": "Lazily load a CSV or set of CSVs.\n\nThis function delegates to the `read_csv` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.  Supports CSV and TSV files.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. For the DuckDB\n    backend used by default, please refer to:\n\n    * CSV/TSV: https://duckdb.org/docs/data/csv/overview.html#parameters.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lines = '''a,b\n... 1,d\n... 2,\n... ,f\n... '''\n>>> with open(\"/tmp/lines.csv\", mode=\"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = ibis.read_csv(\"/tmp/lines.csv\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 d      \u2502\n\u2502     2 \u2502 NULL   \u2502\n\u2502  NULL \u2502 f      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::read_json", "docstring": "Lazily load newline-delimited JSON data.\n\nThis function delegates to the `read_json` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. See\n    https://duckdb.org/docs/extensions/json.html for details.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lines = '''\n... {\"a\": 1, \"b\": \"d\"}\n... {\"a\": 2, \"b\": null}\n... {\"a\": null, \"b\": \"f\"}\n... '''\n>>> with open(\"/tmp/lines.json\", mode=\"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = ibis.read_json(\"/tmp/lines.json\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 d      \u2502\n\u2502     2 \u2502 NULL   \u2502\n\u2502  NULL \u2502 f      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::read_parquet", "docstring": "Lazily load a parquet file or set of parquet files.\n\nThis function delegates to the `read_parquet` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. For the DuckDB\n    backend used by default, please refer to:\n\n    * Parquet: https://duckdb.org/docs/data/parquet\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> import pandas as pd\n>>> ibis.options.interactive = True\n>>> df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": list(\"ghi\")})\n>>> df\n   a  b\n0  1  g\n1  2  h\n2  3  i\n>>> df.to_parquet(\"/tmp/data.parquet\")\n>>> t = ibis.read_parquet(\"/tmp/data.parquet\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 g      \u2502\n\u2502     2 \u2502 h      \u2502\n\u2502     3 \u2502 i      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::read_delta", "docstring": "Lazily load a Delta Lake table.\n\nParameters\n----------\npath\n    A filesystem path or URL.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> import pandas as pd\n>>> ibis.options.interactive = True\n>>> df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": list(\"ghi\")})\n>>> df\n   a  b\n0  1  g\n1  2  h\n2  3  i\n>>> import deltalake as dl\n>>> dl.write_deltalake(\"/tmp/data.delta\", df, mode=\"overwrite\")\n>>> t = ibis.read_delta(\"/tmp/data.delta\")\n>>> t.order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 g      \u2502\n\u2502     2 \u2502 h      \u2502\n\u2502     3 \u2502 i      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::set_backend", "docstring": "Set the default Ibis backend.\n\nParameters\n----------\nbackend\n    May be a backend name or URL, or an existing backend instance.\n\nExamples\n--------\nYou can pass the backend as a name:\n\n>>> import ibis\n>>> ibis.set_backend(\"polars\")\n\nOr as a URI\n\n>>> ibis.set_backend(\n...     \"postgres://user:password@hostname:5432\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nOr as an existing backend instance\n\n>>> ibis.set_backend(ibis.duckdb.connect())", "type": "function"}
{"source": "ibis/expr/api.py::get_backend", "docstring": "Get the current Ibis backend to use for a given expression.\n\nParameters\n----------\nexpr\n    An expression to get the backend from. If not passed, the default\n    backend is returned.\n\nReturns\n-------\nBaseBackend\n    The Ibis backend.\n\nExamples\n--------\n>>> import ibis\n\nGet the default backend.\n\n>>> ibis.get_backend()  # doctest: +ELLIPSIS\n<ibis.backends.duckdb.Backend object at 0x...>\n\nGet the backend for a specific expression.\n\n>>> polars_con = ibis.polars.connect()\n>>> t = polars_con.create_table(\"t\", ibis.memtable({\"a\": [1, 2, 3]}))\n>>> ibis.get_backend(t)  # doctest: +ELLIPSIS\n<ibis.backends.polars.Backend object at 0x...>\n\nSee Also\n--------\n[`get_backend()`](./expression-tables.qmd#ibis.expr.types.relations.Table.get_backend)", "type": "function"}
{"source": "ibis/expr/api.py::window", "docstring": "Create a window clause for use with window functions.\n\nThe `ROWS` window clause includes peer rows based on differences in row\n**number** whereas `RANGE` includes rows based on the differences in row\n**value** of a single `order_by` expression.\n\nAll window frame bounds are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\nrows\n    Whether to use the `ROWS` window clause\nrange\n    Whether to use the `RANGE` window clause\nbetween\n    Automatically infer the window kind based on the boundaries\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::rows_window", "docstring": "Create a rows-based window clause for use with window functions.\n\nThis ROWS window clause aggregates rows based upon differences in row\nnumber.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::range_window", "docstring": "Create a range-based window clause for use with window functions.\n\nThis RANGE window clause aggregates rows based upon differences in the\nvalue of the order-by expression.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::cumulative_window", "docstring": "Create a cumulative window for use with window functions.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::trailing_window", "docstring": "Create a trailing window for use with window functions.\n\nParameters\n----------\npreceding\n    The number of preceding rows\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::trailing_rows_window", "docstring": "Create a trailing window for use with aggregate window functions.\n\nParameters\n----------\npreceding\n    The number of preceding rows\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::trailing_range_window", "docstring": "Create a trailing range window for use with window functions.\n\nParameters\n----------\npreceding\n    A value expression\norder_by\n    Ordering key\ngroup_by\n    Grouping key\n\nReturns\n-------\nWindow\n    A window frame", "type": "function"}
{"source": "ibis/expr/api.py::union", "docstring": "Compute the multiset (or set) union of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use multiset union (False) or set union (True). See examples.\n\nReturns\n-------\nTable\n    A new table containing the union of all input tables.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [1, 2]})\n>>> t1\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t2 = ibis.memtable({\"a\": [2, 3]})\n>>> t2\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.union(t1, t2)  # union all by default\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.union(t1, t2, distinct=True).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can union more than two tables at once.\n\n>>> ibis.union(t1, t1, t1).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::intersect", "docstring": "Compute the set (or multiset) intersection of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set intersect (True) or multiset intersect (False). See examples.\n\nReturns\n-------\nTable\n    A new table containing the intersection of all input tables.\n\nSee Also\n--------\n[`Table.intersect`](./expression-tables.qmd#ibis.expr.types.relations.Table.intersect)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> two_a = ibis.memtable({\"x\": [\"a\", \"a\", \"b\"]})\n>>> three_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"b\"]})\n>>> four_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"a\", \"c\"]})\n\nWith `distinct=True`, the intersection will return one row for each row that appears in all input tables.\nThis is equivalent to a set intersection.\nSo even though the source tables have multiple `\"a\"` values, the result will only have one:\n\n>>> ibis.intersect(two_a, three_a).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the intersection will return all rows that appear in all input tables.\nThis is equivalent to a multiset intersection.\nSince the smallest number of appearances of `\"a\"` is 2, the result will have two `\"a\"` values:\n\n>>> ibis.intersect(two_a, three_a, distinct=False).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMore than two table expressions can be intersected at once.\n- Since `\"a\"` appears at minimum one time, it appears once in the result.\n- Since `\"b\"` doesn't appear in `two_a` or `three_a`, it is not included.\n- Since `\"c\"` does not appear in `one_a`, it is not included.\n\n>>> ibis.intersect(two_a, three_a, four_a)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.intersect(two_a, three_a, four_a, distinct=False)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::difference", "docstring": "Compute the set (or multiset) difference of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set difference (True) or multiset difference (False). See examples.\n\nSee Also\n--------\n[`ibis.difference`](./expression-tables.qmd#ibis.difference)\n\nReturns\n-------\nTable\n    The rows present in `self` that are not present in `tables`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [7, 8, 8, 9, 9, 9]})\n>>> t2 = ibis.memtable({\"a\": [8, 9]})\n\nWith `distinct=True`, if a row ever appears in any of `*rest`,\nit will not appear in the result.\nSo here, all appearances of 8 and 9 are removed:\n\n>>> t1.difference(t2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the algorithm is a [multiset](https://en.wikipedia.org/wiki/Multiset) difference.\nThis means, that since 8 and 9 each appear once in `t2`,\nthe result will be the input with a single instance of each removed:\n\n>>> t1.difference(t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     8 \u2502\n\u2502     9 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith multiple tables in `*rest`, we apply the operation consecutively.\nHere, we remove two eights and two nines:\n\n>>> t1.difference(t2, t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::watermark", "docstring": "Return a watermark object.\n\nParameters\n----------\ntime_col\n    The timestamp column that will be used to generate watermarks in event time processing.\nallowed_delay\n    Length of time that events are allowed to be late.\n\nReturns\n-------\nWatermark\n    A watermark object.", "type": "function"}
{"source": "ibis/expr/api.py::range", "docstring": "Generate a range of values.\n\nInteger ranges are supported, as well as timestamp ranges.\n\n::: {.callout-note}\n`start` is inclusive and `stop` is exclusive, just like Python's builtin\n[](`range`).\n\nWhen `step` equals 0, however, this function will return an empty array.\n\nPython's `range` will raise an exception when `step` is zero.\n:::\n\nParameters\n----------\nstart\n    Lower bound of the range, inclusive.\nstop\n    Upper bound of the range, exclusive.\nstep\n    Step value. Optional, defaults to 1.\n\nReturns\n-------\nArrayValue\n    An array of values\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nRange using only a stop argument\n\n>>> ibis.range(5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [0, 1, ... +3] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSimple range using start and stop\n\n>>> ibis.range(1, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [1, 2, ... +2] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nGenerate an empty range\n\n>>> ibis.range(0)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\nNegative step values are supported\n\n>>> ibis.range(10, 4, -2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [10, 8, ... +1] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`ibis.range` behaves the same as Python's range ...\n\n>>> ibis.range(0, 7, -1)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\n... except when the step is zero, in which case `ibis.range` returns an\nempty array\n\n>>> ibis.range(0, 5, 0)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\nBecause the resulting expression is array, you can unnest the values\n\n>>> ibis.range(5).unnest().name(\"numbers\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 numbers \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int8    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       0 \u2502\n\u2502       1 \u2502\n\u2502       2 \u2502\n\u2502       3 \u2502\n\u2502       4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTimestamp ranges are also supported\n\n>>> expr = ibis.range(\"2002-01-01\", \"2002-02-01\", ibis.interval(days=2)).name(\"ts\")\n>>> expr\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [                                        \u2502\n\u2502     datetime.datetime(2002, 1, 1, 0, 0), \u2502\n\u2502     datetime.datetime(2002, 1, 3, 0, 0), \u2502\n\u2502     ... +14                              \u2502\n\u2502 ]                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> expr.unnest()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ts                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2002-01-01 00:00:00 \u2502\n\u2502 2002-01-03 00:00:00 \u2502\n\u2502 2002-01-05 00:00:00 \u2502\n\u2502 2002-01-07 00:00:00 \u2502\n\u2502 2002-01-09 00:00:00 \u2502\n\u2502 2002-01-11 00:00:00 \u2502\n\u2502 2002-01-13 00:00:00 \u2502\n\u2502 2002-01-15 00:00:00 \u2502\n\u2502 2002-01-17 00:00:00 \u2502\n\u2502 2002-01-19 00:00:00 \u2502\n\u2502 \u2026                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::ifelse", "docstring": "Construct a ternary conditional expression.\n\nParameters\n----------\ncondition\n    A boolean expression\ntrue_expr\n    Expression to return if `condition` evaluates to `True`\nfalse_expr\n    Expression to return if `condition` evaluates to `False` or `NULL`\n\nReturns\n-------\nValue : ir.Value\n    The value of `true_expr` if `condition` is `True` else `false_expr`\n\nSee Also\n--------\n[`BooleanValue.ifelse()`](./expression-numeric.qmd#ibis.expr.types.logical.BooleanValue.ifelse)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"condition\": [True, False, True, None]})\n>>> ibis.ifelse(t.condition, \"yes\", \"no\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 IfElse(condition, 'yes', 'no') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::coalesce", "docstring": "Return the first non-null value from `args`.\n\nParameters\n----------\narg\n    First argument from which to choose the first non-null value\nargs\n    Arguments from which to choose the first non-null value\n\nReturns\n-------\nValue\n    Coalesced expression\n\nSee Also\n--------\n[`Value.coalesce()`](#ibis.expr.types.generic.Value.coalesce)\n[`Value.fill_null()`](#ibis.expr.types.generic.Value.fill_null)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.coalesce(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::greatest", "docstring": "Compute the largest value among the supplied arguments.\n\nParameters\n----------\narg\n    First argument\nargs\n    Remaining arguments\n\nReturns\n-------\nValue\n    Maximum of the passed arguments\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.greatest(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 5 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/api.py::least", "docstring": "Compute the smallest value among the supplied arguments.\n\nParameters\n----------\narg\n    First argument\nargs\n    Remaining arguments\n\nReturns\n-------\nValue\n    Minimum of the passed arguments\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.least(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/decompile.py::_to_snake_case", "docstring": "Convert a camelCase string to snake_case.", "type": "function"}
{"source": "ibis/expr/decompile.py::translate", "docstring": "Translate an ibis operation into a Python expression.", "type": "function"}
{"source": "ibis/expr/decompile.py::decompile", "docstring": "Decompile an ibis expression into Python source code.\n\nParameters\n----------\nexpr\n    node or expression to decompile\nrender_import\n    Whether to add `import ibis` to the result.\nassign_result_to\n    Variable name to store the result at, pass None to avoid assignment.\nformat\n    Whether to format the generated code using black code formatter.\n\nReturns\n-------\nstr\n    Equivalent Python source code for `node`.", "type": "function"}
{"source": "ibis/expr/sql.py::Catalog", "docstring": "A catalog of tables and their schemas.", "type": "class"}
{"source": "ibis/expr/sql.py::apply_limit", "docstring": "Applies a LIMIT, if applicable.", "type": "function"}
{"source": "ibis/expr/sql.py::apply_projections", "docstring": "Applies a SELECT projection, if applicable.", "type": "function"}
{"source": "ibis/expr/sql.py::parse_sql", "docstring": "Parse a SQL string into an Ibis expression.\n\nParameters\n----------\nsqlstring : str\n    SQL string to parse\ncatalog : dict\n    A dictionary mapping table names to either schemas or ibis table expressions.\n    If a schema is passed, a table expression will be created using the schema.\ndialect : str, optional\n    The SQL dialect to use with sqlglot to parse the query string.\n\nReturns\n-------\nexpr : ir.Expr", "type": "function"}
{"source": "ibis/expr/sql.py::SQLString", "docstring": "Object to hold a formatted SQL string.\n\nSyntax highlights in Jupyter notebooks.", "type": "class"}
{"source": "ibis/expr/sql.py::to_sql", "docstring": "Return the formatted SQL string for an expression.\n\nParameters\n----------\nexpr\n    Ibis expression.\ndialect\n    SQL dialect to use for compilation.\npretty\n    Whether to use pretty formatting.\nkwargs\n    Scalar parameters\n\nReturns\n-------\nstr\n    Formatted SQL string\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table({\"a\": \"int\", \"b\": \"int\"}, name=\"t\")\n>>> expr = t.mutate(c=t.a + t.b)\n>>> ibis.to_sql(expr)  # doctest: +SKIP\nSELECT\n  \"t0\".\"a\",\n  \"t0\".\"b\",\n  \"t0\".\"a\" + \"t0\".\"b\" AS \"c\"\nFROM \"t\" AS \"t0\"\n\nYou can also specify the SQL dialect to use for compilation:\n>>> ibis.to_sql(expr, dialect=\"mysql\")  # doctest: +SKIP\nSELECT\n  `t0`.`a`,\n  `t0`.`b`,\n  `t0`.`a` + `t0`.`b` AS `c`\nFROM `t` AS `t0`\n\nSee Also\n--------\n[`Table.compile()`](./expression-tables.qmd#ibis.expr.types.relations.Table.compile)", "type": "function"}
{"source": "ibis/expr/schema.py::Schema", "docstring": "An ordered mapping of str -> [datatype](./datatypes.qmd), used to hold a [Table](./expression-tables.qmd#ibis.expr.tables.Table)'s schema.", "type": "class"}
{"source": "ibis/expr/schema.py::schema", "docstring": "Construct ibis schema from schema-like python objects.", "type": "function"}
{"source": "ibis/expr/schema.py::infer", "docstring": "Infer the corresponding ibis schema for a python object.", "type": "function"}
{"source": "ibis/expr/schema.py::equals", "docstring": "Return whether `other` is equal to `self`.\n\nThe order of fields in the schema is taken into account when computing equality.\n\nParameters\n----------\nother\n    Schema to compare `self` to.\n\nExamples\n--------\n>>> import ibis\n>>> xy = ibis.schema({\"x\": int, \"y\": str})\n>>> xy2 = ibis.schema({\"x\": int, \"y\": str})\n>>> yx = ibis.schema({\"y\": str, \"x\": int})\n>>> xy_float = ibis.schema({\"x\": float, \"y\": str})\n>>> assert xy.equals(xy2)\n>>> assert not xy.equals(yx)\n>>> assert not xy.equals(xy_float)", "type": "function"}
{"source": "ibis/expr/schema.py::from_tuples", "docstring": "Construct a `Schema` from an iterable of pairs.\n\nParameters\n----------\nvalues\n    An iterable of pairs of name and type.\n\nReturns\n-------\nSchema\n    A new schema\n\nExamples\n--------\n>>> import ibis\n>>> ibis.Schema.from_tuples([(\"a\", \"int\"), (\"b\", \"string\")])\nibis.Schema {\n  a  int64\n  b  string\n}", "type": "function"}
{"source": "ibis/expr/schema.py::from_numpy", "docstring": "Return the equivalent ibis schema.", "type": "function"}
{"source": "ibis/expr/schema.py::from_pandas", "docstring": "Return the equivalent ibis schema.", "type": "function"}
{"source": "ibis/expr/schema.py::from_pyarrow", "docstring": "Return the equivalent ibis schema.", "type": "function"}
{"source": "ibis/expr/schema.py::from_polars", "docstring": "Return the equivalent ibis schema.", "type": "function"}
{"source": "ibis/expr/schema.py::from_sqlglot", "docstring": "Construct an Ibis Schema from a SQLGlot Schema.\n\nParameters\n----------\nschema\n    A SQLGlot Schema containing column definitions.\ndialect\n    Optional dialect to use for type conversion.\n\nReturns\n-------\nSchema\n    An Ibis Schema.\n\nExamples\n--------\n>>> import ibis\n>>> import sqlglot as sg\n>>> import sqlglot.expressions as sge\n>>> columns = [\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"a\", quoted=True),\n...         kind=sge.DataType(this=sge.DataType.Type.BIGINT),\n...     ),\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"b\", quoted=True),\n...         kind=sge.DataType(this=sge.DataType.Type.VARCHAR),\n...         constraints=[sge.ColumnConstraint(kind=sge.NotNullColumnConstraint())],\n...     ),\n... ]\n>>> schema_expr = sge.Schema(expressions=columns)\n>>> sch = ibis.Schema.from_sqlglot(schema_expr)\n>>> sch\nibis.Schema {\n  a  int64\n  b  !string\n}\n\nDifferent source dialects are supported using the `dialect` keyword argument.\n\n>>> columns = [\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"a\", quoted=True),\n...         kind=sge.DataType(\n...             this=sge.DataType.Type.ARRAY,\n...             expressions=[sge.DataType(this=sge.DataType.Type.BIGINT, nested=False)],\n...             nested=True,\n...         ),\n...     )\n... ]\n>>> schema_expr = sge.Schema(expressions=columns)\n>>> snowflake_schema = ibis.Schema.from_sqlglot(schema_expr, dialect=\"snowflake\")\n>>> snowflake_schema\nibis.Schema {\n  a  array<json>\n}\n>>> bigquery_schema = ibis.Schema.from_sqlglot(schema_expr, dialect=\"bigquery\")\n>>> bigquery_schema\nibis.Schema {\n  a  array<int64>\n}", "type": "function"}
{"source": "ibis/expr/schema.py::to_numpy", "docstring": "Return the equivalent numpy dtypes.", "type": "function"}
{"source": "ibis/expr/schema.py::to_pandas", "docstring": "Return the equivalent pandas datatypes.", "type": "function"}
{"source": "ibis/expr/schema.py::to_pyarrow", "docstring": "Return the equivalent pyarrow schema.", "type": "function"}
{"source": "ibis/expr/schema.py::to_polars", "docstring": "Return the equivalent polars schema.", "type": "function"}
{"source": "ibis/expr/schema.py::name_at_position", "docstring": "Return the name of a schema column at position `i`.\n\nParameters\n----------\ni\n    The position of the column\n\nReturns\n-------\nstr\n    The name of the column in the schema at position `i`.\n\nExamples\n--------\n>>> import ibis\n>>> sch = ibis.Schema({\"a\": \"int\", \"b\": \"string\"})\n>>> sch.name_at_position(0)\n'a'\n>>> sch.name_at_position(1)\n'b'", "type": "function"}
{"source": "ibis/expr/schema.py::to_sqlglot_column_defs", "docstring": "Convert the schema to a list of SQL column definitions.\n\nParameters\n----------\ndialect\n    The SQL dialect to use.\n\nReturns\n-------\nlist[sqlglot.expressions.ColumnDef]\n    A list of SQL column definitions.\n\nExamples\n--------\n>>> import ibis\n>>> sch = ibis.schema({\"a\": \"int\", \"b\": \"!string\"})\n>>> sch\nibis.Schema {\n  a  int64\n  b  !string\n}\n>>> columns = sch.to_sqlglot_column_defs(dialect=\"duckdb\")\n>>> columns\n[ColumnDef(\n  this=Identifier(this='a', quoted=True),\n  kind=DataType(this=Type.BIGINT)), ColumnDef(\n  this=Identifier(this='b', quoted=True),\n  kind=DataType(this=Type.VARCHAR),\n  constraints=[\n    ColumnConstraint(\n      kind=NotNullColumnConstraint())])]\n\nOne use case for this method is to embed its output into a SQLGlot\n`CREATE TABLE` expression.\n\n>>> import sqlglot as sg\n>>> import sqlglot.expressions as sge\n>>> table = sg.table(\"t\", quoted=True)\n>>> ct = sge.Create(\n...     kind=\"TABLE\",\n...     this=sge.Schema(\n...         this=table,\n...         expressions=columns,\n...     ),\n... )\n>>> ct.sql(dialect=\"duckdb\")\n'CREATE TABLE \"t\" (\"a\" BIGINT, \"b\" TEXT NOT NULL)'", "type": "function"}
{"source": "ibis/expr/schema.py::to_sqlglot", "docstring": "DEPRECATED: use `to_sqlglot_column_defs()` instead.", "type": "function"}
{"source": "ibis/common/temporal.py::normalize_timedelta", "docstring": "Normalize a timedelta value to the given unit.\n\nParameters\n----------\nvalue\n    The value to normalize, either a timedelta or a number.\nunit\n    The unit to normalize to.\n\nReturns\n-------\nThe normalized timedelta value.\n\nExamples\n--------\n>>> from datetime import timedelta\n>>> normalize_timedelta(1, IntervalUnit.SECOND)\n1\n>>> normalize_timedelta(1, IntervalUnit.DAY)\n1\n>>> normalize_timedelta(timedelta(days=14), IntervalUnit.WEEK)\n2\n>>> normalize_timedelta(timedelta(seconds=3), IntervalUnit.MILLISECOND)\n3000\n>>> normalize_timedelta(timedelta(seconds=3), IntervalUnit.MICROSECOND)\n3000000", "type": "function"}
{"source": "ibis/common/temporal.py::to_scale", "docstring": "Convert to number of digits after decimal (eg \"ms\" -> 3).", "type": "function"}
{"source": "ibis/common/patterns.py::NoMatch", "docstring": "Marker to indicate that a pattern didn't match.", "type": "class"}
{"source": "ibis/common/patterns.py::Pattern", "docstring": "Base class for all patterns.\n\nPatterns are used to match values against a given condition. They are extensively\nused by other core components of Ibis to validate and/or coerce user inputs.", "type": "class"}
{"source": "ibis/common/patterns.py::Is", "docstring": "Pattern that matches a value against a reference value.\n\nParameters\n----------\nvalue\n    The reference value to match against.", "type": "class"}
{"source": "ibis/common/patterns.py::Any", "docstring": "Pattern that accepts any value, basically a no-op.", "type": "class"}
{"source": "ibis/common/patterns.py::Nothing", "docstring": "Pattern that no values.", "type": "class"}
{"source": "ibis/common/patterns.py::Capture", "docstring": "Pattern that captures a value in the context.\n\nParameters\n----------\npattern\n    The pattern to match against.\nkey\n    The key to use in the context if the pattern matches.", "type": "class"}
{"source": "ibis/common/patterns.py::Replace", "docstring": "Pattern that replaces a value with the output of another pattern.\n\nParameters\n----------\nmatcher\n    The pattern to match against.\nreplacer\n    The deferred to use as a replacement.", "type": "class"}
{"source": "ibis/common/patterns.py::replace", "docstring": "More convenient syntax for replacing a value with the output of a function.", "type": "function"}
{"source": "ibis/common/patterns.py::Check", "docstring": "Pattern that checks a value against a predicate.\n\nParameters\n----------\npredicate\n    The predicate to use.", "type": "class"}
{"source": "ibis/common/patterns.py::Custom", "docstring": "User defined custom matcher function.\n\nParameters\n----------\nfunc\n    The function to apply.", "type": "class"}
{"source": "ibis/common/patterns.py::EqualTo", "docstring": "Pattern that checks a value equals to the given value.\n\nParameters\n----------\nvalue\n    The value to check against.", "type": "class"}
{"source": "ibis/common/patterns.py::DeferredEqualTo", "docstring": "Pattern that checks a value equals to the given value.\n\nParameters\n----------\nvalue\n    The value to check against.", "type": "class"}
{"source": "ibis/common/patterns.py::Option", "docstring": "Pattern that matches `None` or a value that passes the inner validator.\n\nParameters\n----------\npattern\n    The inner pattern to use.", "type": "class"}
{"source": "ibis/common/patterns.py::TypeOf", "docstring": "Pattern that matches a value that is of a given type.", "type": "class"}
{"source": "ibis/common/patterns.py::SubclassOf", "docstring": "Pattern that matches a value that is a subclass of a given type.\n\nParameters\n----------\ntype\n    The type to check against.", "type": "class"}
{"source": "ibis/common/patterns.py::InstanceOf", "docstring": "Pattern that matches a value that is an instance of a given type.\n\nParameters\n----------\ntypes\n    The type to check against.", "type": "class"}
{"source": "ibis/common/patterns.py::GenericInstanceOf", "docstring": "Pattern that matches a value that is an instance of a given generic type.\n\nParameters\n----------\ntyp\n    The type to check against (must be a generic type).\n\nExamples\n--------\n>>> class MyNumber(Generic[T_co]):\n...     value: T_co\n...\n...     def __init__(self, value: T_co):\n...         self.value = value\n...\n...     def __eq__(self, other):\n...         return type(self) is type(other) and self.value == other.value\n>>> p = GenericInstanceOf(MyNumber[int])\n>>> assert p.match(MyNumber(1), {}) == MyNumber(1)\n>>> assert p.match(MyNumber(1.0), {}) is NoMatch\n>>>\n>>> p = GenericInstanceOf(MyNumber[float])\n>>> assert p.match(MyNumber(1.0), {}) == MyNumber(1.0)\n>>> assert p.match(MyNumber(1), {}) is NoMatch", "type": "class"}
{"source": "ibis/common/patterns.py::LazyInstanceOf", "docstring": "A version of `InstanceOf` that accepts qualnames instead of imported classes.\n\nUseful for delaying imports.\n\nParameters\n----------\ntypes\n    The types to check against.", "type": "class"}
{"source": "ibis/common/patterns.py::CoercedTo", "docstring": "Force a value to have a particular Python type.\n\nIf a Coercible subclass is passed, the `__coerce__` method will be used to\ncoerce the value. Otherwise, the type will be called with the value as the\nonly argument.\n\nParameters\n----------\ntype\n    The type to coerce to.", "type": "class"}
{"source": "ibis/common/patterns.py::GenericCoercedTo", "docstring": "Force a value to have a particular generic Python type.\n\nParameters\n----------\ntyp\n    The type to coerce to. Must be a generic type with bound typevars.\n\nExamples\n--------\n>>> from typing import Generic, TypeVar\n>>>\n>>> T = TypeVar(\"T\", covariant=True)\n>>>\n>>> class MyNumber(Coercible, Generic[T]):\n...     __slots__ = (\"value\",)\n...\n...     def __init__(self, value):\n...         self.value = value\n...\n...     def __eq__(self, other):\n...         return type(self) is type(other) and self.value == other.value\n...\n...     @classmethod\n...     def __coerce__(cls, value, T=None):\n...         if issubclass(T, int):\n...             return cls(int(value))\n...         elif issubclass(T, float):\n...             return cls(float(value))\n...         else:\n...             raise CoercionError(f\"Cannot coerce to {T}\")\n>>> p = GenericCoercedTo(MyNumber[int])\n>>> assert p.match(3.14, {}) == MyNumber(3)\n>>> assert p.match(\"15\", {}) == MyNumber(15)\n>>>\n>>> p = GenericCoercedTo(MyNumber[float])\n>>> assert p.match(3.14, {}) == MyNumber(3.14)\n>>> assert p.match(\"15\", {}) == MyNumber(15.0)", "type": "class"}
{"source": "ibis/common/patterns.py::Not", "docstring": "Pattern that matches a value that does not match a given pattern.\n\nParameters\n----------\npattern\n    The pattern which the value should not match.", "type": "class"}
{"source": "ibis/common/patterns.py::AnyOf", "docstring": "Pattern that if any of the given patterns match.\n\nParameters\n----------\npatterns\n    The patterns to match against. The first pattern that matches will be\n    returned.", "type": "class"}
{"source": "ibis/common/patterns.py::AllOf", "docstring": "Pattern that matches if all of the given patterns match.\n\nParameters\n----------\npatterns\n    The patterns to match against. The value will be passed through each\n    pattern in order. The changes applied to the value propagate through the\n    patterns.", "type": "class"}
{"source": "ibis/common/patterns.py::Length", "docstring": "Pattern that matches if the length of a value is within a given range.\n\nParameters\n----------\nexactly\n    The exact length of the value. If specified, `at_least` and `at_most`\n    must be None.\nat_least\n    The minimum length of the value.\nat_most\n    The maximum length of the value.", "type": "class"}
{"source": "ibis/common/patterns.py::Between", "docstring": "Match a value between two bounds.\n\nParameters\n----------\nlower\n    The lower bound.\nupper\n    The upper bound.", "type": "class"}
{"source": "ibis/common/patterns.py::Contains", "docstring": "Pattern that matches if a value contains a given value.\n\nParameters\n----------\nneedle\n    The item that the passed value should contain.", "type": "class"}
{"source": "ibis/common/patterns.py::IsIn", "docstring": "Pattern that matches if a value is in a given set.\n\nParameters\n----------\nhaystack\n    The set of values that the passed value should be in.", "type": "class"}
{"source": "ibis/common/patterns.py::SequenceOf", "docstring": "Pattern that matches if all of the items in a sequence match a given pattern.\n\nSpecialization of the more flexible GenericSequenceOf pattern which uses two\nadditional patterns to possibly coerce the sequence type and to match on\nthe length of the sequence.\n\nParameters\n----------\nitem\n    The pattern to match against each item in the sequence.\ntype\n    The type to coerce the sequence to. Defaults to tuple.", "type": "class"}
{"source": "ibis/common/patterns.py::GenericSequenceOf", "docstring": "Pattern that matches if all of the items in a sequence match a given pattern.\n\nParameters\n----------\nitem\n    The pattern to match against each item in the sequence.\ntype\n    The type to coerce the sequence to. Defaults to list.\nexactly\n    The exact length of the sequence.\nat_least\n    The minimum length of the sequence.\nat_most\n    The maximum length of the sequence.", "type": "class"}
{"source": "ibis/common/patterns.py::GenericMappingOf", "docstring": "Pattern that matches if all of the keys and values match the given patterns.\n\nParameters\n----------\nkey\n    The pattern to match the keys against.\nvalue\n    The pattern to match the values against.\ntype\n    The type to coerce the mapping to. Defaults to dict.", "type": "class"}
{"source": "ibis/common/patterns.py::Object", "docstring": "Pattern that matches if the object has the given attributes and they match the given patterns.\n\nThe type must conform the structural pattern matching protocol, e.g. it must have a\n__match_args__ attribute that is a tuple of the names of the attributes to match.\n\nParameters\n----------\ntype\n    The type of the object.\n*args\n    The positional arguments to match against the attributes of the object.\n**kwargs\n    The keyword arguments to match against the attributes of the object.", "type": "class"}
{"source": "ibis/common/patterns.py::SomeChunksOf", "docstring": "Pattern that unpacks a value into its elements.\n\nDesigned to be used inside a `PatternList` pattern with the `*` syntax.", "type": "class"}
{"source": "ibis/common/patterns.py::PatternList", "docstring": "Pattern that matches if the respective items in a tuple match the given patterns.\n\nParameters\n----------\nfields\n    The patterns to match the respective items in the tuple.", "type": "class"}
{"source": "ibis/common/patterns.py::NoneOf", "docstring": "Match none of the passed patterns.", "type": "function"}
{"source": "ibis/common/patterns.py::ListOf", "docstring": "Match a list of items matching the given pattern.", "type": "function"}
{"source": "ibis/common/patterns.py::TupleOf", "docstring": "Match a variable-length tuple of items matching the given pattern.", "type": "function"}
{"source": "ibis/common/patterns.py::DictOf", "docstring": "Match a dictionary with keys and values matching the given patterns.", "type": "function"}
{"source": "ibis/common/patterns.py::FrozenDictOf", "docstring": "Match a frozendict with keys and values matching the given patterns.", "type": "function"}
{"source": "ibis/common/patterns.py::pattern", "docstring": "Create a pattern from various types.\n\nNot that if a Coercible type is passed as argument, the constructed pattern\nwon't attempt to coerce the value during matching. In order to allow type\ncoercions use `Pattern.from_typehint()` factory method.\n\nParameters\n----------\nobj\n    The object to create a pattern from. Can be a pattern, a type, a callable,\n    a mapping, an iterable or a value.\n\nExamples\n--------\n>>> assert pattern(Any()) == Any()\n>>> assert pattern(int) == InstanceOf(int)\n>>>\n>>> @pattern\n... def as_int(x, context):\n...     return int(x)\n>>>\n>>> assert as_int.match(1, {}) == 1\n\nReturns\n-------\nThe constructed pattern.", "type": "function"}
{"source": "ibis/common/patterns.py::match", "docstring": "Match a value against a pattern.\n\nParameters\n----------\npat\n    The pattern to match against.\nvalue\n    The value to match.\ncontext\n    Arbitrary mapping of values to be used while matching.\n\nReturns\n-------\nThe matched value if the pattern matches, otherwise :obj:`NoMatch`.\n\nExamples\n--------\n>>> assert match(Any(), 1) == 1\n>>> assert match(1, 1) == 1\n>>> assert match(1, 2) is NoMatch\n>>> assert match(1, 1, context={\"x\": 1}) == 1\n>>> assert match(1, 2, context={\"x\": 1}) is NoMatch\n>>> assert match([1, int], [1, 2]) == [1, 2]\n>>> assert match([1, int, \"a\" @ InstanceOf(str)], [1, 2, \"three\"]) == [\n...     1,\n...     2,\n...     \"three\",\n... ]", "type": "function"}
{"source": "ibis/common/patterns.py::from_typehint", "docstring": "Construct a validator from a python type annotation.\n\nParameters\n----------\nannot\n    The typehint annotation to construct the pattern from. This must be\n    an already evaluated type annotation.\nallow_coercion\n    Whether to use coercion if the typehint is a Coercible type.\n\nReturns\n-------\nA pattern that matches the given type annotation.", "type": "function"}
{"source": "ibis/common/patterns.py::match", "docstring": "Match a value against the pattern.\n\nParameters\n----------\nvalue\n    The value to match the pattern against.\ncontext\n    A dictionary providing arbitrary context for the pattern matching.\n\nReturns\n-------\nThe result of the pattern matching. If the pattern doesn't match\nthe value, then it must return the `NoMatch` sentinel value.", "type": "function"}
{"source": "ibis/common/patterns.py::__invert__", "docstring": "Syntax sugar for matching the inverse of the pattern.", "type": "function"}
{"source": "ibis/common/patterns.py::__or__", "docstring": "Syntax sugar for matching either of the patterns.\n\nParameters\n----------\nother\n    The other pattern to match against.\n\nReturns\n-------\nNew pattern that matches if either of the patterns match.", "type": "function"}
{"source": "ibis/common/patterns.py::__and__", "docstring": "Syntax sugar for matching both of the patterns.\n\nParameters\n----------\nother\n    The other pattern to match against.\n\nReturns\n-------\nNew pattern that matches if both of the patterns match.", "type": "function"}
{"source": "ibis/common/patterns.py::__rshift__", "docstring": "Syntax sugar for replacing a value.\n\nParameters\n----------\nother\n    The deferred to use for constructing the replacement value.\n\nReturns\n-------\nNew replace pattern.", "type": "function"}
{"source": "ibis/common/patterns.py::__rmatmul__", "docstring": "Syntax sugar for capturing a value.\n\nParameters\n----------\nname\n    The name of the capture.\n\nReturns\n-------\nNew capture pattern.", "type": "function"}
{"source": "ibis/common/dispatch.py::lazy_singledispatch", "docstring": "A `singledispatch` implementation that supports lazily registering implementations.", "type": "function"}
{"source": "ibis/common/dispatch.py::register", "docstring": "Register a new implementation for arguments of type `cls`.", "type": "function"}
{"source": "ibis/common/dispatch.py::dispatch", "docstring": "Return the implementation for the given `cls`.", "type": "function"}
{"source": "ibis/common/graph.py::_flatten_collections", "docstring": "Flatten collections of nodes into a single iterator.\n\nWe treat common collection types inherently traversable (e.g. list, tuple, dict)\nbut as undesired in a graph representation, so we traverse them implicitly.\n\nParameters\n----------\nnode\n    Flattaneble object.\n\nReturns\n-------\nA flat generator of the filtered nodes.\n\nExamples\n--------\n>>> from ibis.common.grounds import Concrete\n>>> from ibis.common.graph import Node\n>>>\n>>> class MyNode(Concrete, Node):\n...     number: int\n...     string: str\n...     children: tuple[Node, ...]\n>>> a = MyNode(4, \"a\", ())\n>>>\n>>> b = MyNode(3, \"b\", ())\n>>> c = MyNode(2, \"c\", (a, b))\n>>> d = MyNode(1, \"d\", (c,))\n>>>\n>>> assert list(_flatten_collections((c,))) == [c]\n>>> assert list(_flatten_collections([a, b, (c, a)])) == [a, b, c, a]\n>>> assert list(_flatten_collections([{\"b\": b, \"a\": a}])) == [b, a]", "type": "function"}
{"source": "ibis/common/graph.py::_recursive_lookup", "docstring": "Recursively replace objects in a nested structure with values from a dict.\n\nSince we treat common collection types inherently traversable, so we need to\ntraverse them implicitly and replace the values given a result mapping.\n\nParameters\n----------\nobj\n    Object to replace.\ndct\n    Mapping of objects to replace with their values.\n\nReturns\n-------\nObject with replaced values.\n\nExamples\n--------\n>>> from ibis.common.collections import frozendict\n>>> from ibis.common.grounds import Concrete\n>>> from ibis.common.graph import Node\n>>>\n>>> class MyNode(Concrete, Node):\n...     number: int\n...     string: str\n...     children: tuple[Node, ...]\n>>> a = MyNode(4, \"a\", ())\n>>>\n>>> b = MyNode(3, \"b\", ())\n>>> c = MyNode(2, \"c\", (a, b))\n>>> d = MyNode(1, \"d\", (c,))\n>>>\n>>> dct = {a: \"A\", b: \"B\"}\n>>> _recursive_lookup(a, dct)\n'A'\n>>> _recursive_lookup((a, b), dct)\n('A', 'B')\n>>> _recursive_lookup({1: a, 2: b}, dct)\n{1: 'A', 2: 'B'}\n>>> _recursive_lookup((a, frozendict({1: c})), dct)\n('A', {1: MyNode(number=2, ...)})", "type": "function"}
{"source": "ibis/common/graph.py::_apply_replacements", "docstring": "Replace nodes in a possibly nested object.\n\nParameters\n----------\nobj\n    The object to traverse.\nreplacements\n    A mapping of replacement values.\n\nReturns\n-------\ntuple[Any, bool]\n    A tuple of the replaced object and whether any replacements were made.", "type": "function"}
{"source": "ibis/common/graph.py::_coerce_finder", "docstring": "Coerce an object into a callable finder function.\n\nParameters\n----------\nobj\n    A callable accepting the node, a pattern or a type to match on.\ncontext\n    Optional context to use if the finder is a pattern.\n\nReturns\n-------\nA callable finder function which can be used to match nodes.", "type": "function"}
{"source": "ibis/common/graph.py::_coerce_replacer", "docstring": "Coerce an object into a callable replacer function.\n\nParameters\n----------\nobj\n    A Pattern, Mapping, or Callable.\ncontext\n    Optional context to use if the replacer is a pattern.\n\nReturns\n-------\nA callable replacer function which can be used to replace nodes.", "type": "function"}
{"source": "ibis/common/graph.py::Graph", "docstring": "A mapping-like graph data structure for easier graph traversal and manipulation.\n\nThe data structure is a mapping of nodes to their children. The children are\nrepresented as a sequence of nodes. The graph can be constructed from a root node\nusing the `from_bfs` or `from_dfs` class methods.\n\nParameters\n----------\nmapping : Node or Mapping[Node, Sequence[Node]], default ()\n    Either a root node or a mapping of nodes to their children.", "type": "class"}
{"source": "ibis/common/graph.py::traverse", "docstring": "Utility for generic expression tree traversal.\n\nParameters\n----------\nfn\n    A function applied on each expression. The first element of the tuple controls\n    the traversal, and the second is the result if its not `None`.\nnode\n    The Node expression or a list of expressions.", "type": "function"}
{"source": "ibis/common/graph.py::bfs", "docstring": "Construct a graph from a root node using a breadth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::bfs_while", "docstring": "Construct a graph from a root node using a breadth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A callable which returns a boolean given a node. The traversal will only\n    visit nodes that match the given filter and stop otherwise.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::dfs", "docstring": "Construct a graph from a root node using a depth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::dfs_while", "docstring": "Construct a graph from a root node using a depth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A callable which returns a boolean given a node. The traversal will only\n    visit nodes that match the given filter and stop otherwise.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::__recreate__", "docstring": "Reconstruct the node from the given arguments.", "type": "function"}
{"source": "ibis/common/graph.py::__args__", "docstring": "Sequence of arguments to traverse.", "type": "function"}
{"source": "ibis/common/graph.py::__argnames__", "docstring": "Sequence of argument names.", "type": "function"}
{"source": "ibis/common/graph.py::__children__", "docstring": "Sequence of children nodes.", "type": "function"}
{"source": "ibis/common/graph.py::__rich_repr__", "docstring": "Support for rich reprerentation of the node.", "type": "function"}
{"source": "ibis/common/graph.py::map", "docstring": "Apply a function to all nodes in the graph.\n\nThe traversal is done in a topological order, so the function receives the\nresults of its immediate children as keyword arguments.\n\nParameters\n----------\nfn\n    Function to apply to each node. It receives the node as the first argument,\n    the results as the second and the results of the children as keyword\n    arguments.\nfilter\n    Pattern-like object to filter out nodes from the traversal. The traversal\n    will only visit nodes that match the given pattern and stop otherwise.\n\nReturns\n-------\nA mapping of nodes to their results.", "type": "function"}
{"source": "ibis/common/graph.py::map_clear", "docstring": "Apply a function to all nodes in the graph more memory efficiently.\n\nAlternative implementation of `map` to reduce memory usage. While `map` keeps\nall the results in memory until the end of the traversal, this method removes\nintermediate results as soon as they are not needed anymore.\n\nPrefer this method over `map` if the results consume significant amount of\nmemory and if the intermediate results are not needed.\n\nParameters\n----------\nfn\n    Function to apply to each node. It receives the node as the first argument,\n    the results as the second and the results of the children as keyword\n    arguments.\nfilter\n    Pattern-like object to filter out nodes from the traversal. The traversal\n    will only visit nodes that match the given pattern and stop otherwise.\n\nReturns\n-------\nIn contrast to `map`, this method returns the result of the root node only since\nthe rest of the results are already discarded.", "type": "function"}
{"source": "ibis/common/graph.py::map_nodes", "docstring": "Apply a function to all nodes in the graph more memory efficiently.\n\nAlternative implementation of `map` passing only node results to the function\nas positional arguments. This method is useful for calculations where the\nnodes don't need to be reconstructed.", "type": "function"}
{"source": "ibis/common/graph.py::find", "docstring": "Find all nodes matching a given pattern or type in the graph.\n\nAllow to match nodes based on the flexible pattern matching system implemented\nin the pattern module, but also provide a fast path for matching based on the\ntype of the node.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use if `finder` or `filter` is a pattern.\nordered\n    Emit nodes in topological order if `True`.\n\nReturns\n-------\nThe list of nodes matching the given pattern. The order of the nodes is\ndetermined by a breadth-first search.", "type": "function"}
{"source": "ibis/common/graph.py::find_below", "docstring": "Find all nodes below the current node matching a given pattern in the graph.\n\nA variant of find() that only returns nodes below the current node in the graph.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use if `finder` or `filter` is a pattern.\n\nReturns\n-------\nThe list of nodes matching the given pattern.", "type": "function"}
{"source": "ibis/common/graph.py::find_topmost", "docstring": "Find all topmost nodes matching a given pattern in the graph.\n\nA more advanced version of find, this method stops the traversal at the first\nnode that matches the given pattern and does not descend into its children.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\ncontext\n    Optional context to use if `finder` is a pattern.\n\nReturns\n-------\nThe list of topmost nodes matching the given pattern.", "type": "function"}
{"source": "ibis/common/graph.py::replace", "docstring": "Match and replace nodes in the graph according to a given pattern.\n\nThe pattern matching system is used to match nodes in the graph and replace them\nwith the results of the pattern.\n\nParameters\n----------\nreplacer\n    A `Pattern`, `Mapping` or Callable taking the original unrewritten\n    node, and a mapping of attribute name to value of its rewritten\n    children (or None if no children were rewritten).\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nThe root node of the graph with the replaced nodes.", "type": "function"}
{"source": "ibis/common/graph.py::from_bfs", "docstring": "Construct a graph from a root node using a breadth-first search.\n\nThe traversal is implemented in an iterative fashion using a queue.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::from_dfs", "docstring": "Construct a graph from a root node using a depth-first search.\n\nThe traversal is implemented in an iterative fashion using a stack.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nA graph constructed from the root node.", "type": "function"}
{"source": "ibis/common/graph.py::nodes", "docstring": "Return all unique nodes in the graph.", "type": "function"}
{"source": "ibis/common/graph.py::invert", "docstring": "Invert the data structure.\n\nThe graph originally maps nodes to their children, this method inverts the\nmapping to map nodes to their parents.\n\nReturns\n-------\nThe inverted graph.", "type": "function"}
{"source": "ibis/common/graph.py::toposort", "docstring": "Topologically sort the graph using Kahn's algorithm.\n\nThe graph is sorted in a way that all the dependencies of a node are placed\nbefore the node itself. The graph must not contain any cycles. Especially useful\nfor mutating the graph in a way that the dependencies of a node are mutated\nbefore the node itself.\n\nReturns\n-------\nThe topologically sorted graph.", "type": "function"}
{"source": "ibis/common/selectors.py::Selector", "docstring": "A column selector.", "type": "class"}
{"source": "ibis/common/selectors.py::expand", "docstring": "Expand `table` into value expressions that match the selector.\n\nParameters\n----------\ntable\n    An ibis table expression\n\nReturns\n-------\nSequence[Value]\n    A sequence of value expressions that match the selector", "type": "function"}
{"source": "ibis/common/selectors.py::expand_names", "docstring": "Compute the set of column names that match the selector.", "type": "function"}
{"source": "ibis/common/selectors.py::__and__", "docstring": "Compute the logical conjunction of two `Selector`s.\n\nParameters\n----------\nother\n    Another selector", "type": "function"}
{"source": "ibis/common/selectors.py::__or__", "docstring": "Compute the logical disjunction of two `Selector`s.\n\nParameters\n----------\nother\n    Another selector", "type": "function"}
{"source": "ibis/common/selectors.py::__invert__", "docstring": "Compute the logical negation of a `Selector`.", "type": "function"}
{"source": "ibis/common/egraph.py::DisjointSet", "docstring": "Disjoint set data structure.\n\nAlso known as union-find data structure. It is a data structure that keeps\ntrack of a set of elements partitioned into a number of disjoint (non-overlapping)\nsubsets. It provides near-constant-time operations to add new sets, to merge\nexisting sets, and to determine whether elements are in the same set.\n\nParameters\n----------\ndata :\n    Initial data to add to the disjoint set.\n\nExamples\n--------\n>>> ds = DisjointSet()\n>>> ds.add(1)\n1\n>>> ds.add(2)\n2\n>>> ds.add(3)\n3\n>>> ds.union(1, 2)\nTrue\n>>> ds.union(2, 3)\nTrue\n>>> ds.find(1)\n1\n>>> ds.find(2)\n1\n>>> ds.find(3)\n1\n>>> ds.union(1, 3)\nFalse", "type": "class"}
{"source": "ibis/common/egraph.py::Variable", "docstring": "A named capture in a pattern.\n\nParameters\n----------\nname : str\n    The name of the variable.", "type": "class"}
{"source": "ibis/common/egraph.py::Pattern", "docstring": "A non-ground term, tree of enodes possibly containing variables.\n\nThis class is used to represent a pattern in a query. The pattern is almost\nidentical to an ENode, except that it can contain variables.\n\nParameters\n----------\nhead : type\n    The head or python type of the ENode to match against.\nargs : tuple\n    The arguments of the pattern. The arguments can be enodes, patterns,\n    variables or leaf values.\nname : str, optional\n    The name of the pattern which is used to refer to it in a rewrite rule.", "type": "class"}
{"source": "ibis/common/egraph.py::DynamicApplier", "docstring": "A dynamic applier which calls a function to compute the result.", "type": "class"}
{"source": "ibis/common/egraph.py::Rewrite", "docstring": "A rewrite rule which matches a pattern and applies a pattern or a function.", "type": "class"}
{"source": "ibis/common/egraph.py::ENode", "docstring": "A ground term which is a node in the EGraph, called ENode.\n\nParameters\n----------\nhead : type\n    The type of the Node the ENode represents.\nargs : tuple\n    The arguments of the ENode which are either ENodes or leaf values.", "type": "class"}
{"source": "ibis/common/egraph.py::__contains__", "docstring": "Check if the given id is in the disjoint set.\n\nParameters\n----------\nid :\n    The id to check.\n\nReturns\n-------\nined:\n    True if the id is in the disjoint set, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::__getitem__", "docstring": "Get the set of ids that are in the same class as the given id.\n\nParameters\n----------\nid :\n    The id to get the class for.\n\nReturns\n-------\nclass:\n    The set of ids that are in the same class as the given id, including\n    the given id.", "type": "function"}
{"source": "ibis/common/egraph.py::__iter__", "docstring": "Iterate over the ids in the disjoint set.", "type": "function"}
{"source": "ibis/common/egraph.py::__len__", "docstring": "Get the number of ids in the disjoint set.", "type": "function"}
{"source": "ibis/common/egraph.py::__eq__", "docstring": "Check if the disjoint set is equal to another disjoint set.\n\nParameters\n----------\nother :\n    The other disjoint set to compare to.\n\nReturns\n-------\nequal:\n    True if the disjoint sets are equal, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::copy", "docstring": "Make a copy of the disjoint set.\n\nReturns\n-------\ncopy:\n    A copy of the disjoint set.", "type": "function"}
{"source": "ibis/common/egraph.py::add", "docstring": "Add a new id to the disjoint set.\n\nIf the id is not in the disjoint set, it will be added to the disjoint set\nalong with a new class containing only the given id.\n\nParameters\n----------\nid :\n    The id to add to the disjoint set.\n\nReturns\n-------\nid:\n    The id that was added to the disjoint set.", "type": "function"}
{"source": "ibis/common/egraph.py::find", "docstring": "Find the root of the class that the given id is in.\n\nAlso called as the canonicalized id or the representative id.\n\nParameters\n----------\nid :\n    The id to find the canonicalized id for.\n\nReturns\n-------\nid:\n    The canonicalized id for the given id.", "type": "function"}
{"source": "ibis/common/egraph.py::union", "docstring": "Merge the classes that the given ids are in.\n\nIf the ids are already in the same class, this will return False. Otherwise\nit will merge the classes and return True.\n\nParameters\n----------\nid1 :\n    The first id to merge the classes for.\nid2 :\n    The second id to merge the classes for.\n\nReturns\n-------\nmerged:\n    True if the classes were merged, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::connected", "docstring": "Check if the given ids are in the same class.\n\nTrue if both ids have the same canonicalized id, False otherwise.\n\nParameters\n----------\nid1 :\n    The first id to check.\nid2 :\n    The second id to check.\n\nReturns\n-------\nconnected:\n    True if the ids are connected, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::verify", "docstring": "Verify that the disjoint set is not corrupted.\n\nCheck that each id's canonicalized id's class. In general corruption\nshould not happen if the public API is used, but this is a sanity check\nto make sure that the internal data structures are not corrupted.\n\nReturns\n-------\nverified:\n    True if the disjoint set is not corrupted, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::substitute", "docstring": "Substitute the variable with the corresponding value in the substitution.\n\nParameters\n----------\negraph : EGraph\n    The egraph instance.\nenode : ENode\n    The matched enode.\nsubst : dict\n    The substitution dictionary.\n\nReturns\n-------\nvalue : Any\n    The substituted value.", "type": "function"}
{"source": "ibis/common/egraph.py::matches_none", "docstring": "Evaluate whether the pattern is guaranteed to match nothing.\n\nThis can be evaluated before the matching loop starts, so eventually can\nbe eliminated from the flattened query.", "type": "function"}
{"source": "ibis/common/egraph.py::matches_all", "docstring": "Evaluate whether the pattern is guaranteed to match everything.\n\nThis can be evaluated before the matching loop starts, so eventually can\nbe eliminated from the flattened query.", "type": "function"}
{"source": "ibis/common/egraph.py::__rshift__", "docstring": "Syntax sugar to create a rewrite rule.", "type": "function"}
{"source": "ibis/common/egraph.py::__rmatmul__", "docstring": "Syntax sugar to create a named pattern.", "type": "function"}
{"source": "ibis/common/egraph.py::flatten", "docstring": "Recursively flatten the pattern to a join of selections.\n\n`Pattern(Add, (Pattern(Mul, ($x, 1)), $y))` is turned into a join of\nselections by introducing auxiliary variables where each selection gets\nexecuted as a dictionary lookup.\n\nIn SQL terms this is equivalent to the following query:\nSELECT m.0 AS $x, a.1 AS $y FROM Add a JOIN Mul m ON a.0 = m.id WHERE m.1 = 1\n\nParameters\n----------\nvar : Variable\n    The variable to assign to the flattened pattern.\ncounter : Iterator[int]\n    The counter to generate unique variable names for auxiliary variables\n    connecting the selections.\n\nYields\n------\n(var, pattern) : tuple[Variable, Pattern]\n    The variable and the flattened pattern where the flattened pattern\n    cannot contain any patterns just variables.", "type": "function"}
{"source": "ibis/common/egraph.py::substitute", "docstring": "Substitute the variables in the pattern with the corresponding values.\n\nParameters\n----------\negraph : EGraph\n    The egraph instance.\nenode : ENode\n    The matched enode.\nsubst : dict\n    The substitution dictionary.\n\nReturns\n-------\nenode : ENode\n    The substituted pattern which is a ground term aka. an ENode.", "type": "function"}
{"source": "ibis/common/egraph.py::__argnames__", "docstring": "Implementation for the `ibis.common.graph.Node` protocol.", "type": "function"}
{"source": "ibis/common/egraph.py::__args__", "docstring": "Implementation for the `ibis.common.graph.Node` protocol.", "type": "function"}
{"source": "ibis/common/egraph.py::from_node", "docstring": "Convert an `ibis.common.graph.Node` to an `ENode`.", "type": "function"}
{"source": "ibis/common/egraph.py::to_node", "docstring": "Convert the ENode back to an `ibis.common.graph.Node`.", "type": "function"}
{"source": "ibis/common/egraph.py::_as_enode", "docstring": "Convert a node to an enode.", "type": "function"}
{"source": "ibis/common/egraph.py::add", "docstring": "Add a node to the egraph.\n\nThe node is converted to an enode and added to the egraph. If the enode is\nalready present in the egraph, then the canonical enode is returned.\n\nParameters\n----------\nnode :\n    The node to add to the egraph.\n\nReturns\n-------\nenode :\n    The canonical enode.", "type": "function"}
{"source": "ibis/common/egraph.py::union", "docstring": "Union two nodes in the egraph.\n\nThe nodes are converted to enodes which must be present in the egraph.\nThe eclasses of the nodes are merged and the canonical enode is returned.\n\nParameters\n----------\nnode1 :\n    The first node to union.\nnode2 :\n    The second node to union.\n\nReturns\n-------\nenode :\n    The canonical enode.", "type": "function"}
{"source": "ibis/common/egraph.py::_match_args", "docstring": "Match the arguments of an enode against a pattern's arguments.\n\nAn enode matches a pattern if each of the arguments are:\n- both leaf values and equal\n- both enodes and in the same eclass\n- an enode and a variable, in which case the variable gets bound to the enode\n\nParameters\n----------\nargs : tuple\n    The arguments of the enode. Since an enode is a ground term, the arguments\n    are either enodes or leaf values.\npatargs : tuple\n    The arguments of the pattern. Since a pattern is a flat term (flattened\n    using auxiliary variables), the arguments are either variables or leaf\n    values.\n\nReturns\n-------\ndict[str, Any] :\n    The mapping of variable names to enodes or leaf values.", "type": "function"}
{"source": "ibis/common/egraph.py::match", "docstring": "Match a pattern in the egraph.\n\nThe pattern is converted to a conjunctive query (list of flat patterns) and\nmatched against the relations represented by the egraph. This is called the\nrelational e-matching.\n\nParameters\n----------\npattern :\n    The pattern to match in the egraph.\n\nReturns\n-------\nmatches :\n    A dictionary mapping the matched enodes to their substitutions.", "type": "function"}
{"source": "ibis/common/egraph.py::apply", "docstring": "Apply the given rewrites to the egraph.\n\nIteratively match the patterns and apply the rewrites to the graph. The returned\nnumber of changes is the number of eclasses that were merged. This is the\nnumber of changes made to the egraph. The egraph is saturated if the number of\nchanges is zero.\n\nParameters\n----------\nrewrites :\n    A list of rewrites to apply.\n\nReturns\n-------\nn_changes\n    The number of changes made to the egraph.", "type": "function"}
{"source": "ibis/common/egraph.py::run", "docstring": "Run the match-apply cycles for the given number of iterations.\n\nParameters\n----------\nrewrites :\n    A list of rewrites to apply.\nn :\n    The number of iterations to run.\n\nReturns\n-------\nsaturated :\n    True if the egraph is saturated, False otherwise.", "type": "function"}
{"source": "ibis/common/egraph.py::extract", "docstring": "Extract a node from the egraph.\n\nThe node is converted to an enode which recursively gets converted to an\nenode having the lowest cost according to equivalence classes. Currently\nthe cost function is hardcoded as the depth of the enode.\n\nParameters\n----------\nnode :\n    The node to extract from the egraph.\n\nReturns\n-------\nnode :\n    The extracted node.", "type": "function"}
{"source": "ibis/common/egraph.py::equivalent", "docstring": "Check if two nodes are equivalent.\n\nThe nodes are converted to enodes and checked for equivalence: they are\nequivalent if they are in the same equivalence class.\n\nParameters\n----------\nnode1 :\n    The first node.\nnode2 :\n    The second node.\n\nReturns\n-------\nequivalent :\n    True if the nodes are equivalent, False otherwise.", "type": "function"}
{"source": "ibis/common/deferred.py::Resolver", "docstring": "Specification about constructing a value given a context.\n\nThe context is a dictionary that contains all the captured values and\ninformation relevant for the builder.\n\nThe builder is used in the right hand side of the replace pattern:\n`Replace(pattern, builder)`. Semantically when a match occurs for the\nreplace pattern, the builder is called with the context and the result\nof the builder is used as the replacement value.", "type": "class"}
{"source": "ibis/common/deferred.py::Deferred", "docstring": "The user facing wrapper object providing syntactic sugar for deferreds.\n\nProvides a natural-like syntax for constructing deferred expressions by\noverloading all of the available dunder methods including the equality\noperator.\n\nIts sole purpose is to provide a nicer syntax for constructing deferred\nexpressions, thus it gets unwrapped to the underlying deferred expression\nwhen used by the rest of the library.\n\nParameters\n----------\nobj\n    The deferred object to provide syntax sugar for.\nrepr\n    An optional fixed string to use when repr-ing the deferred expression,\n    instead of the default. This is useful for complex deferred expressions\n    where the arguments don't necessarily make sense to be user facing in\n    the repr.", "type": "class"}
{"source": "ibis/common/deferred.py::Variable", "docstring": "Retrieve a value from the context.\n\nParameters\n----------\nname\n    The key to retrieve from the state.", "type": "class"}
{"source": "ibis/common/deferred.py::Just", "docstring": "Construct exactly the given value.\n\nParameters\n----------\nvalue\n    The value to return when the deferred is called.", "type": "class"}
{"source": "ibis/common/deferred.py::JustUnhashable", "docstring": "Construct exactly the given unhashable value.\n\nParameters\n----------\nvalue\n    The value to return when the deferred is called.", "type": "class"}
{"source": "ibis/common/deferred.py::Factory", "docstring": "Construct a value by calling a function.\n\nThe function is called with two positional arguments:\n1. the value being matched\n2. the context dictionary\n\nThe function must return the constructed value.\n\nParameters\n----------\nfunc\n    The function to apply.", "type": "class"}
{"source": "ibis/common/deferred.py::Call", "docstring": "Pattern that calls a function with the given arguments.\n\nBoth positional and keyword arguments are coerced into patterns.\n\nParameters\n----------\nfunc\n    The function to call.\nargs\n    The positional argument patterns.\nkwargs\n    The keyword argument patterns.", "type": "class"}
{"source": "ibis/common/deferred.py::deferrable", "docstring": "Wrap a top-level expr function to support deferred arguments.\n\nWhen a deferrable function is called, the args & kwargs are traversed to\nlook for `Deferred` values (through builtin collections like\n`list`/`tuple`/`set`/`dict`). If any `Deferred` arguments are found, then\nthe result is also `Deferred`. Otherwise the function is called directly.\n\nParameters\n----------\nfunc\n    A callable to make deferrable\nrepr\n    An optional fixed string to use when repr-ing the deferred expression,\n    instead of the usual. This is useful for complex deferred expressions\n    where the arguments don't necessarily make sense to be user facing\n    in the repr.", "type": "function"}
{"source": "ibis/common/deferred.py::resolve", "docstring": "Construct a new object from the context.\n\nParameters\n----------\ncontext\n    A dictionary containing all the captured values and information\n    relevant for the deferred.\n\nReturns\n-------\nThe constructed object.", "type": "function"}
{"source": "ibis/common/caching.py::memoize", "docstring": "Memoize a function.", "type": "function"}
{"source": "ibis/common/collections.py::Iterable", "docstring": "Iterable abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Reversible", "docstring": "Reverse iterable abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Iterator", "docstring": "Iterator abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Sized", "docstring": "Sized abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Container", "docstring": "Container abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Collection", "docstring": "Collection abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Sequence", "docstring": "Sequence abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::Mapping", "docstring": "Mapping abstract base class for quicker isinstance checks.", "type": "class"}
{"source": "ibis/common/collections.py::MapSet", "docstring": "A mapping that also supports set-like operations.\n\nIt is an altered version of `collections.abc.Mapping` that supports set-like\noperations. The `__iter__`, `__len__`, and `__getitem__` methods must be\nimplemented.\n\nThe set-like operations' other operand must be a `Mapping`. If the two\noperands contain common keys but with different values, then the operation\nbecomes ambiguous and an exception will be raised.\n\nExamples\n--------\n>>> from ibis.common.collections import MapSet\n>>> class MyMap(MapSet):\n...     __slots__ = (\"_data\",)\n...\n...     def __init__(self, *args, **kwargs):\n...         self._data = dict(*args, **kwargs)\n...\n...     def __iter__(self):\n...         return iter(self._data)\n...\n...     def __len__(self):\n...         return len(self._data)\n...\n...     def __getitem__(self, key):\n...         return self._data[key]\n...\n...     def __repr__(self):\n...         return f\"MyMap({repr(self._data)})\"\n>>> m = MyMap(a=1, b=2)\n>>> n = dict(a=1, b=2, c=3)\n>>> m <= n\nTrue\n>>> m < n\nTrue\n>>> n - m\nMyMap({'c': 3})\n>>> m & n\nMyMap({'a': 1, 'b': 2})\n>>> m | n\nMyMap({'a': 1, 'b': 2, 'c': 3})", "type": "class"}
{"source": "ibis/common/collections.py::RewindableIterator", "docstring": "Iterator that can be rewound to a checkpoint.\n\nExamples\n--------\n>>> it = RewindableIterator(range(5))\n>>> next(it)\n0\n>>> next(it)\n1\n>>> it.checkpoint()\n>>> next(it)\n2\n>>> next(it)\n3\n>>> it.rewind()\n>>> next(it)\n2\n>>> next(it)\n3\n>>> next(it)\n4", "type": "class"}
{"source": "ibis/common/collections.py::rewind", "docstring": "Rewind the iterator to the last checkpoint.", "type": "function"}
{"source": "ibis/common/collections.py::checkpoint", "docstring": "Create a checkpoint of the current iterator state.", "type": "function"}
{"source": "ibis/common/exceptions.py::TableNotFound", "docstring": "Exception to raise when a table cannot be found.", "type": "class"}
{"source": "ibis/common/exceptions.py::IbisError", "docstring": "IbisError.", "type": "class"}
{"source": "ibis/common/exceptions.py::InternalError", "docstring": "InternalError.", "type": "class"}
{"source": "ibis/common/exceptions.py::IntegrityError", "docstring": "IntegrityError.", "type": "class"}
{"source": "ibis/common/exceptions.py::ExpressionError", "docstring": "ExpressionError.", "type": "class"}
{"source": "ibis/common/exceptions.py::RelationError", "docstring": "RelationError.", "type": "class"}
{"source": "ibis/common/exceptions.py::TranslationError", "docstring": "TranslationError.", "type": "class"}
{"source": "ibis/common/exceptions.py::OperationNotDefinedError", "docstring": "OperationNotDefinedError.", "type": "class"}
{"source": "ibis/common/exceptions.py::UnsupportedOperationError", "docstring": "UnsupportedOperationError.", "type": "class"}
{"source": "ibis/common/exceptions.py::UnsupportedBackendType", "docstring": "UnsupportedBackendType.", "type": "class"}
{"source": "ibis/common/exceptions.py::UnboundExpressionError", "docstring": "UnboundExpressionError.", "type": "class"}
{"source": "ibis/common/exceptions.py::IbisInputError", "docstring": "IbisInputError.", "type": "class"}
{"source": "ibis/common/exceptions.py::IbisTypeError", "docstring": "IbisTypeError.", "type": "class"}
{"source": "ibis/common/exceptions.py::InputTypeError", "docstring": "InputTypeError.", "type": "class"}
{"source": "ibis/common/exceptions.py::UnsupportedArgumentError", "docstring": "UnsupportedArgumentError.", "type": "class"}
{"source": "ibis/common/exceptions.py::BackendConversionError", "docstring": "A backend cannot convert an input to its native type.", "type": "class"}
{"source": "ibis/common/exceptions.py::BackendConfigurationNotRegistered", "docstring": "A backend has options but isn't registered in ibis/config.py.", "type": "class"}
{"source": "ibis/common/exceptions.py::ConflictingValuesError", "docstring": "A single key has conflicting values in two different mappings.", "type": "class"}
{"source": "ibis/common/exceptions.py::mark_as_unsupported", "docstring": "Decorate an unsupported method.", "type": "function"}
{"source": "ibis/common/typing.py::get_type_hints", "docstring": "Get type hints for a callable or class.\n\nExtension of typing.get_type_hints that supports getting type hints for\nclass properties.\n\nParameters\n----------\nobj\n    Callable or class to get type hints for.\ninclude_extras\n    Whether to include extra type hints such as Annotated.\ninclude_properties\n    Whether to include type hints for class properties.\n\nReturns\n-------\nMapping of parameter or attribute name to type hint.", "type": "function"}
{"source": "ibis/common/typing.py::get_type_params", "docstring": "Get type parameters for a generic class.\n\nParameters\n----------\nobj\n    Generic class to get type parameters for.\n\nReturns\n-------\nMapping of type parameter name to type.\n\nExamples\n--------\n>>> from typing import Dict, List\n>>> class MyList(List[T]): ...\n>>> get_type_params(MyList[int])\n{'T': <class 'int'>}\n>>> class MyDict(Dict[T, U]): ...\n>>> get_type_params(MyDict[int, str])\n{'T': <class 'int'>, 'U': <class 'str'>}", "type": "function"}
{"source": "ibis/common/typing.py::get_bound_typevars", "docstring": "Get type variables bound to concrete types for a generic class.\n\nParameters\n----------\nobj\n    Generic class to get type variables for.\n\nReturns\n-------\nMapping of type variable to attribute name and type.\n\nExamples\n--------\n>>> from typing import Generic\n>>> class MyStruct(Generic[T, U]):\n...     a: T\n...     b: U\n>>> get_bound_typevars(MyStruct[int, str])\n{~T: ('a', <class 'int'>), ~U: ('b', <class 'str'>)}\n>>>\n>>> class MyStruct(Generic[T, U]):\n...     a: T\n...\n...     @property\n...     def myprop(self) -> U: ...\n>>> get_bound_typevars(MyStruct[float, bytes])\n{~T: ('a', <class 'float'>), ~U: ('myprop', <class 'bytes'>)}", "type": "function"}
{"source": "ibis/common/typing.py::evaluate_annotations", "docstring": "Evaluate type annotations that are strings.\n\nParameters\n----------\nannots\n    Type annotations to evaluate.\nmodule_name\n    The name of the module that the annotations are defined in, hence\n    providing global scope.\nclass_name\n    The name of the class that the annotations are defined in, hence\n    providing Self type.\nbest_effort\n    Whether to ignore errors when evaluating type annotations.\n\nReturns\n-------\nActual type hints.\n\nExamples\n--------\n>>> annots = {\"a\": \"dict[str, float]\", \"b\": \"int\"}\n>>> evaluate_annotations(annots, __name__)\n{'a': dict[str, float], 'b': <class 'int'>}", "type": "function"}
{"source": "ibis/common/typing.py::DefaultTypeVars", "docstring": "Enable using default type variables in generic classes (PEP-0696).", "type": "class"}
{"source": "ibis/common/typing.py::Sentinel", "docstring": "Create type-annotable unique objects.", "type": "class"}
{"source": "ibis/common/typing.py::Coercible", "docstring": "Protocol for defining coercible types.\n\nCoercible types define a special `__coerce__` method that accepts an object\nwith an instance of the type. Used in conjunction with the `coerced_to``\npattern to coerce arguments to a specific type.", "type": "class"}
{"source": "ibis/common/typing.py::get_defining_frame", "docstring": "Locate the outermost frame where `obj` is defined.", "type": "function"}
{"source": "ibis/common/typing.py::get_defining_scope", "docstring": "Get variables in the scope where `expr` is first defined.", "type": "function"}
{"source": "ibis/common/annotations.py::Annotation", "docstring": "Base class for all annotations.\n\nAnnotations are used to mark fields in a class and to validate them.", "type": "class"}
{"source": "ibis/common/annotations.py::Attribute", "docstring": "Annotation to mark a field in a class.\n\nAn optional pattern can be provider to validate the field every time it\nis set.\n\nParameters\n----------\npattern : Pattern, default noop\n    Pattern to validate the field.\ndefault : Callable, default EMPTY\n    Callable to compute the default value of the field.", "type": "class"}
{"source": "ibis/common/annotations.py::Argument", "docstring": "Annotation type for all fields which should be passed as arguments.\n\nParameters\n----------\npattern\n    Optional pattern to validate the argument.\ndefault\n    Optional default value of the argument.\ntypehint\n    Optional typehint of the argument.\nkind\n    Kind of the argument, one of `inspect.Parameter` constants.\n    Defaults to positional or keyword.", "type": "class"}
{"source": "ibis/common/annotations.py::attribute", "docstring": "Annotation to mark a field in a class.", "type": "function"}
{"source": "ibis/common/annotations.py::argument", "docstring": "Annotation type for all fields which should be passed as arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::optional", "docstring": "Annotation to allow and treat `None` values as missing arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::varargs", "docstring": "Annotation to mark a variable length positional arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::varkwargs", "docstring": "Annotation to mark a variable length keyword arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::Parameter", "docstring": "Augmented Parameter class to additionally hold a pattern object.", "type": "class"}
{"source": "ibis/common/annotations.py::Signature", "docstring": "Validatable signature.\n\nPrimarily used in the implementation of `ibis.common.grounds.Annotable`.", "type": "class"}
{"source": "ibis/common/annotations.py::annotated", "docstring": "Create functions with arguments validated at runtime.\n\nThere are various ways to apply this decorator:\n\n1. With type annotations\n\n>>> @annotated\n... def foo(x: int, y: str) -> float:\n...     return float(x) + float(y)\n\n2. With argument patterns passed as keyword arguments\n\n>>> from ibis.common.patterns import InstanceOf as instance_of\n>>> @annotated(x=instance_of(int), y=instance_of(str))\n... def foo(x, y):\n...     return float(x) + float(y)\n\n3. With mixing type annotations and patterns where the latter takes precedence\n\n>>> @annotated(x=instance_of(float))\n... def foo(x: int, y: str) -> float:\n...     return float(x) + float(y)\n\n4. With argument patterns passed as a list and/or an optional return pattern\n\n>>> @annotated([instance_of(int), instance_of(str)], instance_of(float))\n... def foo(x, y):\n...     return float(x) + float(y)\n\nParameters\n----------\n*args : Union[\n            tuple[Callable],\n            tuple[list[Pattern], Callable],\n            tuple[list[Pattern], Pattern, Callable]\n        ]\n    Positional arguments.\n    - If a single callable is passed, it's wrapped with the signature\n    - If two arguments are passed, the first one is a list of patterns for the\n      arguments and the second one is the callable to wrap\n    - If three arguments are passed, the first one is a list of patterns for the\n      arguments, the second one is a pattern for the return value and the third\n      one is the callable to wrap\n**kwargs : dict[str, Pattern]\n    Patterns for the arguments.\n\nReturns\n-------\nCallable", "type": "function"}
{"source": "ibis/common/annotations.py::validate", "docstring": "Validate the field.\n\nParameters\n----------\nname\n    The name of the attribute.\nvalue\n    The value of the attribute.\nthis\n    The instance of the class the attribute is defined on.\n\nReturns\n-------\nThe validated value for the field.", "type": "function"}
{"source": "ibis/common/annotations.py::has_default", "docstring": "Check if the field has a default value.\n\nReturns\n-------\nbool", "type": "function"}
{"source": "ibis/common/annotations.py::get_default", "docstring": "Get the default value of the field.\n\nParameters\n----------\nname\n    The name of the attribute.\nthis\n    The instance of the class the attribute is defined on.\n\nReturns\n-------\nThe default value for the field.", "type": "function"}
{"source": "ibis/common/annotations.py::__call__", "docstring": "Needed to support the decorator syntax.", "type": "function"}
{"source": "ibis/common/annotations.py::from_argument", "docstring": "Construct a Parameter from an Argument annotation.", "type": "function"}
{"source": "ibis/common/annotations.py::merge", "docstring": "Merge multiple signatures.\n\nIn addition to concatenating the parameters, it also reorders the\nparameters so that optional arguments come after mandatory arguments.\n\nParameters\n----------\n*signatures : Signature\n    Signature instances to merge.\n**annotations : dict\n    Annotations to add to the merged signature.\n\nReturns\n-------\nSignature", "type": "function"}
{"source": "ibis/common/annotations.py::from_callable", "docstring": "Create a validateable signature from a callable.\n\nParameters\n----------\nfn : Callable\n    Callable to create a signature from.\npatterns : list or dict, default None\n    Pass patterns to add missing or override existing argument type\n    annotations.\nreturn_pattern : Pattern, default None\n    Pattern for the return value of the callable.\n\nReturns\n-------\nSignature", "type": "function"}
{"source": "ibis/common/annotations.py::unbind", "docstring": "Reverse bind of the parameters.\n\nAttempts to reconstructs the original arguments as keyword only arguments.\n\nParameters\n----------\nthis : Any\n    Object with attributes matching the signature parameters.\n\nReturns\n-------\nargs : (args, kwargs)\n    Tuple of positional and keyword arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::validate", "docstring": "Validate the arguments against the signature.\n\nParameters\n----------\nfunc : Callable\n    Callable to validate the arguments for.\nargs : tuple\n    Positional arguments.\nkwargs : dict\n    Keyword arguments.\n\nReturns\n-------\nvalidated : dict\n    Dictionary of validated arguments.", "type": "function"}
{"source": "ibis/common/annotations.py::validate_nobind", "docstring": "Validate the arguments against the signature without binding.", "type": "function"}
{"source": "ibis/common/annotations.py::validate_return", "docstring": "Validate the return value of a function.\n\nParameters\n----------\nfunc : Callable\n    Callable to validate the return value for.\nvalue : Any\n    Return value of the function.\n\nReturns\n-------\nvalidated : Any\n    Validated return value.", "type": "function"}
{"source": "ibis/common/bases.py::AbstractMeta", "docstring": "Base metaclass for many of the ibis core classes.\n\nEnforce the subclasses to define a `__slots__` attribute and provide a\n`__create__` classmethod to change the instantiation behavior of the class.\n\nSupport abstract methods without extending `abc.ABCMeta`. While it provides\na reduced feature set compared to `abc.ABCMeta` (no way to register virtual\nsubclasses) but avoids expensive instance checks by enforcing explicit\nsubclassing.", "type": "class"}
{"source": "ibis/common/bases.py::Abstract", "docstring": "Base class for many of the ibis core classes, see `AbstractMeta`.", "type": "class"}
{"source": "ibis/common/bases.py::Immutable", "docstring": "Prohibit attribute assignment on the instance.", "type": "class"}
{"source": "ibis/common/bases.py::Singleton", "docstring": "Cache instances of the class based on instantiation arguments.", "type": "class"}
{"source": "ibis/common/bases.py::Final", "docstring": "Prohibit subclassing.", "type": "class"}
{"source": "ibis/common/bases.py::Comparable", "docstring": "Enable quick equality comparisons.\n\nThe subclasses must implement the `__equals__` method that returns a boolean\nvalue indicating whether the two instances are equal. This method is called\nonly if the two instances are of the same type and the result is cached for\nfuture comparisons.\n\nSince the class holds a global cache of comparison results, it is important\nto make sure that the instances are not kept alive longer than necessary.", "type": "class"}
{"source": "ibis/common/bases.py::Slotted", "docstring": "A lightweight alternative to `ibis.common.grounds.Annotable`.\n\nThe class is mostly used to reduce boilerplate code.", "type": "class"}
{"source": "ibis/common/bases.py::FrozenSlotted", "docstring": "A lightweight alternative to `ibis.common.grounds.Concrete`.\n\nThis class is used to create immutable dataclasses with slots and a precomputed\nhash value for quicker dictionary lookups.", "type": "class"}
{"source": "ibis/common/bases.py::__call__", "docstring": "Create a new instance of the class.\n\nThe subclass may override the `__create__` classmethod to change the\ninstantiation behavior. This is similar to overriding the `__new__`\nmethod, but without conditionally calling the `__init__` based on the\nreturn type.\n\nParameters\n----------\nargs : tuple\n    Positional arguments eventually passed to the `__init__` method.\nkwargs : dict\n    Keyword arguments eventually passed to the `__init__` method.\n\nReturns\n-------\nThe newly created instance of the class. No extra initialization", "type": "function"}
{"source": "ibis/common/grounds.py::AnnotableMeta", "docstring": "Metaclass to turn class annotations into a validatable function signature.", "type": "class"}
{"source": "ibis/common/grounds.py::Annotable", "docstring": "Base class for objects with custom validation rules.", "type": "class"}
{"source": "ibis/common/grounds.py::Concrete", "docstring": "Opinionated base class for immutable data classes.", "type": "class"}
{"source": "ibis/common/grounds.py::copy", "docstring": "Return a copy of this object with the given overrides.\n\nParameters\n----------\noverrides\n    Argument override values\n\nReturns\n-------\nAnnotable\n    New instance of the copied object", "type": "function"}
{"source": "ibis/common/tests/test_dispatch.py::foo", "docstring": "A docstring.", "type": "function"}
{"source": "ibis/common/tests/test_typing.py::missing", "docstring": "marker for missing value", "type": "class"}
{"source": "ibis/common/tests/test_typing.py::missing1", "docstring": "marker for missing value", "type": "class"}
{"source": "ibis/expr/types/arrays.py::ArrayValue", "docstring": "An Array is a variable-length sequence of values of a single type.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.memtable({\"a\": [[1, None, 3], [4], [], None]})\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, None, ... +1]    \u2502\n\u2502 [4]                  \u2502\n\u2502 []                   \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "class"}
{"source": "ibis/expr/types/arrays.py::array", "docstring": "Create an array expression.\n\nIf any values are [column expressions](../concepts/datatypes.qmd) the\nresult will be a column. Otherwise the result will be a\n[scalar](../concepts/datatypes.qmd).\n\nParameters\n----------\nvalues\n    An iterable of Ibis expressions or Python literals\n\nReturns\n-------\nArrayValue\n\nExamples\n--------\nCreate an array scalar from scalar values\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.array([1.0, None])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [1.0, None] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate an array from column and scalar expressions\n\n>>> t = ibis.memtable({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n>>> ibis.array([t.a, 42, ibis.literal(None)])\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Array((a, 42, None)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 42, ... +1]      \u2502\n\u2502 [2, 42, ... +1]      \u2502\n\u2502 [3, 42, ... +1]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> ibis.array([t.a, 42 + ibis.literal(5)])\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Array((a, Add(5, 42))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 47]                \u2502\n\u2502 [2, 47]                \u2502\n\u2502 [3, 47]                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::length", "docstring": "Compute the length of an array.\n\nReturns\n-------\nIntegerValue\n    The integer length of each element of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[7, 42], [3], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 42]              \u2502\n\u2502 [3]                  \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.length()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayLength(a) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              2 \u2502\n\u2502              1 \u2502\n\u2502           NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::__getitem__", "docstring": "Extract one or more elements of `self`.\n\nParameters\n----------\nindex\n    Index into `array`\n\nReturns\n-------\nValue\n    - If `index` is an [](`int`) or\n      [`IntegerValue`](./expression-numeric.qmd#ibis.expr.types.IntegerValue)\n      then the return type is the element type of `self`.\n    - If `index` is a [](`slice`) then the return type is the same\n      type as the input.\n\nExamples\n--------\nExtract a single element\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[7, 42], [3], None]})\n>>> t.a[0]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayIndex(a, 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                7 \u2502\n\u2502                3 \u2502\n\u2502             NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExtract a range of elements\n\n>>> t = ibis.memtable({\"a\": [[7, 42, 72], [3] * 5, None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 42, ... +1]      \u2502\n\u2502 [3, 3, ... +3]       \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a[1:2]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArraySlice(a, 1, 2)  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [42]                 \u2502\n\u2502 [3]                  \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::concat", "docstring": "Concatenate this array with one or more arrays.\n\nParameters\n----------\nother\n    Other array to concat with `self`\nargs\n    Other arrays to concat with `self`\n\nReturns\n-------\nArrayValue\n    `self` concatenated with `other` and `args`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[7], [3], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7]                  \u2502\n\u2502 [3]                  \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.concat(t.a)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayConcat((a, a))  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 7]               \u2502\n\u2502 [3, 3]               \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.concat(ibis.literal([4], type=\"array<int64>\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayConcat((a, (4,))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 4]                 \u2502\n\u2502 [3, 4]                 \u2502\n\u2502 NULL                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`concat` is also available using the `+` operator\n\n>>> [1] + t.a\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayConcat(((1,), a)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 7]                 \u2502\n\u2502 [1, 3]                 \u2502\n\u2502 NULL                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a + [1]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayConcat((a, (1,))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 1]                 \u2502\n\u2502 [3, 1]                 \u2502\n\u2502 NULL                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::repeat", "docstring": "Repeat this array `n` times.\n\nParameters\n----------\nn\n    Number of times to repeat `self`.\n\nReturns\n-------\nArrayValue\n    `self` repeated `n` times\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[7], [3], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7]                  \u2502\n\u2502 [3]                  \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.repeat(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayRepeat(a, 2)    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 7]               \u2502\n\u2502 [3, 3]               \u2502\n\u2502 []                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`repeat` is also available using the `*` operator\n\n>>> 2 * t.a\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayRepeat(a, 2)    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 7]               \u2502\n\u2502 [3, 3]               \u2502\n\u2502 []                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::unnest", "docstring": "Unnest an array into a column.\n\n::: {.callout-note}\n## Empty arrays and `NULL`s are dropped in the output.\nTo preserve empty arrays as `NULL`s as well as existing `NULL` values,\nuse [`Table.unnest`](./expression-tables.qmd#ibis.expr.types.relations.Table.unnest).\n:::\n\nReturns\n-------\nir.Value\n    Unnested array\n\nSee Also\n--------\n[`Table.unnest`](./expression-tables.qmd#ibis.expr.types.relations.Table.unnest)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[7, 42], [3, 3], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [7, 42]              \u2502\n\u2502 [3, 3]               \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.unnest()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502    42 \u2502\n\u2502     3 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::join", "docstring": "Join the elements of this array expression with `sep`.\n\nParameters\n----------\nsep\n    Separator to use for joining array elements\n\nReturns\n-------\nStringValue\n    Elements of `self` joined with `sep`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[\"a\", \"b\", \"c\"], None, [], [\"b\", None]]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b', ... +1]   \u2502\n\u2502 NULL                 \u2502\n\u2502 []                   \u2502\n\u2502 ['b', None]          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.join(\"|\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayStringJoin(arr, '|') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a|b|c                     \u2502\n\u2502 NULL                      \u2502\n\u2502 NULL                      \u2502\n\u2502 b                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`StringValue.join`](./expression-strings.qmd#ibis.expr.types.strings.StringValue.join)", "type": "function"}
{"source": "ibis/expr/types/arrays.py::map", "docstring": "Apply a `func` or `Deferred` to each element of this array expression.\n\nParameters\n----------\nfunc\n    Function or `Deferred` to apply to each element of this array.\n\n    Callables must accept one or two arguments. If there are two\n    arguments, the second argument is the **zero**-based index of each\n    element of the array.\n\nReturns\n-------\nArrayValue\n    `func` applied to every element of this array expression.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[1, None, 2], [4], []]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, None, ... +1]    \u2502\n\u2502 [4]                  \u2502\n\u2502 []                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThe most succinct way to use `map` is with `Deferred` expressions:\n\n>>> t.a.map((_ + 100).cast(\"float\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayMap(a, Cast(Add(_, 100), float64), _) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<float64>                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [101.0, None, ... +1]                      \u2502\n\u2502 [104.0]                                    \u2502\n\u2502 []                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can also use `map` with a lambda function:\n\n>>> t.a.map(lambda x: (x + 100).cast(\"float\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayMap(a, Cast(Add(x, 100), float64), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<float64>                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [101.0, None, ... +1]                      \u2502\n\u2502 [104.0]                                    \u2502\n\u2502 []                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`.map()` also supports more complex callables like `functools.partial`\nand `lambda`s with closures\n\n>>> from functools import partial\n>>> def add(x, y):\n...     return x + y\n>>> add2 = partial(add, y=2)\n>>> t.a.map(add2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayMap(a, Add(x, 2), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, None, ... +1]         \u2502\n\u2502 [6]                       \u2502\n\u2502 []                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> y = 2\n>>> t.a.map(lambda x: x + y)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayMap(a, Add(x, 2), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, None, ... +1]         \u2502\n\u2502 [6]                       \u2502\n\u2502 []                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can optionally include a second index argument in the mapped function\n\n>>> t.a.map(lambda x, i: i % 2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayMap(a, Modulus(i, 2), x, i) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [0, 1, ... +1]                   \u2502\n\u2502 [0]                              \u2502\n\u2502 []                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::filter", "docstring": "Filter array elements using `predicate` function or `Deferred`.\n\nParameters\n----------\npredicate\n    Function or `Deferred` to use to filter array elements.\n\n    Callables must accept one or two arguments. If there are two\n    arguments, the second argument is the **zero**-based index of each\n    element of the array.\n\nReturns\n-------\nArrayValue\n    Array elements filtered using `predicate`\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [[1, None, 2], [4], []]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, None, ... +1]    \u2502\n\u2502 [4]                  \u2502\n\u2502 []                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThe most succinct way to use `filter` is with `Deferred` expressions:\n\n>>> t.a.filter(_ > 1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFilter(a, Greater(_, 1), _) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2]                              \u2502\n\u2502 [4]                              \u2502\n\u2502 []                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can also use `filter` with a lambda function:\n\n>>> t.a.filter(lambda x: x > 1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFilter(a, Greater(x, 1), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2]                              \u2502\n\u2502 [4]                              \u2502\n\u2502 []                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`.filter()` also supports more complex callables like `functools.partial`\nand `lambda`s with closures\n\n>>> from functools import partial\n>>> def gt(x, y):\n...     return x > y\n>>> gt1 = partial(gt, y=1)\n>>> t.a.filter(gt1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFilter(a, Greater(x, 1), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2]                              \u2502\n\u2502 [4]                              \u2502\n\u2502 []                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> y = 1\n>>> t.a.filter(lambda x: x > y)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFilter(a, Greater(x, 1), x) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2]                              \u2502\n\u2502 [4]                              \u2502\n\u2502 []                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can optionally include a second index argument in the predicate function\n\n>>> t.a.filter(lambda x, i: i % 4 == 0)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFilter(a, Equals(Modulus(i, 4), 0), x, i) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1]                                            \u2502\n\u2502 [4]                                            \u2502\n\u2502 []                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::contains", "docstring": "Return whether the array contains `other`.\n\nParameters\n----------\nother\n    Ibis expression to check for existence of in `self`\n\nReturns\n-------\nBooleanValue\n    Whether `other` is contained in `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1], [], [42, 42], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1]                  \u2502\n\u2502 []                   \u2502\n\u2502 [42, 42]             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.contains(42)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayContains(arr, 42) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                  \u2502\n\u2502 False                  \u2502\n\u2502 True                   \u2502\n\u2502 NULL                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.contains(None)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayContains(arr, None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL                     \u2502\n\u2502 NULL                     \u2502\n\u2502 NULL                     \u2502\n\u2502 NULL                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::index", "docstring": "Return the position of `other` in an array.\n\nParameters\n----------\nother\n    Ibis expression to existence of in `self`\n\nReturns\n-------\nBooleanValue\n    The position of `other` in `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1], [], [42, 42], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1]                  \u2502\n\u2502 []                   \u2502\n\u2502 [42, 42]             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.index(42)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayPosition(arr, 42) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     -1 \u2502\n\u2502                     -1 \u2502\n\u2502                      0 \u2502\n\u2502                   NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.index(800)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayPosition(arr, 800) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                      -1 \u2502\n\u2502                      -1 \u2502\n\u2502                      -1 \u2502\n\u2502                    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.index(None)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayPosition(arr, None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     NULL \u2502\n\u2502                     NULL \u2502\n\u2502                     NULL \u2502\n\u2502                     NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::remove", "docstring": "Remove `other` from `self`.\n\nParameters\n----------\nother\n    Element to remove from `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[3, 2], [], [42, 2], [2, 2], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 2]               \u2502\n\u2502 []                   \u2502\n\u2502 [42, 2]              \u2502\n\u2502 [2, 2]               \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.remove(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayRemove(arr, 2)  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3]                  \u2502\n\u2502 []                   \u2502\n\u2502 [42]                 \u2502\n\u2502 []                   \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::unique", "docstring": "Return the unique values in an array.\n\n::: {.callout-note}\n## Element ordering in array may not be retained.\n:::\n\nReturns\n-------\nArrayValue\n    Unique values in an array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 3, 3], [], [42, 42, None], None]})\n>>> t.arr.unique()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayDistinct(arr)   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 1]               \u2502\n\u2502 []                   \u2502\n\u2502 [42, None]           \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::sort", "docstring": "Sort the elements in an array.\n\nReturns\n-------\nArrayValue\n    Sorted values in an array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[3, 2], [], [42, 42], None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 2]               \u2502\n\u2502 []                   \u2502\n\u2502 [42, 42]             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr.sort()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArraySort(arr)       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [2, 3]               \u2502\n\u2502 []                   \u2502\n\u2502 [42, 42]             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::union", "docstring": "Union two arrays.\n\nParameters\n----------\nother\n    Another array to union with `self`\n\nReturns\n-------\nArrayValue\n    Unioned arrays\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr1\": [[3, 2], [], None], \"arr2\": [[1, 3], [None], [5]]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr1                 \u2503 arr2                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 2]               \u2502 [1, 3]               \u2502\n\u2502 []                   \u2502 [None]               \u2502\n\u2502 NULL                 \u2502 [5]                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr1.union(t.arr2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayUnion(arr1, arr2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +1]         \u2502\n\u2502 [None]                 \u2502\n\u2502 [5]                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr1.union(t.arr2).contains(3)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayContains(ArrayUnion(arr1, arr2), 3) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                                     \u2502\n\u2502 False                                    \u2502\n\u2502 False                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::intersect", "docstring": "Intersect two arrays.\n\nParameters\n----------\nother\n    Another array to intersect with `self`\n\nReturns\n-------\nArrayValue\n    Intersected arrays\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr1\": [[3, 2], [], None], \"arr2\": [[1, 3], [None], [5]]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr1                 \u2503 arr2                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 2]               \u2502 [1, 3]               \u2502\n\u2502 []                   \u2502 [None]               \u2502\n\u2502 NULL                 \u2502 [5]                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.arr1.intersect(t.arr2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayIntersect(arr1, arr2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3]                        \u2502\n\u2502 []                         \u2502\n\u2502 NULL                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::zip", "docstring": "Zip two or more arrays together.\n\nParameters\n----------\nother\n    Another array to zip with `self`\nothers\n    Additional arrays to zip with `self`\n\nReturns\n-------\nArray\n    Array of structs where each struct field is an element of each input\n    array. The fields are named `f1`, `f2`, `f3`, etc.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.options.repr.interactive.max_depth = 2\n>>> t = ibis.memtable(\n...     {\n...         \"numbers\": [[3, 2], [6, 7], [], None],\n...         \"strings\": [[\"a\", \"c\"], [\"d\"], [], [\"x\", \"y\"]],\n...     }\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 numbers              \u2503 strings              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 array<string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [3, 2]               \u2502 ['a', 'c']           \u2502\n\u2502 [6, 7]               \u2502 ['d']                \u2502\n\u2502 []                   \u2502 []                   \u2502\n\u2502 NULL                 \u2502 ['x', 'y']           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.numbers.zip(t.strings)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayZip((numbers, strings))                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<struct<f1: int64, f2: string>>          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [{'f1': 3, 'f2': 'a'}, {'f1': 2, 'f2': 'c'}]  \u2502\n\u2502 [{'f1': 6, 'f2': 'd'}, {'f1': 7, 'f2': None}] \u2502\n\u2502 []                                            \u2502\n\u2502 NULL                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::flatten", "docstring": "Remove one level of nesting from an array expression.\n\nReturns\n-------\nArrayValue\n    Flattened array expression\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> schema = {\n...     \"empty\": \"array<array<int>>\",\n...     \"happy\": \"array<array<string>>\",\n...     \"nulls_only\": \"array<array<struct<a: array<string>>>>\",\n...     \"mixed_nulls\": \"array<array<string>>\",\n... }\n>>> data = {\n...     \"empty\": [[], [], []],\n...     \"happy\": [[[\"abc\"]], [[\"bcd\"]], [[\"def\"]]],\n...     \"nulls_only\": [None, None, None],\n...     \"mixed_nulls\": [[], None, [None]],\n... }\n>>> import pyarrow as pa\n>>> t = ibis.memtable(\n...     pa.Table.from_pydict(\n...         data,\n...         schema=ibis.schema(schema).to_pyarrow(),\n...     )\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 empty                \u2503 happy                \u2503 nulls_only \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 array<array<int64>>  \u2502 array<array<string>> \u2502 array<arr\u2026 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 []                   \u2502 [[...]]              \u2502 NULL       \u2502 \u2026 \u2502\n\u2502 []                   \u2502 [[...]]              \u2502 NULL       \u2502 \u2026 \u2502\n\u2502 []                   \u2502 [[...]]              \u2502 NULL       \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.empty.flatten()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFlatten(empty)  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 []                   \u2502\n\u2502 []                   \u2502\n\u2502 []                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.happy.flatten()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFlatten(happy)  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['abc']              \u2502\n\u2502 ['bcd']              \u2502\n\u2502 ['def']              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.nulls_only.flatten()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFlatten(nulls_only) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<struct<a: array<s\u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL                     \u2502\n\u2502 NULL                     \u2502\n\u2502 NULL                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mixed_nulls.flatten()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayFlatten(mixed_nulls) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 []                        \u2502\n\u2502 NULL                      \u2502\n\u2502 []                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.select(s.across(s.all(), _.flatten()))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 empty                \u2503 happy                \u2503 nulls_only \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 array<string>        \u2502 array<str\u2026 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 []                   \u2502 ['abc']              \u2502 NULL       \u2502 \u2026 \u2502\n\u2502 []                   \u2502 ['bcd']              \u2502 NULL       \u2502 \u2026 \u2502\n\u2502 []                   \u2502 ['def']              \u2502 NULL       \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::anys", "docstring": "Return whether any element in the array is true.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`BooleanColumn.any`](./expression-numeric.qmd#ibis.expr.types.logical.BooleanColumn.any)\n\nReturns\n-------\nBooleanValue\n    Whether any element in the array is true\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"arr\": [\n...             [True, False],\n...             [False],\n...             [True],\n...             [None, False],\n...             [None, True],\n...             [None],\n...             [],\n...             None,\n...         ]\n...     }\n... )\n>>> t.mutate(x=t.arr.anys())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 x       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<boolean>       \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [True, False]        \u2502 True    \u2502\n\u2502 [False]              \u2502 False   \u2502\n\u2502 [True]               \u2502 True    \u2502\n\u2502 [None, False]        \u2502 False   \u2502\n\u2502 [None, True]         \u2502 True    \u2502\n\u2502 [None]               \u2502 NULL    \u2502\n\u2502 []                   \u2502 NULL    \u2502\n\u2502 NULL                 \u2502 NULL    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::alls", "docstring": "Return whether all elements (ignoring nulls) in the array are true.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`BooleanColumn.all`](./expression-numeric.qmd#ibis.expr.types.logical.BooleanColumn.all)\n\nReturns\n-------\nBooleanValue\n    Whether all elements (ignoring nulls) in the array are true.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": range(8),\n...         \"arr\": [\n...             [True, False],\n...             [False],\n...             [True],\n...             [None, False],\n...             [None, True],\n...             [None],\n...             [],\n...             None,\n...         ],\n...     }\n... )\n>>> t.mutate(x=t.arr.alls()).order_by(\"id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 arr                  \u2503 x       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 array<boolean>       \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502 [True, False]        \u2502 False   \u2502\n\u2502     1 \u2502 [False]              \u2502 False   \u2502\n\u2502     2 \u2502 [True]               \u2502 True    \u2502\n\u2502     3 \u2502 [None, False]        \u2502 False   \u2502\n\u2502     4 \u2502 [None, True]         \u2502 True    \u2502\n\u2502     5 \u2502 [None]               \u2502 NULL    \u2502\n\u2502     6 \u2502 []                   \u2502 NULL    \u2502\n\u2502     7 \u2502 NULL                 \u2502 NULL    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::modes", "docstring": "Return the mode of the values in the array.\n\nSee Also\n--------\n[`Column.mode`](./expression-generic.qmd#ibis.expr.types.generic.Column.mode)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 2, 3, 3], [None, 6], [None], [], None]})\n>>> t.mutate(mode=t.arr.modes())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 mode  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +2]       \u2502     3 \u2502\n\u2502 [None, 6]            \u2502     6 \u2502\n\u2502 [None]               \u2502  NULL \u2502\n\u2502 []                   \u2502  NULL \u2502\n\u2502 NULL                 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::mins", "docstring": "Return the minimum value in the array.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`Column.min`](./expression-generic.qmd#ibis.expr.types.generic.Column.min)\n\nReturns\n-------\nValue\n    Minimum value in the array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 2, 3], [None, 6], [None], [], None]})\n>>> t.mutate(x=t.arr.mins())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 x     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +1]       \u2502     1 \u2502\n\u2502 [None, 6]            \u2502     6 \u2502\n\u2502 [None]               \u2502  NULL \u2502\n\u2502 []                   \u2502  NULL \u2502\n\u2502 NULL                 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::maxs", "docstring": "Return the maximum value in the array.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`Column.max`](./expression-generic.qmd#ibis.expr.types.generic.Column.max)\n\nReturns\n-------\nValue\n    Maximum value in the array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 2, 3], [None, 6], [None], [], None]})\n>>> t.mutate(x=t.arr.maxs())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 x     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +1]       \u2502     3 \u2502\n\u2502 [None, 6]            \u2502     6 \u2502\n\u2502 [None]               \u2502  NULL \u2502\n\u2502 []                   \u2502  NULL \u2502\n\u2502 NULL                 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::sums", "docstring": "Return the sum of the values in the array.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`NumericColumn.sum`](./expression-numeric.qmd#ibis.expr.types.numeric.NumericColumn.sum)\n\nReturns\n-------\nValue\n    Sum of the values in the array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 2, 3], [None, 6], [None], [], None]})\n>>> t.mutate(x=t.arr.sums())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 x     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +1]       \u2502     6 \u2502\n\u2502 [None, 6]            \u2502     6 \u2502\n\u2502 [None]               \u2502  NULL \u2502\n\u2502 []                   \u2502  NULL \u2502\n\u2502 NULL                 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/arrays.py::means", "docstring": "Return the mean of the values in the array.\n\nReturns NULL if the array is empty or contains only NULLs.\n\nSee Also\n--------\n[`NumericColumn.mean`](./expression-numeric.qmd#ibis.expr.types.numeric.NumericColumn.mean)\n\nReturns\n-------\nValue\n    Mean of the values in the array\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1, 2, 3], [None, 6], [None], [], None]})\n>>> t.mutate(x=t.arr.means())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503 x       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2, ... +1]       \u2502     2.0 \u2502\n\u2502 [None, 6]            \u2502     6.0 \u2502\n\u2502 [None]               \u2502    NULL \u2502\n\u2502 []                   \u2502    NULL \u2502\n\u2502 NULL                 \u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/binary.py::hashbytes", "docstring": "Compute the binary hash value of `arg`.\n\nParameters\n----------\nhow\n    Hash algorithm to use\n\nReturns\n-------\nBinaryValue\n    Binary expression", "type": "function"}
{"source": "ibis/expr/types/maps.py::MapValue", "docstring": "A dict-like collection with fixed-type keys and values.\n\nMaps are similar to a Python dictionary, with the restriction that all keys\nmust have the same type, and all values must have the same type.\n\nThe key type and the value type can be different.\n\nFor example, keys are `string`s, and values are `int64`s.\n\nKeys are unique within a given map value.\n\nMaps can be constructed with [`ibis.map()`](#ibis.expr.types.map).\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import pyarrow as pa\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCan use `[]` to access values:\n>>> t.m[\"a\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'a', None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    1 \u2502\n\u2502                    1 \u2502\n\u2502                 NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTo provide default values, use `get`:\n>>> t.m.get(\"b\", 0)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'b', 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 2 \u2502\n\u2502                 0 \u2502\n\u2502              NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "class"}
{"source": "ibis/expr/types/maps.py::map", "docstring": "Create a MapValue.\n\nIf any of the `keys` or `values` are Columns, then the output will be a MapColumn.\nOtherwise, the output will be a MapScalar.\n\nParameters\n----------\nkeys\n    Keys of the map or `Mapping`. If `keys` is a `Mapping`, `values` must be `None`.\nvalues\n    Values of the map or `None`. If `None`, the `keys` argument must be a `Mapping`.\n\nReturns\n-------\nMapValue\n    Either a MapScalar or MapColumn, depending on the input shapes.\n\nExamples\n--------\nCreate a Map scalar from a dict with the type inferred\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.map(dict(a=1, b=2))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 {'a': 1, 'b': 2} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a Map Column from columns with keys and values\n\n>>> t = ibis.memtable({\"keys\": [[\"a\", \"b\"], [\"b\"]], \"values\": [[1, 2], [3]]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 keys                 \u2503 values               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>        \u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b']           \u2502 [1, 2]               \u2502\n\u2502 ['b']                \u2502 [3]                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.map(t.keys, t.values)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Map(keys, values)    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<string, int64>   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'b': 3}             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::get", "docstring": "Return the value for `key` from `expr`.\n\nReturn `default` if `key` is not in the map.\n\nParameters\n----------\nkey\n    Expression to use for key\ndefault\n    Expression to return if `key` is not a key in `expr`\n\nReturns\n-------\nValue\n    The element type of `self`\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow as pa\n>>> ibis.options.interactive = True\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.get(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'a', None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    1 \u2502\n\u2502                    1 \u2502\n\u2502                 NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.get(\"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'b', None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    2 \u2502\n\u2502                 NULL \u2502\n\u2502                 NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.get(\"b\", 0)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'b', 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 2 \u2502\n\u2502                 0 \u2502\n\u2502              NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::length", "docstring": "Return the number of key-value pairs in the map.\n\nReturns\n-------\nIntegerValue\n    The number of elements in `self`\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow as pa\n>>> ibis.options.interactive = True\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.length()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapLength(m) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            2 \u2502\n\u2502            1 \u2502\n\u2502         NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::__getitem__", "docstring": "Get the value for a given map `key`.\n\n::: {.callout-note}\n## This operation may have different semantics depending on the backend.\n\nSome backends return `NULL` when a key is missing, others may fail\nthe query.\n:::\n\nParameters\n----------\nkey\n    A map key\n\nReturns\n-------\nValue\n    An element with the value type of the map\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow as pa\n>>> ibis.options.interactive = True\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m[\"a\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapGet(m, 'a', None) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    1 \u2502\n\u2502                    1 \u2502\n\u2502                 NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::contains", "docstring": "Return whether the map contains `key`.\n\nParameters\n----------\nkey\n    Mapping key for which to check\n\nReturns\n-------\nBooleanValue\n    Boolean indicating the presence of `key` in the map expression\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow as pa\n>>> ibis.options.interactive = True\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.contains(\"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapContains(m, 'b') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                \u2502\n\u2502 False               \u2502\n\u2502 NULL                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::keys", "docstring": "Extract the keys of a map.\n\nReturns\n-------\nArrayValue\n    The keys of `self`\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow as pa\n>>> ibis.options.interactive = True\n>>> tab = pa.table(\n...     {\n...         \"m\": pa.array(\n...             [[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...             type=pa.map_(pa.utf8(), pa.int64()),\n...         )\n...     }\n... )\n>>> t = ibis.memtable(tab)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 m                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<!string, int64>  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 2}     \u2502\n\u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.m.keys()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 MapKeys(m)           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<!string>       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b']           \u2502\n\u2502 ['a']                \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::values", "docstring": "Extract the values of a map.\n\nReturns\n-------\nArrayValue\n    The values of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> m = ibis.map({\"a\": 1, \"b\": 2})\n>>> m.values()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [1, 2] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::__add__", "docstring": "Concatenate this map with another.\n\nParameters\n----------\nother\n    Map to concatenate with `self`\n\nReturns\n-------\nMapValue\n    `self` concatenated with `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> m1 = ibis.map({\"a\": 1, \"b\": 2})\n>>> m2 = ibis.map({\"c\": 3, \"d\": 4})\n>>> m1 + m2\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 {'a': 1, 'b': 2, ... +2} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/maps.py::__radd__", "docstring": "Concatenate this map with another.\n\nParameters\n----------\nother\n    Map to concatenate with `self`\n\nReturns\n-------\nMapValue\n    `self` concatenated with `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> m1 = ibis.map({\"a\": 1, \"b\": 2})\n>>> m2 = ibis.map({\"c\": 3, \"d\": 4})\n>>> m1 + m2\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 {'a': 1, 'b': 2, ... +2} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::_DateComponentMixin", "docstring": "Temporal expressions that have a date component.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::_TimeComponentMixin", "docstring": "Temporal expressions that have a time component.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::TimeValue", "docstring": "A time of day from 0:00:00 to 23:59:59.999999999.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::DateValue", "docstring": "A date (without time), eg 2024-12-31.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::TimestampValue", "docstring": "A date and time, eg 2024-12-31 23:59:59.999999.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::IntervalValue", "docstring": "A time duration, eg 6 day or 2 hours or 457 seconds.\n\nThis is the result from operations that compute the difference\nbetween two date or timestamp expressions, such as Timestamp.delta().\n\nThis can be combined with date or timestamp expressions\nusing addition and subtraction, eg\n`ibis.timestamp(\"2020-01-01\") + ibis.interval(days=1)`,\nwhich results in a new timestamp expression.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::DayOfWeek", "docstring": "A namespace of methods for days of the week, eg 'Monday' or 'Tuesday'.", "type": "class"}
{"source": "ibis/expr/types/temporal.py::epoch_seconds", "docstring": "Extract UNIX epoch in seconds.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).epoch_seconds()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1735603200 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::year", "docstring": "Extract the year component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).year()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2024 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::iso_year", "docstring": "Extract the ISO year component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).iso_year()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2025 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::month", "docstring": "Extract the month component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).month()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 12 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::day", "docstring": "Extract the day component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).day()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 31 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::day_of_week", "docstring": "A namespace of methods for extracting day of week information.\n\nReturns\n-------\nDayOfWeek\n    An namespace expression containing methods to use to extract\n    information.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::day_of_year", "docstring": "Extract the day of the year component.\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [\n...             date(2023, 1, 1),\n...             date(2023, 6, 17),\n...             date(2023, 12, 31),\n...             date(2024, 2, 29),\n...             date(2024, 12, 31),\n...         ]\n...     },\n... )\n>>> t.date_col.day_of_year()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ExtractDayOfYear(date_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int32                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                          1 \u2502\n\u2502                        168 \u2502\n\u2502                        365 \u2502\n\u2502                         60 \u2502\n\u2502                        366 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::quarter", "docstring": "Extract the quarter component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).quarter()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::week_of_year", "docstring": "Extract the week of the year component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.date(2024, 12, 31).week_of_year()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::time", "docstring": "Return the time component of the expression.\n\nReturns\n-------\nTimeValue\n    The time component of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(2024, 12, 31, 23, 59, 59).time()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::hour", "docstring": "Extract the hour component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(2024, 12, 31, 23, 59, 59).hour()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 23 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::minute", "docstring": "Extract the minute component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(2024, 12, 31, 23, 59, 59).minute()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::second", "docstring": "Extract the second component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(2024, 12, 31, 23, 59, 59).second()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::microsecond", "docstring": "Extract the microsecond component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(\"2024-12-31 23:59:59.999\").microsecond()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 999000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::millisecond", "docstring": "Extract the millisecond component.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.timestamp(\"2024-12-31 23:59:59.999\").millisecond()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 999 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::between", "docstring": "Check if the expr falls between `lower` and `upper`, inclusive.\n\nAdjusts according to `timezone` if provided.\n\nParameters\n----------\nlower\n    Lower bound\nupper\n    Upper bound\ntimezone\n    Time zone\n\nReturns\n-------\nBooleanValue\n    Whether `self` is between `lower` and `upper`, adjusting `timezone`\n    as needed.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lower = ibis.date(2024, 12, 30)\n>>> upper = ibis.date(2025, 1, 1)\n>>> ibis.date(2024, 12, 31).between(lower, upper)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.date(2020, 12, 31).between(lower, upper)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::strftime", "docstring": "Format a time according to `format_str`.\n\nFormat string may depend on the backend, but we try to conform to ANSI\n`strftime`.\n\nParameters\n----------\nformat_str\n    `strftime` format string\n\nReturns\n-------\nStringValue\n    Formatted version of `arg`", "type": "function"}
{"source": "ibis/expr/types/temporal.py::truncate", "docstring": "Truncate the expression to a time expression in units of `unit`.\n\nCommonly used for time series resampling.\n\nParameters\n----------\nunit\n    The unit to truncate to\n\nReturns\n-------\nTimeValue\n    `self` truncated to `unit`", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__add__", "docstring": "Add an interval to a time expression.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__sub__", "docstring": "Subtract a time or an interval from a time expression.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__rsub__", "docstring": "Subtract a time or an interval from a time expression.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::delta", "docstring": "Compute the number of `part`s between two times.\n\n::: {.callout-note}\n## The order of operands matches standard subtraction\n\nThe second argument is subtracted from the first.\n:::\n\nParameters\n----------\nother\n    A time expression\nunit\n    The unit of time to compute the difference in\n\nReturns\n-------\nIntegerValue\n    The number of `part`s between `self` and `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> start = ibis.time(\"01:58:00\")\n>>> end = ibis.time(\"23:59:59\")\n>>> end.delta(start, unit=\"hour\")\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 22 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> data = '''tpep_pickup_datetime,tpep_dropoff_datetime\n... 2016-02-01T00:23:56,2016-02-01T00:42:28\n... 2016-02-01T00:12:14,2016-02-01T00:21:41\n... 2016-02-01T00:43:24,2016-02-01T00:46:14\n... 2016-02-01T00:55:11,2016-02-01T01:24:34\n... 2016-02-01T00:11:13,2016-02-01T00:16:59'''\n>>> with open(\"/tmp/triptimes.csv\", \"w\") as f:\n...     nbytes = f.write(data)  # nbytes is unused\n>>> taxi = ibis.read_csv(\"/tmp/triptimes.csv\")\n>>> ride_duration = (\n...     taxi.tpep_dropoff_datetime.time()\n...     .delta(taxi.tpep_pickup_datetime.time(), unit=\"minute\")\n...     .name(\"ride_minutes\")\n... )\n>>> ride_duration\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ride_minutes \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           19 \u2502\n\u2502            9 \u2502\n\u2502            3 \u2502\n\u2502           29 \u2502\n\u2502            5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::strftime", "docstring": "Format a date according to `format_str`.\n\nFormat string may depend on the backend, but we try to conform to ANSI\n`strftime`.\n\nParameters\n----------\nformat_str\n    `strftime` format string\n\nReturns\n-------\nStringValue\n    Formatted version of `arg`\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [\n...             date(2020, 10, 5),\n...             date(2020, 11, 10),\n...             date(2020, 12, 15),\n...         ]\n...     },\n... )\n\nReturn a string with the year and month.\n\n>>> t.date_col.strftime(\"%Y-%m\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strftime(date_col, '%Y-%m') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10                     \u2502\n\u2502 2020-11                     \u2502\n\u2502 2020-12                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn a string with the month name, day, and year.\n\n>>> t.date_col.strftime(\"%B %-d, %Y\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strftime(date_col, '%B %-d, %Y') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 October 5, 2020                  \u2502\n\u2502 November 10, 2020                \u2502\n\u2502 December 15, 2020                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::truncate", "docstring": "Truncate date expression to units of `unit`.\n\nParameters\n----------\nunit\n    Unit to truncate `arg` to\n\nReturns\n-------\nDateValue\n    Truncated date value expression\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [\n...             date(2020, 1, 5),\n...             date(2020, 4, 10),\n...             date(2020, 7, 15),\n...             date(2020, 10, 20),\n...         ]\n...     },\n... )\n\nReturn date columns truncated to the start of the year, quarter, month, and\nweek.\n\n>>> t.select(\n...     year=t.date_col.truncate(\"Y\"),\n...     quarter=t.date_col.truncate(\"Q\"),\n...     month=t.date_col.truncate(\"M\"),\n...     week=t.date_col.truncate(\"W\"),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year       \u2503 quarter    \u2503 month      \u2503 week       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date       \u2502 date       \u2502 date       \u2502 date       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-01-01 \u2502 2020-01-01 \u2502 2020-01-01 \u2502 2019-12-30 \u2502\n\u2502 2020-01-01 \u2502 2020-04-01 \u2502 2020-04-01 \u2502 2020-04-06 \u2502\n\u2502 2020-01-01 \u2502 2020-07-01 \u2502 2020-07-01 \u2502 2020-07-13 \u2502\n\u2502 2020-01-01 \u2502 2020-10-01 \u2502 2020-10-01 \u2502 2020-10-19 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__add__", "docstring": "Add an interval to a date.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__sub__", "docstring": "Subtract a date or an interval from a date.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__rsub__", "docstring": "Subtract a date or an interval from a date.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::delta", "docstring": "Compute the number of `part`s between two dates.\n\n::: {.callout-note}\n## The order of operands matches standard subtraction\n\nThe second argument is subtracted from the first.\n:::\n\nParameters\n----------\nother\n    A date expression\nunit\n    The unit of time to compute the difference in\n\nReturns\n-------\nIntegerValue\n    The number of `part`s between `self` and `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> start = ibis.date(\"1992-09-30\")\n>>> end = ibis.date(\"1992-10-01\")\n>>> end.delta(start, unit=\"day\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> prez = ibis.examples.presidential.fetch()\n>>> prez.mutate(\n...     years_in_office=prez.end.delta(prez.start, unit=\"year\"),\n...     hours_in_office=prez.end.delta(prez.start, unit=\"hour\"),\n... ).drop(\"party\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name       \u2503 start      \u2503 end        \u2503 years_in_office \u2503 hours_in_office \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502 date       \u2502 date       \u2502 int64           \u2502 int64           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Eisenhower \u2502 1953-01-20 \u2502 1961-01-20 \u2502               8 \u2502           70128 \u2502\n\u2502 Kennedy    \u2502 1961-01-20 \u2502 1963-11-22 \u2502               2 \u2502           24864 \u2502\n\u2502 Johnson    \u2502 1963-11-22 \u2502 1969-01-20 \u2502               6 \u2502           45264 \u2502\n\u2502 Nixon      \u2502 1969-01-20 \u2502 1974-08-09 \u2502               5 \u2502           48648 \u2502\n\u2502 Ford       \u2502 1974-08-09 \u2502 1977-01-20 \u2502               3 \u2502           21480 \u2502\n\u2502 Carter     \u2502 1977-01-20 \u2502 1981-01-20 \u2502               4 \u2502           35064 \u2502\n\u2502 Reagan     \u2502 1981-01-20 \u2502 1989-01-20 \u2502               8 \u2502           70128 \u2502\n\u2502 Bush       \u2502 1989-01-20 \u2502 1993-01-20 \u2502               4 \u2502           35064 \u2502\n\u2502 Clinton    \u2502 1993-01-20 \u2502 2001-01-20 \u2502               8 \u2502           70128 \u2502\n\u2502 Bush       \u2502 2001-01-20 \u2502 2009-01-20 \u2502               8 \u2502           70128 \u2502\n\u2502 \u2026          \u2502 \u2026          \u2502 \u2026          \u2502               \u2026 \u2502               \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::epoch_days", "docstring": "Return the number of days since the UNIX epoch date.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> date = ibis.date(2020, 1, 1)\n>>> date\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2020-01-01 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> date.epoch_days()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 18262 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t = date.name(\"date_col\").as_table()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 date_col   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-01-01 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(epoch=t.date_col.epoch_days())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 date_col   \u2503 epoch \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date       \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-01-01 \u2502 18262 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::strftime", "docstring": "Format a timestamp according to `format_str`.\n\nFormat string may depend on the backend, but we try to conform to ANSI\n`strftime`.\n\nParameters\n----------\nformat_str\n    `strftime` format string\n\nReturns\n-------\nStringValue\n    Formatted version of `arg`\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"timestamp_col\": [\n...             datetime(2020, 10, 5, 8, 0, 0),\n...             datetime(2020, 11, 10, 10, 2, 15),\n...             datetime(2020, 12, 15, 12, 4, 30),\n...         ]\n...     },\n... )\n\nReturn a string with the year and month.\n\n>>> t.timestamp_col.strftime(\"%Y-%m\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strftime(timestamp_col, '%Y-%m') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10                          \u2502\n\u2502 2020-11                          \u2502\n\u2502 2020-12                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn a string with the month, day, and year.\n\n>>> t.timestamp_col.strftime(\"%B %-d, %Y\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strftime(timestamp_col, '%B %-d, %Y') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 October 5, 2020                       \u2502\n\u2502 November 10, 2020                     \u2502\n\u2502 December 15, 2020                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn a string with the month, day, year, hour, minute, and AM/PM.\n\n>>> t.timestamp_col.strftime(\"%B %-d, %Y at %I:%M %p\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strftime(timestamp_col, '%B %-d, %Y at %I:%M %p') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 October 5, 2020 at 08:00 AM                       \u2502\n\u2502 November 10, 2020 at 10:02 AM                     \u2502\n\u2502 December 15, 2020 at 12:04 PM                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::truncate", "docstring": "Truncate timestamp expression to units of `unit`.\n\nParameters\n----------\nunit\n    Unit to truncate to\n\nReturns\n-------\nTimestampValue\n    Truncated timestamp expression\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"timestamp_col\": [\n...             datetime(2020, 1, 5, 8, 0, 0),\n...             datetime(2020, 4, 10, 10, 2, 15),\n...             datetime(2020, 7, 15, 12, 4, 30),\n...             datetime(2020, 10, 20, 14, 6, 45),\n...         ]\n...     },\n... )\n\nReturn timestamp columns truncated to the start of the year, quarter, and month.\n\n>>> t.select(\n...     year=t.timestamp_col.truncate(\"Y\"),\n...     quarter=t.timestamp_col.truncate(\"Q\"),\n...     month=t.timestamp_col.truncate(\"M\"),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year                \u2503 quarter             \u2503 month               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-01-01 00:00:00 \u2502 2020-01-01 00:00:00 \u2502 2020-01-01 00:00:00 \u2502\n\u2502 2020-01-01 00:00:00 \u2502 2020-04-01 00:00:00 \u2502 2020-04-01 00:00:00 \u2502\n\u2502 2020-01-01 00:00:00 \u2502 2020-07-01 00:00:00 \u2502 2020-07-01 00:00:00 \u2502\n\u2502 2020-01-01 00:00:00 \u2502 2020-10-01 00:00:00 \u2502 2020-10-01 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn timestamp columns truncated to the start of the week and day.\n\n>>> t.select(week=t.timestamp_col.truncate(\"W\"), day=t.timestamp_col.truncate(\"D\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 week                \u2503 day                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2019-12-30 00:00:00 \u2502 2020-01-05 00:00:00 \u2502\n\u2502 2020-04-06 00:00:00 \u2502 2020-04-10 00:00:00 \u2502\n\u2502 2020-07-13 00:00:00 \u2502 2020-07-15 00:00:00 \u2502\n\u2502 2020-10-19 00:00:00 \u2502 2020-10-20 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn timestamp columns truncated to the start of the hour, minute, and\nsecond.\n\n>>> t.select(\n...     hour=t.timestamp_col.truncate(\"h\"),\n...     minute=t.timestamp_col.truncate(\"m\"),\n...     second=t.timestamp_col.truncate(\"s\"),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 hour                \u2503 minute              \u2503 second              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-01-05 08:00:00 \u2502 2020-01-05 08:00:00 \u2502 2020-01-05 08:00:00 \u2502\n\u2502 2020-04-10 10:00:00 \u2502 2020-04-10 10:02:00 \u2502 2020-04-10 10:02:15 \u2502\n\u2502 2020-07-15 12:00:00 \u2502 2020-07-15 12:04:00 \u2502 2020-07-15 12:04:30 \u2502\n\u2502 2020-10-20 14:00:00 \u2502 2020-10-20 14:06:00 \u2502 2020-10-20 14:06:45 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::bucket", "docstring": "Truncate the timestamp to buckets of a specified interval.\n\nThis is similar to `truncate`, but supports truncating to arbitrary\nintervals rather than a single unit. Buckets are computed as fixed\nintervals starting from the UNIX epoch. This origin may be offset by\nspecifying `offset`.\n\nParameters\n----------\ninterval\n    The bucket width as an interval. Alternatively may be specified\n    via component keyword arguments.\nyears\n    Number of years\nquarters\n    Number of quarters\nmonths\n    Number of months\nweeks\n    Number of weeks\ndays\n    Number of days\nhours\n    Number of hours\nminutes\n    Number of minutes\nseconds\n    Number of seconds\nmilliseconds\n    Number of milliseconds\nmicroseconds\n    Number of microseconds\nnanoseconds\n    Number of nanoseconds\noffset\n    An interval to use to offset the start of the bucket.\n\nReturns\n-------\nTimestampValue\n    The start of the bucket as a timestamp.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     [\n...         (\"2020-04-15 08:04:00\", 1),\n...         (\"2020-04-15 08:06:00\", 2),\n...         (\"2020-04-15 08:09:00\", 3),\n...         (\"2020-04-15 08:11:00\", 4),\n...     ],\n...     columns=[\"ts\", \"val\"],\n... ).cast({\"ts\": \"timestamp\"})\n\nBucket the data into 5 minute wide buckets:\n\n>>> t.ts.bucket(minutes=5)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 TimestampBucket(ts, 5m) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-04-15 08:00:00     \u2502\n\u2502 2020-04-15 08:05:00     \u2502\n\u2502 2020-04-15 08:05:00     \u2502\n\u2502 2020-04-15 08:10:00     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nBucket the data into 5 minute wide buckets, offset by 2 minutes:\n\n>>> t.ts.bucket(minutes=5, offset=ibis.interval(minutes=2))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 TimestampBucket(ts, 5m, 2m) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-04-15 08:02:00         \u2502\n\u2502 2020-04-15 08:02:00         \u2502\n\u2502 2020-04-15 08:07:00         \u2502\n\u2502 2020-04-15 08:07:00         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nOne common use of timestamp bucketing is computing statistics per\nbucket. Here we compute the mean of `val` across 5 minute intervals:\n\n>>> mean_by_bucket = (\n...     t.group_by(t.ts.bucket(minutes=5).name(\"bucket\"))\n...     .agg(mean=_.val.mean())\n...     .order_by(\"bucket\")\n... )\n>>> mean_by_bucket\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bucket              \u2503 mean    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-04-15 08:00:00 \u2502     1.0 \u2502\n\u2502 2020-04-15 08:05:00 \u2502     2.5 \u2502\n\u2502 2020-04-15 08:10:00 \u2502     4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::date", "docstring": "Return the date component of the expression.\n\nReturns\n-------\nDateValue\n    The date component of `self`", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__add__", "docstring": "Add an interval to a timestamp.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__sub__", "docstring": "Subtract a timestamp or an interval from a timestamp.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__rsub__", "docstring": "Subtract a timestamp or an interval from a timestamp.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::delta", "docstring": "Compute the number of `part`s between two timestamps.\n\n::: {.callout-note}\n## The order of operands matches standard subtraction\n\nThe second argument is subtracted from the first.\n:::\n\nParameters\n----------\nother\n    A timestamp expression\nunit\n    The unit of time to compute the difference in\n\nReturns\n-------\nIntegerValue\n    The number of `part`s between `self` and `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> start = ibis.time(\"01:58:00\")\n>>> end = ibis.time(\"23:59:59\")\n>>> end.delta(start, unit=\"hour\")\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 22 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> data = '''tpep_pickup_datetime,tpep_dropoff_datetime\n... 2016-02-01T00:23:56,2016-02-01T00:42:28\n... 2016-02-01T00:12:14,2016-02-01T00:21:41\n... 2016-02-01T00:43:24,2016-02-01T00:46:14\n... 2016-02-01T00:55:11,2016-02-01T01:24:34\n... 2016-02-01T00:11:13,2016-02-01T00:16:59'''\n>>> with open(\"/tmp/triptimes.csv\", \"w\") as f:\n...     nbytes = f.write(data)  # nbytes is unused\n>>> taxi = ibis.read_csv(\"/tmp/triptimes.csv\")\n>>> ride_duration = taxi.tpep_dropoff_datetime.delta(\n...     taxi.tpep_pickup_datetime, unit=\"minute\"\n... ).name(\"ride_minutes\")\n>>> ride_duration\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ride_minutes \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           19 \u2502\n\u2502            9 \u2502\n\u2502            3 \u2502\n\u2502           29 \u2502\n\u2502            5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::as_unit", "docstring": "Convert this interval to units of `target_unit`.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::years", "docstring": "The number of years (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::quarters", "docstring": "The number of quarters (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::months", "docstring": "The number of months (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::weeks", "docstring": "The number of weeks (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::days", "docstring": "The number of days (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::hours", "docstring": "The number of hours (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::minutes", "docstring": "The number of minutes (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::seconds", "docstring": "The number of seconds (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::milliseconds", "docstring": "The number of milliseconds (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::microseconds", "docstring": "The number of microseconds (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::nanoseconds", "docstring": "The number of nanoseconds (IntegerValue).", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__add__", "docstring": "Add this interval to `other`.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__sub__", "docstring": "Subtract `other` from this interval.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__rsub__", "docstring": "Subtract `other` from this interval.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__mul__", "docstring": "Multiply this interval by `other`.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::__floordiv__", "docstring": "Floor-divide this interval by `other`.", "type": "function"}
{"source": "ibis/expr/types/temporal.py::negate", "docstring": "Negate an interval expression.\n\nReturns\n-------\nIntervalValue\n    A negated interval value expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nNegate a positive interval of one day to subtract a day from a specific date.\n>>> ibis.date(2024, 11, 1) + ibis.interval(days=1).negate()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2024-10-31 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nNegate a negative interval of one day to add a day to a specific date.\n>>> ibis.date(2024, 11, 1) + ibis.interval(days=-1).negate()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2024-11-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::index", "docstring": "Get the index of the day of the week.\n\n::: {.callout-note}\n## Ibis follows the `pandas` convention for day numbering: Monday = 0 and Sunday = 6.\n:::\n\nReturns\n-------\nIntegerValue\n    The index of the day of the week.\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [\n...             date(2024, 10, 27),\n...             date(2024, 10, 28),\n...             date(2024, 10, 29),\n...             date(2024, 10, 30),\n...             date(2024, 10, 31),\n...             date(2024, 11, 1),\n...             date(2024, 11, 2),\n...         ]\n...     },\n... )\n>>> t.date_col.day_of_week.index()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 DayOfWeekIndex(date_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int16                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                        6 \u2502\n\u2502                        0 \u2502\n\u2502                        1 \u2502\n\u2502                        2 \u2502\n\u2502                        3 \u2502\n\u2502                        4 \u2502\n\u2502                        5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal.py::full_name", "docstring": "Get the name of the day of the week, eg 'Monday' or 'Tuesday'.\n\nReturns\n-------\nStringValue\n    The name of the day of the week\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [\n...             date(2024, 10, 27),\n...             date(2024, 10, 28),\n...             date(2024, 10, 29),\n...             date(2024, 10, 30),\n...             date(2024, 10, 31),\n...             date(2024, 11, 1),\n...             date(2024, 11, 2),\n...         ]\n...     },\n... )\n>>> t.date_col.day_of_week.full_name()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 DayOfWeekName(date_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Sunday                  \u2502\n\u2502 Monday                  \u2502\n\u2502 Tuesday                 \u2502\n\u2502 Wednesday               \u2502\n\u2502 Thursday                \u2502\n\u2502 Friday                  \u2502\n\u2502 Saturday                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::ifelse", "docstring": "Construct a ternary conditional expression.\n\nParameters\n----------\ntrue_expr\n    Expression to return if `self` evaluates to `True`\nfalse_expr\n    Expression to return if `self` evaluates to `False` or `NULL`\n\nReturns\n-------\nValue\n    The value of `true_expr` if `arg` is `True` else `false_expr`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"is_person\": [True, False, True, None]})\n>>> t.is_person.ifelse(\"yes\", \"no\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 IfElse(is_person, 'yes', 'no') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::__and__", "docstring": "Construct a binary AND conditional expression with `self` and `other`.\n\nParameters\n----------\nself\n    Left operand\nother\n    Right operand\n\nReturns\n-------\nBooleanValue\n    A Boolean expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[1], [], [42, 42], None]})\n>>> t.arr.contains(42) & (t.arr.contains(1))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 And(ArrayContains(arr, 42), ArrayContains(arr, 1)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                              \u2502\n\u2502 False                                              \u2502\n\u2502 False                                              \u2502\n\u2502 NULL                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.arr.contains(42) & (t.arr.contains(42))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 And(ArrayContains(arr, 42), ArrayContains(arr, 42)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                               \u2502\n\u2502 False                                               \u2502\n\u2502 True                                                \u2502\n\u2502 NULL                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::__or__", "docstring": "Construct a binary OR conditional expression with `self` and `other`.\n\nParameters\n----------\nself\n    Left operand\nother\n    Right operand\n\nReturns\n-------\nBooleanValue\n    A Boolean expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, None]})\n>>> (t.arr > 1) | (t.arr > 2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Or(Greater(arr, 1), Greater(arr, 2)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                \u2502\n\u2502 True                                 \u2502\n\u2502 True                                 \u2502\n\u2502 NULL                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::__xor__", "docstring": "Construct a binary XOR conditional expression with `self` and `other`.\n\nParameters\n----------\nself\n    Left operand\nother\n    Right operand\n\nReturns\n-------\nBooleanValue\n    A Boolean expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, None]})\n>>> t.arr == 2\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Equals(arr, 2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False          \u2502\n\u2502 True           \u2502\n\u2502 False          \u2502\n\u2502 NULL           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> (t.arr > 2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Greater(arr, 2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False           \u2502\n\u2502 False           \u2502\n\u2502 True            \u2502\n\u2502 NULL            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> (t.arr == 2) ^ (t.arr > 2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Xor(Equals(arr, 2), Greater(arr, 2)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                \u2502\n\u2502 True                                 \u2502\n\u2502 True                                 \u2502\n\u2502 NULL                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::__invert__", "docstring": "Construct a unary NOT conditional expression with `self`.\n\nParameters\n----------\nself\n    Operand\n\nReturns\n-------\nBooleanValue\n    A Boolean expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [True, False, False, None]})\n>>> ~t.arr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Not(arr) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False    \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 NULL     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::negate", "docstring": "DEPRECATED.", "type": "function"}
{"source": "ibis/expr/types/logical.py::any", "docstring": "Return whether at least one element is `True`.\n\nIf the expression does not reference any foreign tables, the result\nwill be a scalar reduction, otherwise it will be a deferred expression\nconstructing an exists subquery when passed to a table method.\n\nParameters\n----------\nwhere\n    Optional filter for the aggregation\n\nReturns\n-------\nBooleanValue\n    Whether at least one element is `True`.\n\nNotes\n-----\nConsider the following ibis expressions\n\n```python\nimport ibis\n\nt = ibis.table(dict(a=\"string\"))\ns = ibis.table(dict(a=\"string\"))\n\ncond = (t.a == s.a).any()\n```\n\nWithout knowing the table to use as the outer query there are two ways to\nturn this expression into a SQL `EXISTS` predicate, depending on which of\n`t` or `s` is filtered on.\n\nFiltering from `t`:\n\n```sql\nSELECT *\nFROM t\nWHERE EXISTS (SELECT 1 FROM s WHERE t.a = s.a)\n```\n\nFiltering from `s`:\n\n```sql\nSELECT *\nFROM s\nWHERE EXISTS (SELECT 1 FROM t WHERE t.a = s.a)\n```\n\nNotably the correlated subquery cannot stand on its own.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, None]})\n>>> (t.arr > 2).any()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr > 4).any()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr == None).any(where=t.arr != None)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::notany", "docstring": "Return whether no elements are `True`.\n\nParameters\n----------\nwhere\n    Optional filter for the aggregation\n\nReturns\n-------\nBooleanValue\n    Whether no elements are `True`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, 4]})\n>>> (t.arr > 1).notany()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr > 4).notany()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> m = ibis.memtable({\"arr\": [True, True, True, False]})\n>>> (t.arr == None).notany(where=t.arr != None)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::all", "docstring": "Return whether all elements are `True`.\n\nParameters\n----------\nwhere\n    Optional filter for the aggregation\n\nReturns\n-------\nBooleanValue\n    Whether all elements are `True`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, 4]})\n>>> (t.arr >= 1).all()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr > 2).all()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr == 2).all(where=t.arr == 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr == 2).all(where=t.arr >= 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::notall", "docstring": "Return whether not all elements are `True`.\n\nParameters\n----------\nwhere\n    Optional filter for the aggregation\n\nReturns\n-------\nBooleanValue\n    Whether not all elements are `True`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, 4]})\n>>> (t.arr >= 1).notall()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr > 2).notall()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr == 2).notall(where=t.arr == 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 False \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> (t.arr == 2).notall(where=t.arr >= 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::cumany", "docstring": "Accumulate the `any` aggregate.\n\nReturns\n-------\nBooleanColumn\n    A boolean column with the cumulative `any` aggregate.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, 4]})\n>>> ((t.arr > 1) | (t.arr >= 1)).cumany()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Any(Or(Greater(arr, 1), GreaterEqual(arr, 1))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                                           \u2502\n\u2502 True                                           \u2502\n\u2502 True                                           \u2502\n\u2502 True                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ((t.arr > 1) & (t.arr >= 1)).cumany()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Any(And(Greater(arr, 1), GreaterEqual(arr, 1))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                           \u2502\n\u2502 True                                            \u2502\n\u2502 True                                            \u2502\n\u2502 True                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::cumall", "docstring": "Accumulate the `all` aggregate.\n\nReturns\n-------\nBooleanColumn\n    A boolean column with the cumulative `all` aggregate.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [1, 2, 3, 4]})\n>>> ((t.arr > 1) & (t.arr >= 1)).cumall()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 All(And(Greater(arr, 1), GreaterEqual(arr, 1))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                                           \u2502\n\u2502 False                                           \u2502\n\u2502 False                                           \u2502\n\u2502 False                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ((t.arr > 0) & (t.arr >= 1)).cumall()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 All(And(Greater(arr, 0), GreaterEqual(arr, 1))) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                                            \u2502\n\u2502 True                                            \u2502\n\u2502 True                                            \u2502\n\u2502 True                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/logical.py::resolve_exists_subquery", "docstring": "An exists subquery whose outer leaf table is unknown.", "type": "function"}
{"source": "ibis/expr/types/joins.py::disambiguate_fields", "docstring": "Resolve name collisions between the left and right tables.", "type": "function"}
{"source": "ibis/expr/types/joins.py::prepare_predicates", "docstring": "Bind and dereference predicates to the left and right tables.\n\nThe responsibility of this function is twofold:\n1. Convert the various input values to valid predicates, including binding.\n2. Dereference the predicates one of the ops.JoinTable(s) in the join chain\n   or the new JoinTable wrapping the right table. JoinTable(s) are used to\n   ensure that all join participants are unique, even if the same table is\n   joined multiple times.\n\nSince join predicates can be ambiguous sometimes, we do the two steps above\nin the same time so that we have more contextual information to resolve\nambiguities.\n\nPossible inputs for the predicates:\n1. A python boolean literal, which is converted to a literal expression\n2. A boolean `Value` expression, which gets flattened and dereferenced.\n   If there are comparison expressions where both sides depend on the same\n   relation, then the left side is dereferenced to one of the join tables\n   already part of the join chain, while the right side is dereferenced to\n   the new join table wrapping the right table.\n3. A `Deferred` expression, which gets resolved on the left table and then\n   the same path is followed as for `Value` expressions.\n4. A pair of expression-like objects, which are getting bound to the left\n   and right tables respectively using the robust `bind` function handling\n   several cases, including `Deferred` expressions, `Selector`s, literals,\n   etc. Then the left are dereferenced to the join chain whereas the right\n   to the new join table wrapping the right table.\n\nParameters\n----------\nchain\n    The join chain\nright\n    The right table\npredicates\n    Predicates to bind and dereference, see the possible values above\ncomparison\n    The comparison operation to construct if the input is a pair of\n    expression-like objects", "type": "function"}
{"source": "ibis/expr/types/joins.py::finished", "docstring": "Decorator to ensure the join chain is finished before calling a method.", "type": "function"}
{"source": "ibis/expr/types/joins.py::_finish", "docstring": "Construct a valid table expression from this join expression.", "type": "function"}
{"source": "ibis/expr/types/relations.py::bind", "docstring": "Bind a value to a table expression.", "type": "function"}
{"source": "ibis/expr/types/relations.py::unwrap_alias", "docstring": "Unwrap an alias node.", "type": "function"}
{"source": "ibis/expr/types/relations.py::unwrap_aliases", "docstring": "Unwrap aliases into a mapping of {name: expression}.", "type": "function"}
{"source": "ibis/expr/types/relations.py::Table", "docstring": "An immutable and lazy dataframe.\n\nAnalogous to a SQL table or a pandas DataFrame. A table expression contains\nan [ordered set of named columns](./schemas.qmd#ibis.expr.schema.Schema),\neach with a single known type. Unless explicitly ordered with an\n[`.order_by()`](./expression-tables.qmd#ibis.expr.types.relations.Table.order_by),\nthe order of rows is undefined.\n\nTable immutability means that the data underlying an Ibis `Table` cannot be modified: every\nmethod on a Table returns a new Table with those changes. Laziness\nmeans that an Ibis `Table` expression does not run your computation every time you call one of its methods.\nInstead, it is a symbolic expression that represents a set of operations\nto be performed, which typically is translated into a SQL query. That\nSQL query is then executed on a backend, where the data actually lives.\nThe result (now small enough to be manageable) can then be materialized back\ninto python as a pandas/pyarrow/python DataFrame/Column/scalar.\n\nYou will not create Table objects directly. Instead, you will create one\n\n- from a pandas DataFrame, pyarrow table, Polars table, or raw python dicts/lists\n  with [`ibis.memtable(df)`](./expression-tables.qmd#ibis.memtable)\n- from an existing table in a data platform with\n  [`connection.table(\"name\")`](./expression-tables.qmd#ibis.backends.duckdb.Backend.table)\n- from a file or URL, into a specific backend with\n  [`connection.read_csv/parquet/json(\"path/to/file\")`](../backends/duckdb.qmd#ibis.backends.duckdb.Backend.read_csv)\n  (only some backends, typically local ones, support this)\n- from a file or URL, into the default backend with\n   [`ibis.read_csv/read_json/read_parquet(\"path/to/file\")`](./expression-tables.qmd#ibis.read_csv)\n\nSee the [user guide](https://ibis-project.org/how-to/input-output/basics) for more\ninfo.", "type": "class"}
{"source": "ibis/expr/types/relations.py::get_name", "docstring": "Return the fully qualified name of the table.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.duckdb.connect()\n>>> t = con.create_table(\"t\", {\"id\": [1, 2, 3]})\n>>> t.get_name()\n'memory.main.t'", "type": "function"}
{"source": "ibis/expr/types/relations.py::bind", "docstring": "Bind column values to a table expression.\n\nThis method handles the binding of every kind of column-like value that\nIbis handles, including strings, integers, deferred expressions and\nselectors, to a table expression.\n\nParameters\n----------\nargs\n    Column-like values to bind.\nkwargs\n    Column-like values to bind, with names.\n\nReturns\n-------\ntuple[Value, ...]\n    A tuple of bound values", "type": "function"}
{"source": "ibis/expr/types/relations.py::as_scalar", "docstring": "Inform ibis that the table expression should be treated as a scalar.\n\nNote that the table must have exactly one column and one row for this to\nwork. If the table has more than one column an error will be raised in\nexpression construction time. If the table has more than one row an\nerror will be raised by the backend when the expression is executed.\n\nReturns\n-------\nScalar\n    A scalar subquery\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> heavy_gentoo = t.filter(t.species == \"Gentoo\", t.body_mass_g > 6200)\n>>> from_that_island = t.filter(t.island == heavy_gentoo.select(\"island\").as_scalar())\n>>> from_that_island.species.value_counts().order_by(\"species\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 species_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502            44 \u2502\n\u2502 Gentoo  \u2502           124 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::as_table", "docstring": "Promote the expression to a table.\n\nThis method is a no-op for table expressions.\n\nReturns\n-------\nTable\n    A table expression\n\nExamples\n--------\n>>> t = ibis.table(dict(a=\"int\"), name=\"t\")\n>>> s = t.as_table()\n>>> t is s\nTrue", "type": "function"}
{"source": "ibis/expr/types/relations.py::__contains__", "docstring": "Return whether `name` is a column in the table.\n\nParameters\n----------\nname\n    Possible column name\n\nReturns\n-------\nbool\n    Whether `name` is a column in `self`\n\nExamples\n--------\n>>> t = ibis.table(dict(a=\"string\", b=\"float\"), name=\"t\")\n>>> \"a\" in t\nTrue\n>>> \"c\" in t\nFalse", "type": "function"}
{"source": "ibis/expr/types/relations.py::cast", "docstring": "Cast the columns of a table.\n\nSimilar to `pandas.DataFrame.astype`.\n\n::: {.callout-note}\n## If you need to cast columns to a single type, use [selectors](./selectors.qmd).\n:::\n\nParameters\n----------\nschema\n    Mapping, schema or iterable of pairs to use for casting\n\nReturns\n-------\nTable\n    Casted table\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.schema()\nibis.Schema {\n  species            string\n  island             string\n  bill_length_mm     float64\n  bill_depth_mm      float64\n  flipper_length_mm  int64\n  body_mass_g        int64\n  sex                string\n  year               int64\n}\n>>> cols = [\"body_mass_g\", \"bill_length_mm\"]\n>>> t[cols].head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 body_mass_g \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        3750 \u2502           39.1 \u2502\n\u2502        3800 \u2502           39.5 \u2502\n\u2502        3250 \u2502           40.3 \u2502\n\u2502        NULL \u2502           NULL \u2502\n\u2502        3450 \u2502           36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nColumns not present in the input schema will be passed through unchanged\n\n>>> t.columns\n('species', 'island', 'bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g', 'sex', 'year')\n>>> expr = t.cast({\"body_mass_g\": \"float64\", \"bill_length_mm\": \"int\"})\n>>> expr.select(*cols).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 body_mass_g \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502 int64          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      3750.0 \u2502             39 \u2502\n\u2502      3800.0 \u2502             40 \u2502\n\u2502      3250.0 \u2502             40 \u2502\n\u2502        NULL \u2502           NULL \u2502\n\u2502      3450.0 \u2502             37 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nColumns that are in the input `schema` but not in the table raise an error\n\n>>> t.cast({\"foo\": \"string\"})  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n    ...\nibis.common.exceptions.IbisError: Cast schema has fields that are not in the table: ['foo']", "type": "function"}
{"source": "ibis/expr/types/relations.py::try_cast", "docstring": "Cast the columns of a table.\n\nIf the cast fails for a row, the value is returned\nas `NULL` or `NaN` depending on backend behavior.\n\nParameters\n----------\nschema\n    Mapping, schema or iterable of pairs to use for casting\n\nReturns\n-------\nTable\n    Casted table\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"2.2\", \"3.3\", \"book\"]})\n>>> t.try_cast({\"a\": \"int\", \"b\": \"float\"})\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     2.2 \u2502\n\u2502     2 \u2502     3.3 \u2502\n\u2502     3 \u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::preview", "docstring": "Return a subset as a Rich Table.\n\nThis is an explicit version of what you get when you inspect\nthis object in interactive mode, except with this version you\ncan pass formatting options. The options are the same as those exposed\nin `ibis.options.interactive`.\n\nParameters\n----------\nmax_rows\n    Maximum number of rows to display\nmax_columns\n    Maximum number of columns to display\nmax_length\n    Maximum length for pretty-printed arrays and maps\nmax_string\n    Maximum length for pretty-printed strings\nmax_depth\n    Maximum depth for nested data types\nconsole_width\n    Width of the console in characters. If not specified, the width\n    will be inferred from the console.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.examples.penguins.fetch()\n\nBecause the console_width is too small, only 2 columns are shown even though\nwe specified up to 3.\n\n>>> t.preview(\n...     max_rows=3,\n...     max_columns=3,\n...     max_string=8,\n...     console_width=30,\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island   \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string   \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgers\u2026 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgers\u2026 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgers\u2026 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026        \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::__getitem__", "docstring": "Select one or more columns or rows from a table expression.\n\nParameters\n----------\nwhat\n    What to select. Options are:\n    - A `str` column name or `int` column index to select a single column.\n    - A sequence of column names or indices to select multiple columns.\n    - A slice to select a subset of rows.\n\nReturns\n-------\nTable | Column\n    The return type depends on the input. For a single string or int\n    input a column is returned, otherwise a table is returned.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().head()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nSelect a single column by name:\n\n>>> t[\"island\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSelect a single column by index:\n\n>>> t.columns[1]\n'island'\n>>> t[1]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSelect multiple columns by name:\n\n>>> t[[\"island\", \"bill_length_mm\"]]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502           39.1 \u2502\n\u2502 Torgersen \u2502           39.5 \u2502\n\u2502 Torgersen \u2502           40.3 \u2502\n\u2502 Torgersen \u2502           NULL \u2502\n\u2502 Torgersen \u2502           36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSelect a range of rows:\n\n>>> t[:2]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t[2:5]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::__getattr__", "docstring": "Return the column name of a table.\n\nParameters\n----------\nkey\n    Column name\n\nReturns\n-------\nColumn\n    Column expression with name `key`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.island\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 Torgersen \u2502\n\u2502 \u2026         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::columns", "docstring": "Return a [](`tuple`) of column names in this table.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.columns\n('species',\n 'island',\n 'bill_length_mm',\n 'bill_depth_mm',\n 'flipper_length_mm',\n 'body_mass_g',\n 'sex',\n 'year')", "type": "function"}
{"source": "ibis/expr/types/relations.py::schema", "docstring": "Return the [Schema](./schemas.qmd#ibis.expr.schema.Schema) for this table.\n\nReturns\n-------\nSchema\n    The table's schema.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.schema()\nibis.Schema {\n  species            string\n  island             string\n  bill_length_mm     float64\n  bill_depth_mm      float64\n  flipper_length_mm  int64\n  body_mass_g        int64\n  sex                string\n  year               int64\n}", "type": "function"}
{"source": "ibis/expr/types/relations.py::group_by", "docstring": "Create a grouped table expression.\n\nSimilar to SQL's GROUP BY statement, or pandas .groupby() method.\n\nParameters\n----------\nby\n    Grouping expressions\nkey_exprs\n    Named grouping expressions\n\nReturns\n-------\nGroupedTable\n    A grouped table expression\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"fruit\": [\"apple\", \"apple\", \"banana\", \"orange\"],\n...         \"price\": [0.5, 0.5, 0.25, 0.33],\n...     }\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 fruit  \u2503 price   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 apple  \u2502    0.50 \u2502\n\u2502 apple  \u2502    0.50 \u2502\n\u2502 banana \u2502    0.25 \u2502\n\u2502 orange \u2502    0.33 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.group_by(\"fruit\").agg(total_cost=_.price.sum(), avg_cost=_.price.mean()).order_by(\n...     \"fruit\"\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 fruit  \u2503 total_cost \u2503 avg_cost \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64    \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 apple  \u2502       1.00 \u2502     0.50 \u2502\n\u2502 banana \u2502       0.25 \u2502     0.25 \u2502\n\u2502 orange \u2502       0.33 \u2502     0.33 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::rowid", "docstring": "A unique integer per row.\n\n::: {.callout-note}\n## This operation is only valid on physical tables\n\nAny further meaning behind this expression is backend dependent.\nGenerally this corresponds to some index into the database storage\n(for example, SQLite and DuckDB's `rowid`).\n\nFor a monotonically increasing row number, see `ibis.row_number`.\n:::\n\nReturns\n-------\nIntegerColumn\n    An integer column", "type": "function"}
{"source": "ibis/expr/types/relations.py::view", "docstring": "Create a new table expression distinct from the current one.\n\nUse this API for any self-referencing operations like a self-join.\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/expr/types/relations.py::aggregate", "docstring": "Aggregate a table with a given set of reductions grouping by `by`.\n\nParameters\n----------\nmetrics\n    Aggregate expressions. These can be any scalar-producing\n    expression, including aggregation functions like `sum` or literal\n    values like `ibis.literal(1)`.\nby\n    Grouping expressions.\nhaving\n    Post-aggregation filters. The shape requirements are the same\n    `metrics`, but the output type for `having` is `boolean`.\n\n    ::: {.callout-warning}\n    ## Expressions like `x is None` return `bool` and **will not** generate a SQL comparison to `NULL`\n    :::\nkwargs\n    Named aggregate expressions\n\nReturns\n-------\nTable\n    An aggregate table expression\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"fruit\": [\"apple\", \"apple\", \"banana\", \"orange\"],\n...         \"price\": [0.5, 0.5, 0.25, 0.33],\n...     }\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 fruit  \u2503 price   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 apple  \u2502    0.50 \u2502\n\u2502 apple  \u2502    0.50 \u2502\n\u2502 banana \u2502    0.25 \u2502\n\u2502 orange \u2502    0.33 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.aggregate(\n...     by=[\"fruit\"],\n...     total_cost=_.price.sum(),\n...     avg_cost=_.price.mean(),\n...     having=_.price.sum() < 0.5,\n... ).order_by(\"fruit\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 fruit  \u2503 total_cost \u2503 avg_cost \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64    \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 banana \u2502       0.25 \u2502     0.25 \u2502\n\u2502 orange \u2502       0.33 \u2502     0.33 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::distinct", "docstring": "Return a Table with duplicate rows removed.\n\nSimilar to `pandas.DataFrame.drop_duplicates()`.\n\n::: {.callout-note}\n## Some backends do not support `keep='last'`\n:::\n\nParameters\n----------\non\n    Only consider certain columns for identifying duplicates.\n    By default deduplicate all of the columns.\nkeep\n    Determines which duplicates to keep.\n\n    - `\"first\"`: Drop duplicates except for the first occurrence.\n    - `\"last\"`: Drop duplicates except for the last occurrence.\n    - `None`: Drop all duplicates\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.examples as ex\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> t = ex.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nCompute the distinct rows of a subset of columns\n\n>>> t[[\"species\", \"island\"]].distinct().order_by(s.all())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species   \u2503 island    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie    \u2502 Biscoe    \u2502\n\u2502 Adelie    \u2502 Dream     \u2502\n\u2502 Adelie    \u2502 Torgersen \u2502\n\u2502 Chinstrap \u2502 Dream     \u2502\n\u2502 Gentoo    \u2502 Biscoe    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDrop all duplicate rows except the first\n\n>>> t.distinct(on=[\"species\", \"island\"], keep=\"first\").order_by(s.all())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2513\n\u2503 species   \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_\u2026 \u2503 flipper_length_mm \u2503  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2529\n\u2502 string    \u2502 string    \u2502 float64        \u2502 float64      \u2502 int64             \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524\n\u2502 Adelie    \u2502 Biscoe    \u2502           37.8 \u2502         18.3 \u2502               174 \u2502  \u2502\n\u2502 Adelie    \u2502 Dream     \u2502           39.5 \u2502         16.7 \u2502               178 \u2502  \u2502\n\u2502 Adelie    \u2502 Torgersen \u2502           39.1 \u2502         18.7 \u2502               181 \u2502  \u2502\n\u2502 Chinstrap \u2502 Dream     \u2502           46.5 \u2502         17.9 \u2502               192 \u2502  \u2502\n\u2502 Gentoo    \u2502 Biscoe    \u2502           46.1 \u2502         13.2 \u2502               211 \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2518\n\nDrop all duplicate rows except the last\n\n>>> t.distinct(on=[\"species\", \"island\"], keep=\"last\").order_by(s.all())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2513\n\u2503 species   \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_\u2026 \u2503 flipper_length_mm \u2503  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2529\n\u2502 string    \u2502 string    \u2502 float64        \u2502 float64      \u2502 int64             \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524\n\u2502 Adelie    \u2502 Biscoe    \u2502           42.7 \u2502         18.3 \u2502               196 \u2502  \u2502\n\u2502 Adelie    \u2502 Dream     \u2502           41.5 \u2502         18.5 \u2502               201 \u2502  \u2502\n\u2502 Adelie    \u2502 Torgersen \u2502           43.1 \u2502         19.2 \u2502               197 \u2502  \u2502\n\u2502 Chinstrap \u2502 Dream     \u2502           50.2 \u2502         18.7 \u2502               198 \u2502  \u2502\n\u2502 Gentoo    \u2502 Biscoe    \u2502           49.9 \u2502         16.1 \u2502               213 \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2518\n\nDrop all duplicated rows\n\n>>> expr = t.distinct(on=[\"species\", \"island\", \"year\", \"bill_length_mm\"], keep=None)\n>>> expr.count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 273 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 344 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can pass [`selectors`](./selectors.qmd) to `on`\n\n>>> t.distinct(on=~s.numeric())  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Biscoe    \u2502           37.8 \u2502          18.3 \u2502               174 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Biscoe    \u2502           37.7 \u2502          18.7 \u2502               180 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502           39.5 \u2502          16.7 \u2502               178 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502           37.2 \u2502          18.1 \u2502               178 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502           37.5 \u2502          18.9 \u2502               179 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502           46.1 \u2502          13.2 \u2502               211 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502           50.0 \u2502          16.3 \u2502               230 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nThe only valid values of `keep` are `\"first\"`, `\"last\"` and [](`None`).\n\n>>> t.distinct(on=\"species\", keep=\"second\")  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisError: Invalid value for keep: 'second' ...", "type": "function"}
{"source": "ibis/expr/types/relations.py::sample", "docstring": "Sample a fraction of rows from a table.\n\n::: {.callout-note}\n## Results may be non-repeatable\n\nSampling is by definition a random operation. Some backends support\nspecifying a `seed` for repeatable results, but not all backends\nsupport that option. And some backends (duckdb, for example) do support\nspecifying a seed but may still not have repeatable results in all\ncases.\n\nIn all cases, results are backend-specific. An execution against one\nbackend is unlikely to sample the same rows when executed against a\ndifferent backend, even with the same `seed` set.\n:::\n\nParameters\n----------\nfraction\n    The percentage of rows to include in the sample, expressed as a\n    float between 0 and 1.\nmethod\n    The sampling method to use. The default is \"row\", which includes\n    each row with a probability of `fraction`. If method is \"block\",\n    some backends may instead sample a fraction of blocks of rows\n    (where \"block\" is a backend dependent definition), which may be\n    significantly more efficient (at the cost of a less statistically\n    random sample). This is identical to \"row\" for backends lacking a\n    blockwise sampling implementation. For those coming from SQL, \"row\"\n    and \"block\" correspond to \"bernoulli\" and \"system\" respectively in\n    a TABLESAMPLE clause.\nseed\n    An optional random seed to use, for repeatable sampling. The range\n    of possible seed values is backend specific (most support at least\n    `[0, 2**31 - 1]`). Backends that never support specifying a seed\n    for repeatable sampling will error appropriately. Note that some\n    backends (like DuckDB) do support specifying a seed, but may still\n    not have repeatable results in all cases.\n\nReturns\n-------\nTable\n    The input table, with `fraction` of rows selected.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"x\": [1, 2, 3, 4], \"y\": [\"a\", \"b\", \"c\", \"d\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503 y      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502\n\u2502     2 \u2502 b      \u2502\n\u2502     3 \u2502 c      \u2502\n\u2502     4 \u2502 d      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSample approximately half the rows, with a seed specified for\nreproducibility.\n\n>>> t.sample(0.5, seed=1234)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503 y      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502 b      \u2502\n\u2502     3 \u2502 c      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::limit", "docstring": "Select `n` rows from `self` starting at `offset`.\n\n::: {.callout-note}\n## The result set is not deterministic without a call to [`order_by`](#ibis.expr.types.relations.Table.order_by).\n:::\n\nParameters\n----------\nn\n    Number of rows to include. If `None`, the entire table is selected\n    starting from `offset`.\noffset\n    Number of rows to skip first\n\nReturns\n-------\nTable\n    The first `n` rows of `self` starting at `offset`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 1, 2], \"b\": [\"c\", \"a\", \"a\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502\n\u2502     1 \u2502 a      \u2502\n\u2502     2 \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.limit(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502\n\u2502     1 \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can use `None` with `offset` to slice starting from a particular row\n\n>>> t.limit(None, offset=1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502\n\u2502     2 \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`Table.order_by`](#ibis.expr.types.relations.Table.order_by)", "type": "function"}
{"source": "ibis/expr/types/relations.py::head", "docstring": "Select the first `n` rows of a table.\n\n::: {.callout-note}\n## The result set is not deterministic without a call to [`order_by`](#ibis.expr.types.relations.Table.order_by).\n:::\n\nParameters\n----------\nn\n    Number of rows to include\n\nReturns\n-------\nTable\n    `self` limited to `n` rows\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 1, 2], \"b\": [\"c\", \"a\", \"a\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502\n\u2502     1 \u2502 a      \u2502\n\u2502     2 \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.head(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502\n\u2502     1 \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`Table.limit`](#ibis.expr.types.relations.Table.limit)\n[`Table.order_by`](#ibis.expr.types.relations.Table.order_by)", "type": "function"}
{"source": "ibis/expr/types/relations.py::order_by", "docstring": "Sort a table by one or more expressions.\n\nSimilar to `pandas.DataFrame.sort_values()`.\n\nParameters\n----------\nby\n    Expressions to sort the table by.\n\nReturns\n-------\nTable\n    Sorted table\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"a\": [3, 2, 1, 3],\n...         \"b\": [\"a\", \"B\", \"c\", \"D\"],\n...         \"c\": [4, 6, 5, 7],\n...     }\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSort by b. Default is ascending. Note how capital letters come before lowercase\n\n>>> t.order_by(\"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSort in descending order\n\n>>> t.order_by(ibis.desc(\"b\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can also use the deferred API to get the same result\n\n>>> from ibis import _\n>>> t.order_by(_.b.desc())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSort by multiple columns/expressions\n\n>>> t.order_by([\"a\", _.c.desc()])\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can actually pass arbitrary expressions to use as sort keys.\nFor example, to ignore the case of the strings in column `b`\n\n>>> t.order_by(_.b.lower())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThis means that shuffling a Table is super simple\n\n>>> t.order_by(ibis.random())  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 c      \u2502     5 \u2502\n\u2502     3 \u2502 D      \u2502     7 \u2502\n\u2502     3 \u2502 a      \u2502     4 \u2502\n\u2502     2 \u2502 B      \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n[Selectors](./selectors.qmd) are allowed as sort keys and are a concise way to sort by\nmultiple columns matching some criteria\n\n>>> import ibis.selectors as s\n>>> penguins = ibis.examples.penguins.fetch()\n>>> penguins[[\"year\", \"island\"]].value_counts().order_by(s.startswith(\"year\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 island    \u2503 year_island_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string    \u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502 Torgersen \u2502                20 \u2502\n\u2502  2007 \u2502 Biscoe    \u2502                44 \u2502\n\u2502  2007 \u2502 Dream     \u2502                46 \u2502\n\u2502  2008 \u2502 Torgersen \u2502                16 \u2502\n\u2502  2008 \u2502 Dream     \u2502                34 \u2502\n\u2502  2008 \u2502 Biscoe    \u2502                64 \u2502\n\u2502  2009 \u2502 Torgersen \u2502                16 \u2502\n\u2502  2009 \u2502 Dream     \u2502                44 \u2502\n\u2502  2009 \u2502 Biscoe    \u2502                60 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUse the [`across`](./selectors.qmd#ibis.selectors.across) selector to\napply a specific order to multiple columns\n\n>>> penguins[[\"year\", \"island\"]].value_counts().order_by(\n...     s.across(s.startswith(\"year\"), _.desc())\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 island    \u2503 year_island_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string    \u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2009 \u2502 Biscoe    \u2502                60 \u2502\n\u2502  2009 \u2502 Dream     \u2502                44 \u2502\n\u2502  2009 \u2502 Torgersen \u2502                16 \u2502\n\u2502  2008 \u2502 Biscoe    \u2502                64 \u2502\n\u2502  2008 \u2502 Dream     \u2502                34 \u2502\n\u2502  2008 \u2502 Torgersen \u2502                16 \u2502\n\u2502  2007 \u2502 Dream     \u2502                46 \u2502\n\u2502  2007 \u2502 Biscoe    \u2502                44 \u2502\n\u2502  2007 \u2502 Torgersen \u2502                20 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::_assemble_set_op", "docstring": "Assemble a set operation expression.\n\nThis exists to workaround an issue in sqlglot where codegen blows the\nPython stack because of set operation nesting.\n\nThe implementation here uses a queue to balance the operation tree.", "type": "function"}
{"source": "ibis/expr/types/relations.py::union", "docstring": "Compute the multiset (or set) union of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use multiset union (False) or set union (True). See examples.\n\nReturns\n-------\nTable\n    A new table containing the union of all input tables.\n\nSee Also\n--------\n[`ibis.union`](./expression-tables.qmd#ibis.union)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [1, 2]})\n>>> t1\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t2 = ibis.memtable({\"a\": [2, 3]})\n>>> t2\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t1.union(t2)  # union all by default\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t1.union(t2, distinct=True).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can union more than two tables at once.\n\n>>> t1.union(t1, t1).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::intersect", "docstring": "Compute the set (or multiset) intersection of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set intersect (True) or multiset intersect (False). See examples.\n\nReturns\n-------\nTable\n    A new table containing the intersection of all input tables.\n\nSee Also\n--------\n[`ibis.intersect`](./expression-tables.qmd#ibis.intersect)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> two_a = ibis.memtable({\"x\": [\"a\", \"a\", \"b\"]})\n>>> three_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"b\"]})\n>>> four_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"a\", \"c\"]})\n\nWith `distinct=True`, the intersection will return one row for each row that appears in all input tables.\nThis is equivalent to a set intersection.\nSo even though the source tables have multiple `\"a\"` values, the result will only have one:\n\n>>> two_a.intersect(three_a).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the intersection will return all rows that appear in all input tables.\nThis is equivalent to a multiset intersection.\nSince the smallest number of appearances of `\"a\"` is 2, the result will have two `\"a\"` values:\n\n>>> two_a.intersect(three_a, distinct=False).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMore than two table expressions can be intersected at once.\n- Since `\"a\"` appears at minimum one time, it appears once in the result.\n- Since `\"b\"` doesn't appear in `two_a` or `three_a`, it is not included.\n- Since `\"c\"` does not appear in `one_a`, it is not included.\n\n>>> two_a.intersect(three_a, four_a)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> two_a.intersect(three_a, four_a, distinct=False)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::difference", "docstring": "Compute the set (or multiset) difference of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set difference (`True`) or multiset difference (`False`). See examples.\n\nSee Also\n--------\n[`ibis.difference`](./expression-tables.qmd#ibis.difference)\n\nReturns\n-------\nTable\n    The rows present in `self` that are not present in `tables`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [7, 8, 8, 9, 9, 9]})\n>>> t2 = ibis.memtable({\"a\": [8, 9]})\n\nWith distinct=True, if a row ever appears in any of `*rest`,\nit will not appear in the result.\nSo here, all appearances of 8 and 9 are removed:\n\n>>> t1.difference(t2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the algorithm is a [multiset](https://en.wikipedia.org/wiki/Multiset) difference.\nThis means, that since 8 and 9 each appear once in `t2`,\nthe result will be the input with a single instance of each removed:\n\n>>> t1.difference(t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     8 \u2502\n\u2502     9 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith multiple tables in `*rest`, we apply the operation consecutively.\nHere, we remove two eights and two nines:\n\n>>> t1.difference(t2, t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::to_array", "docstring": "Deprecated - use `as_scalar` instead.", "type": "function"}
{"source": "ibis/expr/types/relations.py::mutate", "docstring": "Add columns to a table expression.\n\nParameters\n----------\nexprs\n    List of named expressions to add as columns\nmutations\n    Named expressions using keyword arguments\n\nReturns\n-------\nTable\n    Table expression with additional columns\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().select(\"species\", \"year\", \"bill_length_mm\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2007 \u2502           39.1 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           39.5 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           40.3 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           NULL \u2502\n\u2502 Adelie  \u2502  2007 \u2502           36.7 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           39.3 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           38.9 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           39.2 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           34.1 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           42.0 \u2502\n\u2502 \u2026       \u2502     \u2026 \u2502              \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAdd a new column from a per-element expression\n\n>>> t.mutate(next_year=_.year + 1).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503 bill_length_mm \u2503 next_year \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502 float64        \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2007 \u2502           39.1 \u2502      2008 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           39.5 \u2502      2008 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           40.3 \u2502      2008 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           NULL \u2502      2008 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           36.7 \u2502      2008 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAdd a new column based on an aggregation. Note the automatic broadcasting.\n\n>>> t.select(\"species\", bill_demean=_.bill_length_mm - _.bill_length_mm.mean()).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 bill_demean \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502    -4.82193 \u2502\n\u2502 Adelie  \u2502    -4.42193 \u2502\n\u2502 Adelie  \u2502    -3.62193 \u2502\n\u2502 Adelie  \u2502        NULL \u2502\n\u2502 Adelie  \u2502    -7.22193 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMutate across multiple columns\n\n>>> t.mutate(s.across(s.numeric() & ~s.cols(\"year\"), _ - _.mean())).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2007 \u2502       -4.82193 \u2502\n\u2502 Adelie  \u2502  2007 \u2502       -4.42193 \u2502\n\u2502 Adelie  \u2502  2007 \u2502       -3.62193 \u2502\n\u2502 Adelie  \u2502  2007 \u2502           NULL \u2502\n\u2502 Adelie  \u2502  2007 \u2502       -7.22193 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::select", "docstring": "Compute a new table expression using `exprs` and `named_exprs`.\n\nPassing an aggregate function to this method will broadcast the\naggregate's value over the number of rows in the table and\nautomatically constructs a window function expression. See the examples\nsection for more details.\n\nFor backwards compatibility the keyword argument `exprs` is reserved\nand cannot be used to name an expression. This behavior will be removed\nin v4.\n\nParameters\n----------\nexprs\n    Column expression, string, or list of column expressions and\n    strings.\nnamed_exprs\n    Column expressions\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nSimple projection\n\n>>> t.select(\"island\", \"bill_length_mm\").head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502           39.1 \u2502\n\u2502 Torgersen \u2502           39.5 \u2502\n\u2502 Torgersen \u2502           40.3 \u2502\n\u2502 Torgersen \u2502           NULL \u2502\n\u2502 Torgersen \u2502           36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIn that simple case, you could also just use python's indexing syntax\n\n>>> t[[\"island\", \"bill_length_mm\"]].head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502           39.1 \u2502\n\u2502 Torgersen \u2502           39.5 \u2502\n\u2502 Torgersen \u2502           40.3 \u2502\n\u2502 Torgersen \u2502           NULL \u2502\n\u2502 Torgersen \u2502           36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProjection by zero-indexed column position\n\n>>> t.select(t[0], t[4]).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 flipper_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502               181 \u2502\n\u2502 Adelie  \u2502               186 \u2502\n\u2502 Adelie  \u2502               195 \u2502\n\u2502 Adelie  \u2502              NULL \u2502\n\u2502 Adelie  \u2502               193 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProjection with renaming and compute in one call\n\n>>> t.select(next_year=t.year + 1).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 next_year \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can do the same thing with a named expression, and using the\ndeferred API\n\n>>> from ibis import _\n>>> t.select((_.year + 1).name(\"next_year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 next_year \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2502      2008 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProjection with aggregation expressions\n\n>>> t.select(\"island\", bill_mean=t.bill_length_mm.mean()).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_mean \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502  43.92193 \u2502\n\u2502 Torgersen \u2502  43.92193 \u2502\n\u2502 Torgersen \u2502  43.92193 \u2502\n\u2502 Torgersen \u2502  43.92193 \u2502\n\u2502 Torgersen \u2502  43.92193 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProjection with a selector\n\n>>> import ibis.selectors as s\n>>> t.select(s.numeric() & ~s.cols(\"year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 body_mass_g \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502 float64       \u2502 int64             \u2502 int64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           39.1 \u2502          18.7 \u2502               181 \u2502        3750 \u2502\n\u2502           39.5 \u2502          17.4 \u2502               186 \u2502        3800 \u2502\n\u2502           40.3 \u2502          18.0 \u2502               195 \u2502        3250 \u2502\n\u2502           NULL \u2502          NULL \u2502              NULL \u2502        NULL \u2502\n\u2502           36.7 \u2502          19.3 \u2502               193 \u2502        3450 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProjection + aggregation across multiple columns\n\n>>> from ibis import _\n>>> t.select(s.across(s.numeric() & ~s.cols(\"year\"), _.mean())).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 body_mass_g \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502 float64       \u2502 float64           \u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       43.92193 \u2502      17.15117 \u2502        200.915205 \u2502 4201.754386 \u2502\n\u2502       43.92193 \u2502      17.15117 \u2502        200.915205 \u2502 4201.754386 \u2502\n\u2502       43.92193 \u2502      17.15117 \u2502        200.915205 \u2502 4201.754386 \u2502\n\u2502       43.92193 \u2502      17.15117 \u2502        200.915205 \u2502 4201.754386 \u2502\n\u2502       43.92193 \u2502      17.15117 \u2502        200.915205 \u2502 4201.754386 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::rename", "docstring": "Rename columns in the table.\n\nParameters\n----------\nmethod\n    An optional method for renaming columns. May be one of:\n\n    - A format string to use to rename all columns, like\n      `\"prefix_{name}\"`.\n    - A function from old name to new name. If the function returns\n      `None` the old name is used.\n    - The literal strings `\"snake_case\"` or `\"ALL_CAPS\"` to\n      rename all columns using a `snake_case` or `\"ALL_CAPS\"`\n      naming convention respectively.\n    - A mapping from new name to old name. Existing columns not present\n      in the mapping will passthrough with their original name.\nsubstitutions\n    Columns to be explicitly renamed, expressed as `new_name=old_name`\n    keyword arguments.\n\nReturns\n-------\nTable\n    A renamed table expression\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> first3 = s.index[:3]  # first 3 columns\n>>> t = ibis.examples.penguins_raw_raw.fetch().select(first3)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 studyName \u2503 Sample Number \u2503 Species                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64         \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708   \u2502             1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             2 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             3 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             4 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             5 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             6 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             7 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             8 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502             9 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 PAL0708   \u2502            10 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2502 \u2026         \u2502             \u2026 \u2502 \u2026                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRename specific columns by passing keyword arguments like\n`new_name=\"old_name\"`\n\n>>> t.rename(study_name=\"studyName\").head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 study_name \u2503 Sample Number \u2503 Species                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502 int64         \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708    \u2502             1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRename all columns using a format string\n\n>>> t.rename(\"p_{name}\").head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 p_studyName \u2503 p_Sample Number \u2503 p_Species                           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string      \u2502 int64           \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708     \u2502               1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRename all columns using a snake_case convention\n\n>>> t.rename(\"snake_case\").head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 study_name \u2503 sample_number \u2503 species                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502 int64         \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708    \u2502             1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRename all columns using an ALL_CAPS convention\n\n>>> t.rename(\"ALL_CAPS\").head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 STUDY_NAME \u2503 SAMPLE_NUMBER \u2503 SPECIES                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502 int64         \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708    \u2502             1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRename all columns using a callable\n\n>>> t.rename(str.upper).head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 STUDYNAME \u2503 SAMPLE NUMBER \u2503 SPECIES                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64         \u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PAL0708   \u2502             1 \u2502 Adelie Penguin (Pygoscelis adeliae) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::drop", "docstring": "Remove fields from a table.\n\nParameters\n----------\nfields\n    Fields to drop. Strings and selectors are accepted.\n\nReturns\n-------\nTable\n    A table with all columns matching `fields` removed.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nDrop one or more columns\n\n>>> t.drop(\"species\").head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.drop(\"species\", \"bill_length_mm\").head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 body_mass_g \u2503 sex    \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64       \u2502 int64             \u2502 int64       \u2502 string \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502          18.7 \u2502               181 \u2502        3750 \u2502 male   \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502          17.4 \u2502               186 \u2502        3800 \u2502 female \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502          18.0 \u2502               195 \u2502        3250 \u2502 female \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502          NULL \u2502              NULL \u2502        NULL \u2502 NULL   \u2502 \u2026 \u2502\n\u2502 Torgersen \u2502          19.3 \u2502               193 \u2502        3450 \u2502 female \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nDrop with selectors, mix and match\n\n>>> import ibis.selectors as s\n>>> t.drop(\"species\", s.startswith(\"bill_\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 flipper_length_mm \u2503 body_mass_g \u2503 sex    \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64             \u2502 int64       \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torgersen \u2502               181 \u2502        3750 \u2502 male   \u2502  2007 \u2502\n\u2502 Torgersen \u2502               186 \u2502        3800 \u2502 female \u2502  2007 \u2502\n\u2502 Torgersen \u2502               195 \u2502        3250 \u2502 female \u2502  2007 \u2502\n\u2502 Torgersen \u2502              NULL \u2502        NULL \u2502 NULL   \u2502  2007 \u2502\n\u2502 Torgersen \u2502               193 \u2502        3450 \u2502 female \u2502  2007 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::filter", "docstring": "Select rows from `table` based on `predicates`.\n\nParameters\n----------\npredicates\n    Boolean value expressions used to select rows in `table`.\n\nReturns\n-------\nTable\n    Filtered table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.filter([t.species == \"Adelie\", t.body_mass_g > 3500]).sex.value_counts().drop_null(\n...     \"sex\"\n... ).order_by(\"sex\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sex    \u2503 sex_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 female \u2502        22 \u2502\n\u2502 male   \u2502        68 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::nunique", "docstring": "Compute the number of unique rows in the table.\n\nParameters\n----------\nwhere\n    Optional boolean expression to filter rows when counting.\n\nReturns\n-------\nIntegerScalar\n    Number of unique rows in the table\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [\"foo\", \"bar\", \"bar\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 foo    \u2502\n\u2502 bar    \u2502\n\u2502 bar    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.nunique()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 2 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.nunique(where=t.a != \"foo\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::count", "docstring": "Compute the number of rows in the table.\n\nParameters\n----------\nwhere\n    Optional boolean expression to filter rows when counting.\n\nReturns\n-------\nIntegerScalar\n    Number of rows in the table\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [\"foo\", \"bar\", \"baz\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 foo    \u2502\n\u2502 bar    \u2502\n\u2502 baz    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.count()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 3 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.count(where=t.a != \"foo\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 2 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> type(t.count())\n<class 'ibis.expr.types.numeric.IntegerScalar'>", "type": "function"}
{"source": "ibis/expr/types/relations.py::drop_null", "docstring": "Remove rows with null values from the table.\n\nParameters\n----------\nsubset\n    Columns names to consider when dropping nulls. By default all columns\n    are considered.\nhow\n    Determine whether a row is removed if there is **at least one null\n    value in the row** (`'any'`), or if **all** row values are null\n    (`'all'`).\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 344 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.drop_null([\"bill_length_mm\", \"body_mass_g\"]).count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 342 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.drop_null(how=\"all\").count()  # no rows where all columns are null\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 344 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::fill_null", "docstring": "Fill null values in a table expression.\n\n::: {.callout-note}\n## There is potential lack of type stability with the `fill_null` API\n\nFor example, different library versions may impact whether a given\nbackend promotes integer replacement values to floats.\n:::\n\nParameters\n----------\nreplacements\n    Value with which to fill nulls. If `replacements` is a mapping, the\n    keys are column names that map to their replacement value. If\n    passed as a scalar all columns are filled with that value.\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.sex\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sex    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 male   \u2502\n\u2502 female \u2502\n\u2502 female \u2502\n\u2502 NULL   \u2502\n\u2502 female \u2502\n\u2502 male   \u2502\n\u2502 female \u2502\n\u2502 male   \u2502\n\u2502 NULL   \u2502\n\u2502 NULL   \u2502\n\u2502 \u2026      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.fill_null({\"sex\": \"unrecorded\"}).sex\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sex        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 male       \u2502\n\u2502 female     \u2502\n\u2502 female     \u2502\n\u2502 unrecorded \u2502\n\u2502 female     \u2502\n\u2502 male       \u2502\n\u2502 female     \u2502\n\u2502 male       \u2502\n\u2502 unrecorded \u2502\n\u2502 unrecorded \u2502\n\u2502 \u2026          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::dropna", "docstring": "Deprecated - use `drop_null` instead.", "type": "function"}
{"source": "ibis/expr/types/relations.py::fillna", "docstring": "Deprecated - use `fill_null` instead.", "type": "function"}
{"source": "ibis/expr/types/relations.py::unpack", "docstring": "Project the struct fields of each of `columns` into `self`.\n\nExisting fields are retained in the projection.\n\nParameters\n----------\ncolumns\n    String column names to project into `self`.\n\nReturns\n-------\nTable\n    The child table with struct fields of each of `columns` projected.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lines = '''\n...     {\"name\": \"a\", \"pos\": {\"lat\": 10.1, \"lon\": 30.3}}\n...     {\"name\": \"b\", \"pos\": {\"lat\": 10.2, \"lon\": 30.2}}\n...     {\"name\": \"c\", \"pos\": {\"lat\": 10.3, \"lon\": 30.1}}\n... '''\n>>> with open(\"/tmp/lines.json\", \"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = ibis.read_json(\"/tmp/lines.json\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name   \u2503 pos                                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 struct<lat: float64, lon: float64> \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 {'lat': 10.1, 'lon': 30.3}         \u2502\n\u2502 b      \u2502 {'lat': 10.2, 'lon': 30.2}         \u2502\n\u2502 c      \u2502 {'lat': 10.3, 'lon': 30.1}         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.unpack(\"pos\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name   \u2503 lat     \u2503 lon     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502    10.1 \u2502    30.3 \u2502\n\u2502 b      \u2502    10.2 \u2502    30.2 \u2502\n\u2502 c      \u2502    10.3 \u2502    30.1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExisting columns are overwritten by unpacking, regardless of existing\ncolumn ordering.\n\nHere, `x` follows `a`:\n\n>>> t = ibis.memtable(\n...     {\"a\": [{\"x\": 1}, {\"x\": 2}], \"x\": [\"abc\", \"def\"]},\n...     schema={\"a\": \"struct<x: int>\", \"x\": \"string\"},\n... )\n>>> t.unpack(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAnd here, `x` precedes `a`:\n\n>>> t = ibis.memtable(\n...     {\"x\": [\"abc\", \"def\"], \"a\": [{\"x\": 1}, {\"x\": 2}]},\n...     schema={\"x\": \"string\", \"a\": \"struct<x: int>\"},\n... )\n>>> t.unpack(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`StructValue.lift`](./expression-collections.qmd#ibis.expr.types.structs.StructValue.lift)", "type": "function"}
{"source": "ibis/expr/types/relations.py::info", "docstring": "Return summary information about a table.\n\nReturns\n-------\nTable\n    Summary of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.info()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 name              \u2503 type    \u2503 nullable \u2503 nulls \u2503 non_nulls \u2503 null_frac \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 string  \u2502 boolean  \u2502 int64 \u2502 int64     \u2502 float64   \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 species           \u2502 string  \u2502 True     \u2502     0 \u2502       344 \u2502  0.000000 \u2502 \u2026 \u2502\n\u2502 island            \u2502 string  \u2502 True     \u2502     0 \u2502       344 \u2502  0.000000 \u2502 \u2026 \u2502\n\u2502 bill_length_mm    \u2502 float64 \u2502 True     \u2502     2 \u2502       342 \u2502  0.005814 \u2502 \u2026 \u2502\n\u2502 bill_depth_mm     \u2502 float64 \u2502 True     \u2502     2 \u2502       342 \u2502  0.005814 \u2502 \u2026 \u2502\n\u2502 flipper_length_mm \u2502 int64   \u2502 True     \u2502     2 \u2502       342 \u2502  0.005814 \u2502 \u2026 \u2502\n\u2502 body_mass_g       \u2502 int64   \u2502 True     \u2502     2 \u2502       342 \u2502  0.005814 \u2502 \u2026 \u2502\n\u2502 sex               \u2502 string  \u2502 True     \u2502    11 \u2502       333 \u2502  0.031977 \u2502 \u2026 \u2502\n\u2502 year              \u2502 int64   \u2502 True     \u2502     0 \u2502       344 \u2502  0.000000 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::describe", "docstring": "Return summary information about a table.\n\nParameters\n----------\nquantile\n    The quantiles to compute for numerical columns. Defaults to (0.25, 0.5, 0.75).\n\nReturns\n-------\nTable\n    A table containing summary information about the columns of self.\n\nNotes\n-----\nThis function computes summary statistics for each column in the table. For\nnumerical columns, it computes statistics such as minimum, maximum, mean,\nstandard deviation, and quantiles. For string columns, it computes the mode\nand the number of unique values.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> p = ibis.examples.penguins.fetch()\n>>> p.describe()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 name              \u2503 pos   \u2503 type    \u2503 count \u2503 nulls \u2503 unique \u2503 mode   \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 int16 \u2502 string  \u2502 int64 \u2502 int64 \u2502 int64  \u2502 string \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 species           \u2502     0 \u2502 string  \u2502   344 \u2502     0 \u2502      3 \u2502 Adelie \u2502 \u2026 \u2502\n\u2502 island            \u2502     1 \u2502 string  \u2502   344 \u2502     0 \u2502      3 \u2502 Biscoe \u2502 \u2026 \u2502\n\u2502 bill_length_mm    \u2502     2 \u2502 float64 \u2502   344 \u2502     2 \u2502    164 \u2502 NULL   \u2502 \u2026 \u2502\n\u2502 bill_depth_mm     \u2502     3 \u2502 float64 \u2502   344 \u2502     2 \u2502     80 \u2502 NULL   \u2502 \u2026 \u2502\n\u2502 flipper_length_mm \u2502     4 \u2502 int64   \u2502   344 \u2502     2 \u2502     55 \u2502 NULL   \u2502 \u2026 \u2502\n\u2502 body_mass_g       \u2502     5 \u2502 int64   \u2502   344 \u2502     2 \u2502     94 \u2502 NULL   \u2502 \u2026 \u2502\n\u2502 sex               \u2502     6 \u2502 string  \u2502   344 \u2502    11 \u2502      2 \u2502 male   \u2502 \u2026 \u2502\n\u2502 year              \u2502     7 \u2502 int64   \u2502   344 \u2502     0 \u2502      3 \u2502 NULL   \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> p.select(s.of_type(\"numeric\")).describe()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 name              \u2503 pos   \u2503 type    \u2503 count \u2503 nulls \u2503 unique \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 int16 \u2502 string  \u2502 int64 \u2502 int64 \u2502 int64  \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 flipper_length_mm \u2502     2 \u2502 int64   \u2502   344 \u2502     2 \u2502     55 \u2502 \u2026 \u2502\n\u2502 body_mass_g       \u2502     3 \u2502 int64   \u2502   344 \u2502     2 \u2502     94 \u2502 \u2026 \u2502\n\u2502 year              \u2502     4 \u2502 int64   \u2502   344 \u2502     0 \u2502      3 \u2502 \u2026 \u2502\n\u2502 bill_length_mm    \u2502     0 \u2502 float64 \u2502   344 \u2502     2 \u2502    164 \u2502 \u2026 \u2502\n\u2502 bill_depth_mm     \u2502     1 \u2502 float64 \u2502   344 \u2502     2 \u2502     80 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> p.select(s.of_type(\"string\")).describe()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 pos   \u2503 type   \u2503 count \u2503 nulls \u2503 unique \u2503 mode   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int16 \u2502 string \u2502 int64 \u2502 int64 \u2502 int64  \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 sex     \u2502     2 \u2502 string \u2502   344 \u2502    11 \u2502      2 \u2502 male   \u2502\n\u2502 species \u2502     0 \u2502 string \u2502   344 \u2502     0 \u2502      3 \u2502 Adelie \u2502\n\u2502 island  \u2502     1 \u2502 string \u2502   344 \u2502     0 \u2502      3 \u2502 Biscoe \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::join", "docstring": "Perform a join between two tables.\n\nParameters\n----------\nright\n    Right table to join\npredicates\n    Condition(s) to join on. See examples for details.\nhow\n    Join method, e.g. `\"inner\"` or `\"left\"`.\nlname\n    A format string to use to rename overlapping columns in the left\n    table (e.g. `\"left_{name}\"`).\nrname\n    A format string to use to rename overlapping columns in the right\n    table (e.g. `\"right_{name}\"`).\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> movies = ibis.examples.ml_latest_small_movies.fetch()\n>>> movies.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 movieId \u2503 title                            \u2503 genres                          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string                           \u2502 string                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502 Toy Story (1995)                 \u2502 Adventure|Animation|Children|C\u2026 \u2502\n\u2502       2 \u2502 Jumanji (1995)                   \u2502 Adventure|Children|Fantasy      \u2502\n\u2502       3 \u2502 Grumpier Old Men (1995)          \u2502 Comedy|Romance                  \u2502\n\u2502       4 \u2502 Waiting to Exhale (1995)         \u2502 Comedy|Drama|Romance            \u2502\n\u2502       5 \u2502 Father of the Bride Part II (19\u2026 \u2502 Comedy                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ratings = ibis.examples.ml_latest_small_ratings.fetch().drop(\"timestamp\")\n>>> ratings.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 userId \u2503 movieId \u2503 rating  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64   \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502       1 \u2502     4.0 \u2502\n\u2502      1 \u2502       3 \u2502     4.0 \u2502\n\u2502      1 \u2502       6 \u2502     4.0 \u2502\n\u2502      1 \u2502      47 \u2502     5.0 \u2502\n\u2502      1 \u2502      50 \u2502     5.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nEquality left join on the shared `movieId` column.\nNote the `_right` suffix added to all overlapping\ncolumns from the right table\n(in this case only the \"movieId\" column).\n\n>>> ratings.join(movies, \"movieId\", how=\"left\").head(5)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 userId \u2503 movieId \u2503 rating  \u2503 movieId_right \u2503 title                       \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64   \u2502 float64 \u2502 int64         \u2502 string                      \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502      1 \u2502       1 \u2502     4.0 \u2502             1 \u2502 Toy Story (1995)            \u2502 \u2026 \u2502\n\u2502      1 \u2502       3 \u2502     4.0 \u2502             3 \u2502 Grumpier Old Men (1995)     \u2502 \u2026 \u2502\n\u2502      1 \u2502       6 \u2502     4.0 \u2502             6 \u2502 Heat (1995)                 \u2502 \u2026 \u2502\n\u2502      1 \u2502      47 \u2502     5.0 \u2502            47 \u2502 Seven (a.k.a. Se7en) (1995) \u2502 \u2026 \u2502\n\u2502      1 \u2502      50 \u2502     5.0 \u2502            50 \u2502 Usual Suspects, The (1995)  \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nExplicit equality join using the default `how` value of `\"inner\"`.\nNote how there is no `_right` suffix added to the `movieId` column\nsince this is an inner join and the `movieId` column is part of the\njoin condition.\n\n>>> ratings.join(movies, ratings.movieId == movies.movieId).head(5)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 userId \u2503 movieId \u2503 rating  \u2503 title                  \u2503 genres                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64   \u2502 float64 \u2502 string                 \u2502 string                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502       1 \u2502     4.0 \u2502 Toy Story (1995)       \u2502 Adventure|Animation|C\u2026 \u2502\n\u2502      1 \u2502       3 \u2502     4.0 \u2502 Grumpier Old Men (199\u2026 \u2502 Comedy|Romance         \u2502\n\u2502      1 \u2502       6 \u2502     4.0 \u2502 Heat (1995)            \u2502 Action|Crime|Thriller  \u2502\n\u2502      1 \u2502      47 \u2502     5.0 \u2502 Seven (a.k.a. Se7en) \u2026 \u2502 Mystery|Thriller       \u2502\n\u2502      1 \u2502      50 \u2502     5.0 \u2502 Usual Suspects, The (\u2026 \u2502 Crime|Mystery|Thriller \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> tags = ibis.examples.ml_latest_small_tags.fetch()\n>>> tags.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 userId \u2503 movieId \u2503 tag             \u2503 timestamp  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64   \u2502 string          \u2502 int64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      2 \u2502   60756 \u2502 funny           \u2502 1445714994 \u2502\n\u2502      2 \u2502   60756 \u2502 Highly quotable \u2502 1445714996 \u2502\n\u2502      2 \u2502   60756 \u2502 will ferrell    \u2502 1445714992 \u2502\n\u2502      2 \u2502   89774 \u2502 Boxing story    \u2502 1445715207 \u2502\n\u2502      2 \u2502   89774 \u2502 MMA             \u2502 1445715200 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can join on multiple columns/conditions by passing in a\nsequence. Show the top 5 users by the number of unique movies that\nthey both rated *and* tagged:\n\n>>> (\n...     tags.join(ratings, [\"userId\", \"movieId\"])\n...     .group_by(_.userId)\n...     .agg(n_rated_and_tagged=_.movieId.nunique())\n...     .order_by(_.n_rated_and_tagged.desc())\n...     .head(5)\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 userId \u2503 n_rated_and_tagged \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    474 \u2502               1149 \u2502\n\u2502    567 \u2502                109 \u2502\n\u2502     62 \u2502                 69 \u2502\n\u2502    477 \u2502                 66 \u2502\n\u2502    424 \u2502                 58 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTo self-join a table with itself, you need to call\n`.view()` on one of the arguments so the two tables\nare distinct from each other.\n\nFor crafting more complex join conditions,\na valid form of a join condition is a 2-tuple like\n`({left_key}, {right_key})`, where each key can be\n\n- a Column\n- Deferred expression\n- lambda of the form (Table) -> Column\n\nFor example, to find all movies pairings that received the same\n(ignoring case) tags:\n\n>>> movie_tags = tags[\"movieId\", \"tag\"]\n>>> view = movie_tags.view()\n>>> movie_tags.join(\n...     view,\n...     [\n...         movie_tags.movieId != view.movieId,\n...         (_.tag.lower(), lambda t: t.tag.lower()),\n...     ],\n... ).head().order_by((\"movieId\", \"movieId_right\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 movieId \u2503 tag               \u2503 movieId_right \u2503 tag_right         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string            \u2502 int64         \u2502 string            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   60756 \u2502 funny             \u2502          1732 \u2502 funny             \u2502\n\u2502   60756 \u2502 Highly quotable   \u2502          1732 \u2502 Highly quotable   \u2502\n\u2502   89774 \u2502 Tom Hardy         \u2502        139385 \u2502 tom hardy         \u2502\n\u2502  106782 \u2502 drugs             \u2502          1732 \u2502 drugs             \u2502\n\u2502  106782 \u2502 Leonardo DiCaprio \u2502          5989 \u2502 Leonardo DiCaprio \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::asof_join", "docstring": "Perform an \"as-of\" join between `left` and `right`.\n\nSimilar to a left join except that the match is done on nearest key\nrather than equal keys.\n\nParameters\n----------\nright\n    Table expression\non\n    Closest match inequality condition\npredicates\n    Additional join predicates\ntolerance\n    Amount of time to look behind when joining\nlname\n    A format string to use to rename overlapping columns in the left\n    table (e.g. `\"left_{name}\"`).\nrname\n    A format string to use to rename overlapping columns in the right\n    table (e.g. `\"right_{name}\"`).\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> from datetime import datetime, timedelta\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> sensors = ibis.memtable(\n...     {\n...         \"site\": [\"a\", \"b\", \"a\", \"b\", \"a\"],\n...         \"humidity\": [0.3, 0.4, 0.5, 0.6, 0.7],\n...         \"event_time\": [\n...             datetime(2024, 11, 16, 12, 0, 15, 500000),\n...             datetime(2024, 11, 16, 12, 0, 15, 700000),\n...             datetime(2024, 11, 17, 18, 12, 14, 950000),\n...             datetime(2024, 11, 17, 18, 12, 15, 120000),\n...             datetime(2024, 11, 18, 18, 12, 15, 100000),\n...         ],\n...     }\n... )\n>>> events = ibis.memtable(\n...     {\n...         \"site\": [\"a\", \"b\", \"a\"],\n...         \"event_type\": [\n...             \"cloud coverage\",\n...             \"rain start\",\n...             \"rain stop\",\n...         ],\n...         \"event_time\": [\n...             datetime(2024, 11, 16, 12, 0, 15, 400000),\n...             datetime(2024, 11, 17, 18, 12, 15, 100000),\n...             datetime(2024, 11, 18, 18, 12, 15, 100000),\n...         ],\n...     }\n... )\n\nThis setup simulates time-series data by pairing irregularly collected sensor\nreadings with weather events, enabling analysis of environmental conditions\nbefore each event. We will use the `asof_join` method to match each event with\nthe most recent prior sensor reading from the sensors table at the same site.\n\n>>> sensors\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 site   \u2503 humidity \u2503 event_time              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64  \u2502 timestamp               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502      0.3 \u2502 2024-11-16 12:00:15.500 \u2502\n\u2502 b      \u2502      0.4 \u2502 2024-11-16 12:00:15.700 \u2502\n\u2502 a      \u2502      0.5 \u2502 2024-11-17 18:12:14.950 \u2502\n\u2502 b      \u2502      0.6 \u2502 2024-11-17 18:12:15.120 \u2502\n\u2502 a      \u2502      0.7 \u2502 2024-11-18 18:12:15.100 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> events\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 site   \u2503 event_type     \u2503 event_time              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string         \u2502 timestamp               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 cloud coverage \u2502 2024-11-16 12:00:15.400 \u2502\n\u2502 b      \u2502 rain start     \u2502 2024-11-17 18:12:15.100 \u2502\n\u2502 a      \u2502 rain stop      \u2502 2024-11-18 18:12:15.100 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWe can find the closest event to each sensor reading with a 1 second tolerance.\nUsing the \"site\" column as a join predicate ensures we only match events that\noccurred at or near the same site as the sensor reading.\n\n>>> tolerance = timedelta(seconds=1)\n>>> sensors.asof_join(events, on=\"event_time\", predicates=\"site\", tolerance=tolerance).drop(\n...     \"event_time_right\"\n... ).order_by(\"event_time\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 site   \u2503 humidity \u2503 event_time              \u2503 site_right \u2503 event_type     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64  \u2502 timestamp               \u2502 string     \u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502      0.3 \u2502 2024-11-16 12:00:15.500 \u2502 a          \u2502 cloud coverage \u2502\n\u2502 b      \u2502      0.4 \u2502 2024-11-16 12:00:15.700 \u2502 NULL       \u2502 NULL           \u2502\n\u2502 a      \u2502      0.5 \u2502 2024-11-17 18:12:14.950 \u2502 NULL       \u2502 NULL           \u2502\n\u2502 b      \u2502      0.6 \u2502 2024-11-17 18:12:15.120 \u2502 b          \u2502 rain start     \u2502\n\u2502 a      \u2502      0.7 \u2502 2024-11-18 18:12:15.100 \u2502 a          \u2502 rain stop      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::cross_join", "docstring": "Compute the cross join of a sequence of tables.\n\nParameters\n----------\nright\n    Right table\nrest\n    Additional tables to cross join\nlname\n    A format string to use to rename overlapping columns in the left\n    table (e.g. `\"left_{name}\"`).\nrname\n    A format string to use to rename overlapping columns in the right\n    table (e.g. `\"right_{name}\"`).\n\nReturns\n-------\nTable\n    Cross join of `left`, `right` and `rest`\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 344 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n>>> agg = t.drop(\"year\").agg(s.across(s.numeric(), _.mean()))\n>>> expr = t.cross_join(agg)\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> expr.columns\n('species',\n 'island',\n 'bill_length_mm',\n 'bill_depth_mm',\n 'flipper_length_mm',\n 'body_mass_g',\n 'sex',\n 'year',\n 'bill_length_mm_right',\n 'bill_depth_mm_right',\n 'flipper_length_mm_right',\n 'body_mass_g_right')\n>>> expr.count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 344 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::alias", "docstring": "Create a table expression with a specific name `alias`.\n\nThis method is useful for exposing an ibis expression to the underlying\nbackend for use in the\n[`Table.sql`](#ibis.expr.types.relations.Table.sql) method.\n\n::: {.callout-note}\n## `.alias` will create a temporary view\n\n`.alias` creates a temporary view in the database.\n\nThis side effect will be removed in a future version of ibis and **is\nnot part of the public API**.\n:::\n\nParameters\n----------\nalias\n    Name of the child expression\n\nReturns\n-------\nTable\n    An table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> expr = t.alias(\"ping\u00fcinos\").sql('SELECT * FROM \"ping\u00fcinos\" LIMIT 5')\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::sql", "docstring": "Run a SQL query against a table expression.\n\nParameters\n----------\nquery\n    Query string\ndialect\n    Optional string indicating the dialect of `query`. Defaults to the\n    backend's native dialect.\n\nReturns\n-------\nTable\n    An opaque table expression\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch(table_name=\"penguins\")\n>>> expr = t.sql(\n...     \"\"\"\n...     SELECT island, mean(bill_length_mm) AS avg_bill_length\n...     FROM penguins\n...     GROUP BY 1\n...     ORDER BY 2 DESC\n...     \"\"\"\n... )\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 avg_bill_length \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Biscoe    \u2502       45.257485 \u2502\n\u2502 Dream     \u2502       44.167742 \u2502\n\u2502 Torgersen \u2502       38.950980 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMix and match ibis expressions with SQL queries\n\n>>> t = ibis.examples.penguins.fetch(table_name=\"penguins\")\n>>> expr = t.sql(\n...     \"\"\"\n...     SELECT island, mean(bill_length_mm) AS avg_bill_length\n...     FROM penguins\n...     GROUP BY 1\n...     ORDER BY 2 DESC\n...     \"\"\"\n... )\n>>> expr = expr.mutate(\n...     island=_.island.lower(),\n...     avg_bill_length=_.avg_bill_length.round(1),\n... )\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 avg_bill_length \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 biscoe    \u2502            45.3 \u2502\n\u2502 dream     \u2502            44.2 \u2502\n\u2502 torgersen \u2502            39.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nBecause ibis expressions aren't named, they aren't visible to\nsubsequent `.sql` calls. Use the [`alias`](#ibis.expr.types.relations.Table.alias) method\nto assign a name to an expression.\n\n>>> expr.alias(\"b\").sql(\"SELECT * FROM b WHERE avg_bill_length > 40\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island \u2503 avg_bill_length \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 biscoe \u2502            45.3 \u2502\n\u2502 dream  \u2502            44.2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`Table.alias`](#ibis.expr.types.relations.Table.alias)", "type": "function"}
{"source": "ibis/expr/types/relations.py::to_pandas", "docstring": "Convert a table expression to a pandas DataFrame.\n\nParameters\n----------\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nDataFrame\n    The result of executing the expression as a pandas DataFrame", "type": "function"}
{"source": "ibis/expr/types/relations.py::cache", "docstring": "Cache the provided expression.\n\nAll subsequent operations on the returned expression will be performed\non the cached data. The lifetime of the cached table is tied to its\npython references (ie. it is released once the last reference to it is\ngarbage collected). Alternatively, use the\n[`with`](https://docs.python.org/3/reference/compound_stmts.html#with)\nstatement or call the `.release()` method for more control.\n\nThis method is idempotent: calling it multiple times in succession will\nreturn the same value as the first call.\n\n::: {.callout-note}\n## This method eagerly evaluates the expression prior to caching\n\nSubsequent evaluations will not recompute the expression so method\nchaining will not incur the overhead of caching more than once.\n:::\n\nReturns\n-------\nTable\n    Cached table\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> heavy_computation = ibis.literal(\"Heavy Computation\")\n>>> cached_penguins = t.mutate(computation=heavy_computation).cache()\n>>> cached_penguins\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nExplicit cache cleanup\n\n>>> with t.mutate(computation=heavy_computation).cache() as cached_penguins:\n...     cached_penguins\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::pivot_longer", "docstring": "Transform a table from wider to longer.\n\nParameters\n----------\ncol\n    String column name or selector.\nnames_to\n    A string or iterable of strings indicating how to name the new\n    pivoted columns.\nnames_pattern\n    Pattern to use to extract column names from the input. By default\n    the entire column name is extracted.\nnames_transform\n    Function or mapping of a name in `names_to` to a function to\n    transform a column name to a value.\nvalues_to\n    Name of the pivoted value column.\nvalues_transform\n    Apply a function to the value column. This can be a lambda or\n    deferred expression.\n\nReturns\n-------\nTable\n    Pivoted table\n\nExamples\n--------\nBasic usage\n\n>>> import ibis\n>>> import ibis.selectors as s\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> relig_income = ibis.examples.relig_income_raw.fetch()\n>>> relig_income\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 religion                \u2503 <$10k \u2503 $10-20k \u2503 $20-30k \u2503 $30-40k \u2503 $40-50k \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string                  \u2502 int64 \u2502 int64   \u2502 int64   \u2502 int64   \u2502 int64   \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Agnostic                \u2502    27 \u2502      34 \u2502      60 \u2502      81 \u2502      76 \u2502 \u2026 \u2502\n\u2502 Atheist                 \u2502    12 \u2502      27 \u2502      37 \u2502      52 \u2502      35 \u2502 \u2026 \u2502\n\u2502 Buddhist                \u2502    27 \u2502      21 \u2502      30 \u2502      34 \u2502      33 \u2502 \u2026 \u2502\n\u2502 Catholic                \u2502   418 \u2502     617 \u2502     732 \u2502     670 \u2502     638 \u2502 \u2026 \u2502\n\u2502 Don\u2019t know/refused      \u2502    15 \u2502      14 \u2502      15 \u2502      11 \u2502      10 \u2502 \u2026 \u2502\n\u2502 Evangelical Prot        \u2502   575 \u2502     869 \u2502    1064 \u2502     982 \u2502     881 \u2502 \u2026 \u2502\n\u2502 Hindu                   \u2502     1 \u2502       9 \u2502       7 \u2502       9 \u2502      11 \u2502 \u2026 \u2502\n\u2502 Historically Black Prot \u2502   228 \u2502     244 \u2502     236 \u2502     238 \u2502     197 \u2502 \u2026 \u2502\n\u2502 Jehovah's Witness       \u2502    20 \u2502      27 \u2502      24 \u2502      24 \u2502      21 \u2502 \u2026 \u2502\n\u2502 Jewish                  \u2502    19 \u2502      19 \u2502      25 \u2502      25 \u2502      30 \u2502 \u2026 \u2502\n\u2502 \u2026                       \u2502     \u2026 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nHere we convert column names not matching the selector for the `religion` column\nand convert those names into values\n\n>>> relig_income.pivot_longer(~s.cols(\"religion\"), names_to=\"income\", values_to=\"count\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 religion \u2503 income             \u2503 count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string   \u2502 string             \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Agnostic \u2502 <$10k              \u2502    27 \u2502\n\u2502 Agnostic \u2502 $10-20k            \u2502    34 \u2502\n\u2502 Agnostic \u2502 $20-30k            \u2502    60 \u2502\n\u2502 Agnostic \u2502 $30-40k            \u2502    81 \u2502\n\u2502 Agnostic \u2502 $40-50k            \u2502    76 \u2502\n\u2502 Agnostic \u2502 $50-75k            \u2502   137 \u2502\n\u2502 Agnostic \u2502 $75-100k           \u2502   122 \u2502\n\u2502 Agnostic \u2502 $100-150k          \u2502   109 \u2502\n\u2502 Agnostic \u2502 >150k              \u2502    84 \u2502\n\u2502 Agnostic \u2502 Don't know/refused \u2502    96 \u2502\n\u2502 \u2026        \u2502 \u2026                  \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSimilarly for a different example dataset, we convert names to values\nbut using a different selector and the default `values_to` value.\n\n>>> world_bank_pop = ibis.examples.world_bank_pop_raw.fetch()\n>>> world_bank_pop.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 country \u2503 indicator   \u2503 2000         \u2503 2001         \u2503 2002         \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string      \u2502 float64      \u2502 float64      \u2502 float64      \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 4.162500e+04 \u2502 4.202500e+04 \u2502 4.219400e+04 \u2502 \u2026 \u2502\n\u2502 ABW     \u2502 SP.URB.GROW \u2502 1.664222e+00 \u2502 9.563731e-01 \u2502 4.013352e-01 \u2502 \u2026 \u2502\n\u2502 ABW     \u2502 SP.POP.TOTL \u2502 8.910100e+04 \u2502 9.069100e+04 \u2502 9.178100e+04 \u2502 \u2026 \u2502\n\u2502 ABW     \u2502 SP.POP.GROW \u2502 2.539234e+00 \u2502 1.768757e+00 \u2502 1.194718e+00 \u2502 \u2026 \u2502\n\u2502 AFE     \u2502 SP.URB.TOTL \u2502 1.155517e+08 \u2502 1.197755e+08 \u2502 1.242275e+08 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> world_bank_pop.pivot_longer(s.matches(r\"\\d{4}\"), names_to=\"year\").head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 country \u2503 indicator   \u2503 year   \u2503 value   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string      \u2502 string \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 2000   \u2502 41625.0 \u2502\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 2001   \u2502 42025.0 \u2502\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 2002   \u2502 42194.0 \u2502\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 2003   \u2502 42277.0 \u2502\n\u2502 ABW     \u2502 SP.URB.TOTL \u2502 2004   \u2502 42317.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`pivot_longer` has some preprocessing capabilities like stripping a prefix and applying\na function to column names\n\n>>> billboard = ibis.examples.billboard.fetch()\n>>> billboard\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 artist         \u2503 track                   \u2503 date_entered \u2503 wk1   \u2503 wk2   \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string         \u2502 string                  \u2502 date         \u2502 int64 \u2502 int64 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 2 Pac          \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    87 \u2502    82 \u2502 \u2026 \u2502\n\u2502 2Ge+her        \u2502 The Hardest Part Of ... \u2502 2000-09-02   \u2502    91 \u2502    87 \u2502 \u2026 \u2502\n\u2502 3 Doors Down   \u2502 Kryptonite              \u2502 2000-04-08   \u2502    81 \u2502    70 \u2502 \u2026 \u2502\n\u2502 3 Doors Down   \u2502 Loser                   \u2502 2000-10-21   \u2502    76 \u2502    76 \u2502 \u2026 \u2502\n\u2502 504 Boyz       \u2502 Wobble Wobble           \u2502 2000-04-15   \u2502    57 \u2502    34 \u2502 \u2026 \u2502\n\u2502 98^0           \u2502 Give Me Just One Nig... \u2502 2000-08-19   \u2502    51 \u2502    39 \u2502 \u2026 \u2502\n\u2502 A*Teens        \u2502 Dancing Queen           \u2502 2000-07-08   \u2502    97 \u2502    97 \u2502 \u2026 \u2502\n\u2502 Aaliyah        \u2502 I Don't Wanna           \u2502 2000-01-29   \u2502    84 \u2502    62 \u2502 \u2026 \u2502\n\u2502 Aaliyah        \u2502 Try Again               \u2502 2000-03-18   \u2502    59 \u2502    53 \u2502 \u2026 \u2502\n\u2502 Adams, Yolanda \u2502 Open My Heart           \u2502 2000-08-26   \u2502    76 \u2502    76 \u2502 \u2026 \u2502\n\u2502 \u2026              \u2502 \u2026                       \u2502 \u2026            \u2502     \u2026 \u2502     \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> billboard.pivot_longer(\n...     s.startswith(\"wk\"),\n...     names_to=\"week\",\n...     names_pattern=r\"wk(.+)\",\n...     names_transform=int,\n...     values_to=\"rank\",\n...     values_transform=_.cast(\"int\"),\n... ).drop_null(\"rank\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 artist  \u2503 track                   \u2503 date_entered \u2503 week \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string                  \u2502 date         \u2502 int8 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    1 \u2502    87 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    2 \u2502    82 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    3 \u2502    72 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    4 \u2502    77 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    5 \u2502    87 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    6 \u2502    94 \u2502\n\u2502 2 Pac   \u2502 Baby Don't Cry (Keep... \u2502 2000-02-26   \u2502    7 \u2502    99 \u2502\n\u2502 2Ge+her \u2502 The Hardest Part Of ... \u2502 2000-09-02   \u2502    1 \u2502    91 \u2502\n\u2502 2Ge+her \u2502 The Hardest Part Of ... \u2502 2000-09-02   \u2502    2 \u2502    87 \u2502\n\u2502 2Ge+her \u2502 The Hardest Part Of ... \u2502 2000-09-02   \u2502    3 \u2502    92 \u2502\n\u2502 \u2026       \u2502 \u2026                       \u2502 \u2026            \u2502    \u2026 \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can use regular expression capture groups to extract multiple\nvariables stored in column names\n\n>>> who = ibis.examples.who.fetch()\n>>> who\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 country     \u2503 iso2   \u2503 iso3   \u2503 year  \u2503 new_sp_m014 \u2503 new_sp_m1524 \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string      \u2502 string \u2502 string \u2502 int64 \u2502 int64       \u2502 int64        \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1981 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1982 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1983 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1984 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1985 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1986 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1987 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1988 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1989 \u2502        NULL \u2502         NULL \u2502 \u2026 \u2502\n\u2502 \u2026           \u2502 \u2026      \u2502 \u2026      \u2502     \u2026 \u2502           \u2026 \u2502            \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> len(who.columns)\n60\n>>> who.pivot_longer(\n...     s.index[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_(.)(.*)\",\n...     values_to=\"count\",\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 country     \u2503 iso2   \u2503 iso3   \u2503 year  \u2503 diagnosis \u2503 gender \u2503 age    \u2503 count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string      \u2502 string \u2502 string \u2502 int64 \u2502 string    \u2502 string \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 014    \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 1524   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 2534   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 3544   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 4554   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 5564   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 m      \u2502 65     \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 f      \u2502 014    \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 f      \u2502 1524   \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502 f      \u2502 2534   \u2502  NULL \u2502\n\u2502 \u2026           \u2502 \u2026      \u2502 \u2026      \u2502     \u2026 \u2502 \u2026         \u2502 \u2026      \u2502 \u2026      \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`names_transform` is flexible, and can be:\n\n    1. A mapping of one or more names in `names_to` to callable\n    2. A callable that will be applied to every name\n\nLet's recode gender and age to numeric values using a mapping\n\n>>> who.pivot_longer(\n...     s.index[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_(.)(.*)\",\n...     names_transform=dict(\n...         gender={\"m\": 1, \"f\": 2}.get,\n...         age=dict(\n...             zip(\n...                 [\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\"],\n...                 range(7),\n...             )\n...         ).get,\n...     ),\n...     values_to=\"count\",\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 country     \u2503 iso2   \u2503 iso3   \u2503 year  \u2503 diagnosis \u2503 gender \u2503 age  \u2503 count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string      \u2502 string \u2502 string \u2502 int64 \u2502 string    \u2502 int8   \u2502 int8 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    0 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    1 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    2 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    3 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    4 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    5 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      1 \u2502    6 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      2 \u2502    0 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      2 \u2502    1 \u2502  NULL \u2502\n\u2502 Afghanistan \u2502 AF     \u2502 AFG    \u2502  1980 \u2502 sp        \u2502      2 \u2502    2 \u2502  NULL \u2502\n\u2502 \u2026           \u2502 \u2026      \u2502 \u2026      \u2502     \u2026 \u2502 \u2026         \u2502      \u2026 \u2502    \u2026 \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThe number of match groups in `names_pattern` must match the length of `names_to`\n\n>>> who.pivot_longer(  # quartodoc: +EXPECTED_FAILURE\n...     s.index[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_.(.*)\",\n... )\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisInputError: Number of match groups in `names_pattern` ...\n\n`names_transform` must be a mapping or callable\n\n>>> who.pivot_longer(\n...     s.index[\"new_sp_m014\":\"newrel_f65\"], names_transform=\"upper\"\n... )  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisTypeError: ... Got <class 'str'>", "type": "function"}
{"source": "ibis/expr/types/relations.py::pivot_wider", "docstring": "Pivot a table to a wider format.\n\nParameters\n----------\nid_cols\n    A set of columns that uniquely identify each observation.\nnames_from\n    An argument describing which column or columns to use to get the\n    name of the output columns.\nnames_prefix\n    String added to the start of every column name.\nnames_sep\n    If `names_from` or `values_from` contains multiple columns, this\n    argument will be used to join their values together into a single\n    string to use as a column name.\nnames_sort\n    If [](`True`) columns are sorted. If [](`False`) column names are\n    ordered by appearance.\nnames\n    An explicit sequence of values to look for in columns matching\n    `names_from`.\n\n    * When this value is `None`, the values will be computed from\n      `names_from`.\n    * When this value is not `None`, each element's length must match\n      the length of `names_from`.\n\n    See examples below for more detail.\nvalues_from\n    An argument describing which column or columns to get the cell\n    values from.\nvalues_fill\n    A scalar value that specifies what each value should be filled with\n    when missing.\nvalues_agg\n    A function applied to the value in each cell in the output.\n\nReturns\n-------\nTable\n    Wider pivoted table\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> from ibis import _\n>>> ibis.options.interactive = True\n\nBasic usage\n\n>>> fish_encounters = ibis.examples.fish_encounters.fetch()\n>>> fish_encounters\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 fish  \u2503 station \u2503 seen  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  4842 \u2502 Release \u2502     1 \u2502\n\u2502  4842 \u2502 I80_1   \u2502     1 \u2502\n\u2502  4842 \u2502 Lisbon  \u2502     1 \u2502\n\u2502  4842 \u2502 Rstr    \u2502     1 \u2502\n\u2502  4842 \u2502 Base_TD \u2502     1 \u2502\n\u2502  4842 \u2502 BCE     \u2502     1 \u2502\n\u2502  4842 \u2502 BCW     \u2502     1 \u2502\n\u2502  4842 \u2502 BCE2    \u2502     1 \u2502\n\u2502  4842 \u2502 BCW2    \u2502     1 \u2502\n\u2502  4842 \u2502 MAE     \u2502     1 \u2502\n\u2502     \u2026 \u2502 \u2026       \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> fish_encounters.pivot_wider(names_from=\"station\", values_from=\"seen\")  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 fish  \u2503 Release \u2503 I80_1 \u2503 Lisbon \u2503 Rstr  \u2503 Base_TD \u2503 BCE   \u2503 BCW   \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64   \u2502 int64 \u2502 int64  \u2502 int64 \u2502 int64   \u2502 int64 \u2502 int64 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502  4842 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4843 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4844 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4845 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502  4847 \u2502       1 \u2502     1 \u2502      1 \u2502  NULL \u2502    NULL \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502  4848 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502    NULL \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502  4849 \u2502       1 \u2502     1 \u2502   NULL \u2502  NULL \u2502    NULL \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502  4850 \u2502       1 \u2502     1 \u2502   NULL \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4851 \u2502       1 \u2502     1 \u2502   NULL \u2502  NULL \u2502    NULL \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502  4854 \u2502       1 \u2502     1 \u2502   NULL \u2502  NULL \u2502    NULL \u2502  NULL \u2502  NULL \u2502 \u2026 \u2502\n\u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502      \u2026 \u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502     \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nYou can do simple transpose-like operations using `pivot_wider`\n\n>>> t = ibis.memtable(dict(outcome=[\"yes\", \"no\"], counted=[3, 4]))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 outcome \u2503 counted \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 yes     \u2502       3 \u2502\n\u2502 no      \u2502       4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.pivot_wider(names_from=\"outcome\", values_from=\"counted\", names_sort=True)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 no    \u2503 yes   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     4 \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nFill missing pivoted values using `values_fill`\n\n>>> fish_encounters.pivot_wider(\n...     names_from=\"station\", values_from=\"seen\", values_fill=0\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 fish  \u2503 Release \u2503 I80_1 \u2503 Lisbon \u2503 Rstr  \u2503 Base_TD \u2503 BCE   \u2503 BCW   \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64   \u2502 int64 \u2502 int64  \u2502 int64 \u2502 int64   \u2502 int64 \u2502 int64 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502  4842 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4843 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4844 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4845 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       1 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502  4847 \u2502       1 \u2502     1 \u2502      1 \u2502     0 \u2502       0 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502  4848 \u2502       1 \u2502     1 \u2502      1 \u2502     1 \u2502       0 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502  4849 \u2502       1 \u2502     1 \u2502      0 \u2502     0 \u2502       0 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502  4850 \u2502       1 \u2502     1 \u2502      0 \u2502     1 \u2502       1 \u2502     1 \u2502     1 \u2502 \u2026 \u2502\n\u2502  4851 \u2502       1 \u2502     1 \u2502      0 \u2502     0 \u2502       0 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502  4854 \u2502       1 \u2502     1 \u2502      0 \u2502     0 \u2502       0 \u2502     0 \u2502     0 \u2502 \u2026 \u2502\n\u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502      \u2026 \u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502     \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nCompute multiple values columns\n\n>>> us_rent_income = ibis.examples.us_rent_income.fetch()\n>>> us_rent_income\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 geoid  \u2503 name       \u2503 variable \u2503 estimate \u2503 moe   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string     \u2502 string   \u2502 int64    \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 01     \u2502 Alabama    \u2502 income   \u2502    24476 \u2502   136 \u2502\n\u2502 01     \u2502 Alabama    \u2502 rent     \u2502      747 \u2502     3 \u2502\n\u2502 02     \u2502 Alaska     \u2502 income   \u2502    32940 \u2502   508 \u2502\n\u2502 02     \u2502 Alaska     \u2502 rent     \u2502     1200 \u2502    13 \u2502\n\u2502 04     \u2502 Arizona    \u2502 income   \u2502    27517 \u2502   148 \u2502\n\u2502 04     \u2502 Arizona    \u2502 rent     \u2502      972 \u2502     4 \u2502\n\u2502 05     \u2502 Arkansas   \u2502 income   \u2502    23789 \u2502   165 \u2502\n\u2502 05     \u2502 Arkansas   \u2502 rent     \u2502      709 \u2502     5 \u2502\n\u2502 06     \u2502 California \u2502 income   \u2502    29454 \u2502   109 \u2502\n\u2502 06     \u2502 California \u2502 rent     \u2502     1358 \u2502     3 \u2502\n\u2502 \u2026      \u2502 \u2026          \u2502 \u2026        \u2502        \u2026 \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> us_rent_income.pivot_wider(\n...     names_from=\"variable\", values_from=[\"estimate\", \"moe\"]\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 geoid  \u2503 name                 \u2503 estimate_income \u2503 moe_income \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string               \u2502 int64           \u2502 int64      \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 01     \u2502 Alabama              \u2502           24476 \u2502        136 \u2502 \u2026 \u2502\n\u2502 02     \u2502 Alaska               \u2502           32940 \u2502        508 \u2502 \u2026 \u2502\n\u2502 04     \u2502 Arizona              \u2502           27517 \u2502        148 \u2502 \u2026 \u2502\n\u2502 05     \u2502 Arkansas             \u2502           23789 \u2502        165 \u2502 \u2026 \u2502\n\u2502 06     \u2502 California           \u2502           29454 \u2502        109 \u2502 \u2026 \u2502\n\u2502 08     \u2502 Colorado             \u2502           32401 \u2502        109 \u2502 \u2026 \u2502\n\u2502 09     \u2502 Connecticut          \u2502           35326 \u2502        195 \u2502 \u2026 \u2502\n\u2502 10     \u2502 Delaware             \u2502           31560 \u2502        247 \u2502 \u2026 \u2502\n\u2502 11     \u2502 District of Columbia \u2502           43198 \u2502        681 \u2502 \u2026 \u2502\n\u2502 12     \u2502 Florida              \u2502           25952 \u2502         70 \u2502 \u2026 \u2502\n\u2502 \u2026      \u2502 \u2026                    \u2502               \u2026 \u2502          \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nThe column name separator can be changed using the `names_sep` parameter\n\n>>> us_rent_income.pivot_wider(\n...     names_from=\"variable\",\n...     names_sep=\".\",\n...     values_from=(\"estimate\", \"moe\"),\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 geoid  \u2503 name                 \u2503 estimate.income \u2503 moe.income \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string               \u2502 int64           \u2502 int64      \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 01     \u2502 Alabama              \u2502           24476 \u2502        136 \u2502 \u2026 \u2502\n\u2502 02     \u2502 Alaska               \u2502           32940 \u2502        508 \u2502 \u2026 \u2502\n\u2502 04     \u2502 Arizona              \u2502           27517 \u2502        148 \u2502 \u2026 \u2502\n\u2502 05     \u2502 Arkansas             \u2502           23789 \u2502        165 \u2502 \u2026 \u2502\n\u2502 06     \u2502 California           \u2502           29454 \u2502        109 \u2502 \u2026 \u2502\n\u2502 08     \u2502 Colorado             \u2502           32401 \u2502        109 \u2502 \u2026 \u2502\n\u2502 09     \u2502 Connecticut          \u2502           35326 \u2502        195 \u2502 \u2026 \u2502\n\u2502 10     \u2502 Delaware             \u2502           31560 \u2502        247 \u2502 \u2026 \u2502\n\u2502 11     \u2502 District of Columbia \u2502           43198 \u2502        681 \u2502 \u2026 \u2502\n\u2502 12     \u2502 Florida              \u2502           25952 \u2502         70 \u2502 \u2026 \u2502\n\u2502 \u2026      \u2502 \u2026                    \u2502               \u2026 \u2502          \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\nSupply an alternative function to summarize values\n\n>>> warpbreaks = ibis.examples.warpbreaks.fetch().select(\"wool\", \"tension\", \"breaks\")\n>>> warpbreaks\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 wool   \u2503 tension \u2503 breaks \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 A      \u2502 L       \u2502     26 \u2502\n\u2502 A      \u2502 L       \u2502     30 \u2502\n\u2502 A      \u2502 L       \u2502     54 \u2502\n\u2502 A      \u2502 L       \u2502     25 \u2502\n\u2502 A      \u2502 L       \u2502     70 \u2502\n\u2502 A      \u2502 L       \u2502     52 \u2502\n\u2502 A      \u2502 L       \u2502     51 \u2502\n\u2502 A      \u2502 L       \u2502     26 \u2502\n\u2502 A      \u2502 L       \u2502     67 \u2502\n\u2502 A      \u2502 M       \u2502     18 \u2502\n\u2502 \u2026      \u2502 \u2026       \u2502      \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> warpbreaks.pivot_wider(\n...     names_from=\"wool\", values_from=\"breaks\", values_agg=\"mean\"\n... ).select(\"tension\", \"A\", \"B\").order_by(\"tension\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 tension \u2503 A         \u2503 B         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 float64   \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 H       \u2502 24.555556 \u2502 18.777778 \u2502\n\u2502 L       \u2502 44.555556 \u2502 28.222222 \u2502\n\u2502 M       \u2502 24.000000 \u2502 28.777778 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPassing `Deferred` objects to `values_agg` is supported\n\n>>> warpbreaks.pivot_wider(\n...     names_from=\"tension\",\n...     values_from=\"breaks\",\n...     values_agg=_.sum(),\n... ).select(\"wool\", \"H\", \"L\", \"M\").order_by(s.all())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 wool   \u2503 H     \u2503 L     \u2503 M     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 A      \u2502   221 \u2502   401 \u2502   216 \u2502\n\u2502 B      \u2502   169 \u2502   254 \u2502   259 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUse a custom aggregate function\n\n>>> warpbreaks.pivot_wider(\n...     names_from=\"wool\",\n...     values_from=\"breaks\",\n...     values_agg=lambda col: col.std() / col.mean(),\n... ).select(\"tension\", \"A\", \"B\").order_by(\"tension\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 tension \u2503 A        \u2503 B        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 H       \u2502 0.418344 \u2502 0.260590 \u2502\n\u2502 L       \u2502 0.406183 \u2502 0.349325 \u2502\n\u2502 M       \u2502 0.360844 \u2502 0.327719 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nGenerate some random data, setting the random seed for reproducibility\n\n>>> import random\n>>> random.seed(0)\n>>> raw = ibis.memtable(\n...     [\n...         dict(\n...             product=product,\n...             country=country,\n...             year=year,\n...             production=random.random(),\n...         )\n...         for product in \"AB\"\n...         for country in [\"AI\", \"EI\"]\n...         for year in range(2000, 2015)\n...     ]\n... )\n>>> production = raw.filter(((_.product == \"A\") & (_.country == \"AI\")) | (_.product == \"B\"))\n>>> production.order_by(s.all())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 product \u2503 country \u2503 year  \u2503 production \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string  \u2502 int64 \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 A       \u2502 AI      \u2502  2000 \u2502   0.844422 \u2502\n\u2502 A       \u2502 AI      \u2502  2001 \u2502   0.757954 \u2502\n\u2502 A       \u2502 AI      \u2502  2002 \u2502   0.420572 \u2502\n\u2502 A       \u2502 AI      \u2502  2003 \u2502   0.258917 \u2502\n\u2502 A       \u2502 AI      \u2502  2004 \u2502   0.511275 \u2502\n\u2502 A       \u2502 AI      \u2502  2005 \u2502   0.404934 \u2502\n\u2502 A       \u2502 AI      \u2502  2006 \u2502   0.783799 \u2502\n\u2502 A       \u2502 AI      \u2502  2007 \u2502   0.303313 \u2502\n\u2502 A       \u2502 AI      \u2502  2008 \u2502   0.476597 \u2502\n\u2502 A       \u2502 AI      \u2502  2009 \u2502   0.583382 \u2502\n\u2502 \u2026       \u2502 \u2026       \u2502     \u2026 \u2502          \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPivoting with multiple name columns\n\n>>> production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     values_from=\"production\",\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 B_AI     \u2503 B_EI     \u2503 A_AI     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64  \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2000 \u2502 0.477010 \u2502 0.870471 \u2502 0.844422 \u2502\n\u2502  2001 \u2502 0.865310 \u2502 0.191067 \u2502 0.757954 \u2502\n\u2502  2002 \u2502 0.260492 \u2502 0.567511 \u2502 0.420572 \u2502\n\u2502  2003 \u2502 0.805028 \u2502 0.238616 \u2502 0.258917 \u2502\n\u2502  2004 \u2502 0.548699 \u2502 0.967540 \u2502 0.511275 \u2502\n\u2502  2005 \u2502 0.014042 \u2502 0.803179 \u2502 0.404934 \u2502\n\u2502  2006 \u2502 0.719705 \u2502 0.447970 \u2502 0.783799 \u2502\n\u2502  2007 \u2502 0.398824 \u2502 0.080446 \u2502 0.303313 \u2502\n\u2502  2008 \u2502 0.824845 \u2502 0.320055 \u2502 0.476597 \u2502\n\u2502  2009 \u2502 0.668153 \u2502 0.507941 \u2502 0.583382 \u2502\n\u2502     \u2026 \u2502        \u2026 \u2502        \u2026 \u2502        \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSelect a subset of names. This call incurs no computation when\nconstructing the expression.\n\n>>> production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     names=[(\"A\", \"AI\"), (\"B\", \"AI\")],\n...     values_from=\"production\",\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 A_AI     \u2503 B_AI     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2000 \u2502 0.844422 \u2502 0.477010 \u2502\n\u2502  2001 \u2502 0.757954 \u2502 0.865310 \u2502\n\u2502  2002 \u2502 0.420572 \u2502 0.260492 \u2502\n\u2502  2003 \u2502 0.258917 \u2502 0.805028 \u2502\n\u2502  2004 \u2502 0.511275 \u2502 0.548699 \u2502\n\u2502  2005 \u2502 0.404934 \u2502 0.014042 \u2502\n\u2502  2006 \u2502 0.783799 \u2502 0.719705 \u2502\n\u2502  2007 \u2502 0.303313 \u2502 0.398824 \u2502\n\u2502  2008 \u2502 0.476597 \u2502 0.824845 \u2502\n\u2502  2009 \u2502 0.583382 \u2502 0.668153 \u2502\n\u2502     \u2026 \u2502        \u2026 \u2502        \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSort the new columns' names\n\n>>> production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     values_from=\"production\",\n...     names_sort=True,\n... )  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 A_AI     \u2503 B_AI     \u2503 B_EI     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64  \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2000 \u2502 0.844422 \u2502 0.477010 \u2502 0.870471 \u2502\n\u2502  2001 \u2502 0.757954 \u2502 0.865310 \u2502 0.191067 \u2502\n\u2502  2002 \u2502 0.420572 \u2502 0.260492 \u2502 0.567511 \u2502\n\u2502  2003 \u2502 0.258917 \u2502 0.805028 \u2502 0.238616 \u2502\n\u2502  2004 \u2502 0.511275 \u2502 0.548699 \u2502 0.967540 \u2502\n\u2502  2005 \u2502 0.404934 \u2502 0.014042 \u2502 0.803179 \u2502\n\u2502  2006 \u2502 0.783799 \u2502 0.719705 \u2502 0.447970 \u2502\n\u2502  2007 \u2502 0.303313 \u2502 0.398824 \u2502 0.080446 \u2502\n\u2502  2008 \u2502 0.476597 \u2502 0.824845 \u2502 0.320055 \u2502\n\u2502  2009 \u2502 0.583382 \u2502 0.668153 \u2502 0.507941 \u2502\n\u2502     \u2026 \u2502        \u2026 \u2502        \u2026 \u2502        \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::relocate", "docstring": "Relocate `columns` before or after other specified columns.\n\nParameters\n----------\ncolumns\n    Columns to relocate. Selectors are accepted.\nbefore\n    A column name or selector to insert the new columns before.\nafter\n    A column name or selector. Columns in `columns` are relocated after the last\n    column selected in `after`.\nkwargs\n    Additional column names to relocate, renaming argument values to\n    keyword argument names.\n\nReturns\n-------\nTable\n    A table with the columns relocated.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import ibis.selectors as s\n>>> t = ibis.memtable(dict(a=[1], b=[1], c=[1], d=[\"a\"], e=[\"a\"], f=[\"a\"]))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 c     \u2503 d      \u2503 e      \u2503 f      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(\"f\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f      \u2503 a     \u2503 b     \u2503 c     \u2503 d      \u2503 e      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(\"a\", after=\"c\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b     \u2503 c     \u2503 a     \u2503 d      \u2503 e      \u2503 f      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(\"f\", before=\"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 f      \u2503 b     \u2503 c     \u2503 d      \u2503 e      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(\"a\", after=s.last())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b     \u2503 c     \u2503 d      \u2503 e      \u2503 f      \u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502 a      \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRelocate allows renaming\n\n>>> t.relocate(ff=\"f\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ff     \u2503 a     \u2503 b     \u2503 c     \u2503 d      \u2503 e      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can relocate based on any predicate selector, such as\n[`of_type`](./selectors.qmd#ibis.selectors.of_type)\n\n>>> t.relocate(s.of_type(\"string\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 d      \u2503 e      \u2503 f      \u2503 a     \u2503 b     \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string \u2502 string \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 a      \u2502 a      \u2502     1 \u2502     1 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(s.numeric(), after=s.last())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 d      \u2503 e      \u2503 f      \u2503 a     \u2503 b     \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string \u2502 string \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 a      \u2502 a      \u2502     1 \u2502     1 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWhen multiple columns are selected with `before` or `after`, those\nselected columns are moved before and after the `selectors` input\n\n>>> t = ibis.memtable(dict(a=[1], b=[\"a\"], c=[1], d=[\"a\"]))\n>>> t.relocate(s.numeric(), after=s.of_type(\"string\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b      \u2503 d      \u2503 a     \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 a      \u2502     1 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.relocate(s.numeric(), before=s.of_type(\"string\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 c     \u2503 b      \u2503 d      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 string \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 a      \u2502 a      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWhen there are duplicate **renames** in a call to relocate, the\nlast one is preserved\n\n>>> t.relocate(e=\"d\", f=\"d\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f      \u2503 a     \u2503 b      \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502 a      \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nHowever, if there are duplicates that are **not** part of a rename, the\norder specified in the relocate call is preserved\n\n>>> t.relocate(\n...     \"b\",\n...     s.of_type(\"string\"),  # \"b\" is a string column, so the selector matches\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b      \u2503 d      \u2503 a     \u2503 c     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 a      \u2502     1 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::value_counts", "docstring": "Compute a frequency table of this table's values.\n\n::: {.callout-note title=\"Changed in version 10.0.0\"}\nAdded `name` parameter.\n:::\n\nParameters\n----------\nname\n    The name to use for the frequency column.\n    If not provided, a suitable name will be generated.\n\nReturns\n-------\nTable\n    Frequency table of this table's values.\n\nSee Also\n--------\n[`Table.topk`](./expression-tables.qmd#ibis.expr.types.relations.Table.topk)\n[`Column.value_counts`](./expression-generic.qmd#ibis.expr.types.generic.Column.value_counts)\n[`Column.topk`](./expression-generic.qmd#ibis.expr.types.generic.Column.topk)\n\nExamples\n--------\n>>> from ibis import examples\n>>> ibis.options.interactive = True\n>>> t = examples.penguins.fetch()\n>>> t.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.year.value_counts(name=\"n\").order_by(\"year\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 n     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502   110 \u2502\n\u2502  2008 \u2502   114 \u2502\n\u2502  2009 \u2502   120 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t[[\"year\", \"island\"]].value_counts().order_by(\"year\", \"island\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 island    \u2503 year_island_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string    \u2502 int64             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502 Biscoe    \u2502                44 \u2502\n\u2502  2007 \u2502 Dream     \u2502                46 \u2502\n\u2502  2007 \u2502 Torgersen \u2502                20 \u2502\n\u2502  2008 \u2502 Biscoe    \u2502                64 \u2502\n\u2502  2008 \u2502 Dream     \u2502                34 \u2502\n\u2502  2008 \u2502 Torgersen \u2502                16 \u2502\n\u2502  2009 \u2502 Biscoe    \u2502                60 \u2502\n\u2502  2009 \u2502 Dream     \u2502                44 \u2502\n\u2502  2009 \u2502 Torgersen \u2502                16 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::topk", "docstring": "Get the most frequent values of this table.\n\nParameters\n----------\nk\n    Number of top values to return.\n    If `None`, all values are returned in descending order.\nname\n    The name to use for the frequency column.\n    If not provided, a suitable name will be generated.\n\nReturns\n-------\nTable\n    Frequency table of this table's values.\n\nSee Also\n--------\n[`Table.value_counts`](./expression-tables.qmd#ibis.expr.types.relations.Table.value_counts)\n[`Column.topk`](./expression-generic.qmd#ibis.expr.types.generic.Column.topk)\n[`Column.value_counts`](./expression-generic.qmd#ibis.expr.types.generic.Column.value_counts)\n\nExamples\n--------\n>>> from ibis import examples, selectors as s\n>>> ibis.options.interactive = True\n>>> t = examples.penguins.fetch().select(\"species\", \"island\", \"sex\", \"year\")\n>>> t.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 sex    \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502 male   \u2502  2007 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502 female \u2502  2007 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502 female \u2502  2007 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502 NULL   \u2502  2007 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502 female \u2502  2007 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.topk().order_by(ibis.desc(\"species_island_sex_year_count\"), s.all() & ~s.index[-1])\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species   \u2503 island \u2503 sex    \u2503 year  \u2503 species_island_sex_year_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string \u2502 string \u2502 int64 \u2502 int64                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Gentoo    \u2502 Biscoe \u2502 male   \u2502  2008 \u2502                            23 \u2502\n\u2502 Gentoo    \u2502 Biscoe \u2502 female \u2502  2008 \u2502                            22 \u2502\n\u2502 Gentoo    \u2502 Biscoe \u2502 male   \u2502  2009 \u2502                            21 \u2502\n\u2502 Gentoo    \u2502 Biscoe \u2502 female \u2502  2009 \u2502                            20 \u2502\n\u2502 Gentoo    \u2502 Biscoe \u2502 male   \u2502  2007 \u2502                            17 \u2502\n\u2502 Gentoo    \u2502 Biscoe \u2502 female \u2502  2007 \u2502                            16 \u2502\n\u2502 Chinstrap \u2502 Dream  \u2502 female \u2502  2007 \u2502                            13 \u2502\n\u2502 Chinstrap \u2502 Dream  \u2502 male   \u2502  2007 \u2502                            13 \u2502\n\u2502 Chinstrap \u2502 Dream  \u2502 female \u2502  2009 \u2502                            12 \u2502\n\u2502 Chinstrap \u2502 Dream  \u2502 male   \u2502  2009 \u2502                            12 \u2502\n\u2502 \u2026         \u2502 \u2026      \u2502 \u2026      \u2502     \u2026 \u2502                             \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.topk(3, name=\"n\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island \u2503 sex    \u2503 year  \u2503 n     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string \u2502 string \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Gentoo  \u2502 Biscoe \u2502 male   \u2502  2008 \u2502    23 \u2502\n\u2502 Gentoo  \u2502 Biscoe \u2502 female \u2502  2008 \u2502    22 \u2502\n\u2502 Gentoo  \u2502 Biscoe \u2502 male   \u2502  2009 \u2502    21 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::unnest", "docstring": "Unnest an array `column` from a table.\n\nWhen unnesting an existing column the newly unnested column replaces\nthe existing column.\n\nParameters\n----------\ncolumn\n    Array column to unnest.\noffset\n    Name of the resulting index column.\nkeep_empty\n    Keep empty array values as `NULL` in the output table, as well as\n    existing `NULL` values.\n\nReturns\n-------\nTable\n    Table with the array column `column` unnested.\n\nSee Also\n--------\n[`ArrayValue.unnest`](./expression-collections.qmd#ibis.expr.types.arrays.ArrayValue.unnest)\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n\nConstruct a table expression with an array column.\n\n>>> t = ibis.memtable({\"x\": [[1, 2], [], None, [3, 4, 5]], \"y\": [1, 2, 3, 4]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x                    \u2503 y     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2]               \u2502     1 \u2502\n\u2502 []                   \u2502     2 \u2502\n\u2502 NULL                 \u2502     3 \u2502\n\u2502 [3, 4, ... +1]       \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUnnest the array column `x`, replacing the **existing** `x` column.\n\n>>> t.unnest(\"x\").order_by(_.x)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503 y     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502\n\u2502     2 \u2502     1 \u2502\n\u2502     3 \u2502     4 \u2502\n\u2502     4 \u2502     4 \u2502\n\u2502     5 \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUnnest the array column `x` with an offset. The `offset` parameter is\nthe name of the resulting index column.\n\n>>> t.unnest(t.x, offset=\"idx\").order_by(_.x)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503 y     \u2503 idx   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502     0 \u2502\n\u2502     2 \u2502     1 \u2502     1 \u2502\n\u2502     3 \u2502     4 \u2502     0 \u2502\n\u2502     4 \u2502     4 \u2502     1 \u2502\n\u2502     5 \u2502     4 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nUnnest the array column `x` keep empty array values as `NULL` in the\noutput table.\n\n>>> t.unnest(_.x, offset=\"idx\", keep_empty=True).order_by(_.x, _.y)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x     \u2503 y     \u2503 idx   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502     0 \u2502\n\u2502     2 \u2502     1 \u2502     1 \u2502\n\u2502     3 \u2502     4 \u2502     0 \u2502\n\u2502     4 \u2502     4 \u2502     1 \u2502\n\u2502     5 \u2502     4 \u2502     2 \u2502\n\u2502  NULL \u2502     2 \u2502  NULL \u2502\n\u2502  NULL \u2502     3 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIf you need to preserve the row order of the preserved empty arrays or\nnull values use\n[`row_number`](./expression-tables.qmd#ibis.row_number) to\ncreate an index column before calling `unnest`.\n\n>>> (\n...     t.mutate(original_row=ibis.row_number())\n...     .unnest(\"x\", offset=\"idx\", keep_empty=True)\n...     .relocate(\"original_row\")\n...     .order_by(\"original_row\", \"idx\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 original_row \u2503 x     \u2503 y     \u2503 idx   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            0 \u2502     1 \u2502     1 \u2502     0 \u2502\n\u2502            0 \u2502     2 \u2502     1 \u2502     1 \u2502\n\u2502            1 \u2502  NULL \u2502     2 \u2502  NULL \u2502\n\u2502            2 \u2502  NULL \u2502     3 \u2502  NULL \u2502\n\u2502            3 \u2502     3 \u2502     4 \u2502     0 \u2502\n\u2502            3 \u2502     4 \u2502     4 \u2502     1 \u2502\n\u2502            3 \u2502     5 \u2502     4 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can also unnest more complex expressions, and the resulting column\nwill be projected as the last expression in the result.\n\n>>> t.unnest(_.x.map(lambda v: v + 1).name(\"plus_one\")).order_by(_.plus_one)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x                    \u2503 y     \u2503 plus_one \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<int64>         \u2502 int64 \u2502 int64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [1, 2]               \u2502     1 \u2502        2 \u2502\n\u2502 [1, 2]               \u2502     1 \u2502        3 \u2502\n\u2502 [3, 4, ... +1]       \u2502     4 \u2502        4 \u2502\n\u2502 [3, 4, ... +1]       \u2502     4 \u2502        5 \u2502\n\u2502 [3, 4, ... +1]       \u2502     4 \u2502        6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/relations.py::release", "docstring": "Release the underlying expression from the cache.", "type": "function"}
{"source": "ibis/expr/types/generic.py::Value", "docstring": "Base class for a data generating expression having a known type.", "type": "class"}
{"source": "ibis/expr/types/generic.py::null", "docstring": "Create a NULL scalar.\n\n`NULL`s with an unspecified type are castable and comparable to values,\nbut lack datatype-specific methods:\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.null().upper()  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n    ...\nAttributeError: 'NullScalar' object has no attribute 'upper'\n>>> ibis.null(str).upper()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.null(str).upper().isnull()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::literal", "docstring": "Create a scalar expression from a Python value.\n\n::: {.callout-tip}\n## Use specific functions for arrays, structs and maps\n\nIbis supports literal construction of arrays using the following\nfunctions:\n\n1. [`ibis.array`](./expression-collections.qmd#ibis.array)\n1. [`ibis.struct`](./expression-collections.qmd#ibis.struct)\n1. [`ibis.map`](./expression-collections.qmd#ibis.map)\n\nConstructing these types using `literal` will be deprecated in a future\nrelease.\n:::\n\nParameters\n----------\nvalue\n    A Python value\ntype\n    An instance of [`DataType`](./datatypes.qmd#ibis.expr.datatypes.DataType) or a string\n    indicating the ibis type of `value`. This parameter can be used\n    in cases where ibis's type inference isn't sufficient for discovering\n    the type of `value`.\n\nReturns\n-------\nScalar\n    An expression representing a literal value\n\nExamples\n--------\nConstruct an integer literal\n\n>>> import ibis\n>>> x = ibis.literal(42)\n>>> x.type()\nInt8(nullable=True)\n\nConstruct a `float64` literal from an `int`\n\n>>> y = ibis.literal(42, type=\"double\")\n>>> y.type()\nFloat64(nullable=True)\n\nIbis checks for invalid types\n\n>>> ibis.literal(\"foobar\", type=\"int64\")  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n  ...\nTypeError: Value 'foobar' cannot be safely coerced to int64\n\nLiterals can also be used in a deferred context.\n\nHere's an example of constructing a table of a column's type repeated for\nevery row:\n\n>>> from ibis import _, selectors as s\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.select(s.across(s.all(), ibis.literal(_.type(), type=str).name(_.get_name()))).head(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string \u2502 string         \u2502 string        \u2502 string            \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 string  \u2502 string \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::_is_null_literal", "docstring": "Detect whether `value` will be treated by ibis as a null literal.", "type": "function"}
{"source": "ibis/expr/types/generic.py::name", "docstring": "Rename an expression to `name`.\n\nParameters\n----------\nname\n    The new name of the expression\n\nReturns\n-------\nValue\n    `self` with name `name`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2]})\n>>> t.a\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.a.name(\"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::type", "docstring": "Return the [DataType](./datatypes.qmd) of `self`.\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"int_col\": [1],\n...         \"timestamp_col\": [\n...             datetime(2024, 11, 2, 10, 5, 2),\n...         ],\n...         \"string_col\": [\"a\"],\n...     }\n... )\n\n>>> t.int_col.type()\nInt64(nullable=True)\n>>> t.timestamp_col.type()\nTimestamp(timezone=None, scale=None, nullable=True)\n>>> t.string_col.type()\nString(length=None, nullable=True)", "type": "function"}
{"source": "ibis/expr/types/generic.py::hash", "docstring": "Compute an integer hash value.\n\n::: {.callout-note}\n## The hashing function used is backend-dependent.\n:::\n\nReturns\n-------\nIntegerValue\n    The hash value of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.literal(\"hello\").hash()  # doctest: +SKIP\n-4155090522938856779", "type": "function"}
{"source": "ibis/expr/types/generic.py::cast", "docstring": "Cast expression to indicated data type.\n\nSimilar to `pandas.Series.astype`.\n\nParameters\n----------\ntarget_type\n    Type to cast to. Anything accepted by [`ibis.dtype()`](./datatypes.qmd#ibis.dtype)\n\nReturns\n-------\nValue\n    Casted expression\n\nSee Also\n--------\n[`Value.try_cast()`](./expression-generic.qmd#ibis.expr.types.generic.Value.try_cast)\n[`ibis.dtype()`](./datatypes.qmd#ibis.dtype)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> x = ibis.examples.penguins.fetch()[\"bill_depth_mm\"]\n>>> x\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_depth_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          18.7 \u2502\n\u2502          17.4 \u2502\n\u2502          18.0 \u2502\n\u2502          NULL \u2502\n\u2502          19.3 \u2502\n\u2502          20.6 \u2502\n\u2502          17.8 \u2502\n\u2502          19.6 \u2502\n\u2502          18.1 \u2502\n\u2502          20.2 \u2502\n\u2502             \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\npython's built-in types can be used\n\n>>> x.cast(int)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Cast(bill_depth_mm, int64) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                         19 \u2502\n\u2502                         17 \u2502\n\u2502                         18 \u2502\n\u2502                       NULL \u2502\n\u2502                         19 \u2502\n\u2502                         21 \u2502\n\u2502                         18 \u2502\n\u2502                         20 \u2502\n\u2502                         18 \u2502\n\u2502                         20 \u2502\n\u2502                          \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nor string names\n\n>>> x.cast(\"uint16\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Cast(bill_depth_mm, uint16) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 uint16                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                          19 \u2502\n\u2502                          17 \u2502\n\u2502                          18 \u2502\n\u2502                        NULL \u2502\n\u2502                          19 \u2502\n\u2502                          21 \u2502\n\u2502                          18 \u2502\n\u2502                          20 \u2502\n\u2502                          18 \u2502\n\u2502                          20 \u2502\n\u2502                           \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIf you make an illegal cast, you won't know until the backend actually\nexecutes it. Consider [`.try_cast()`](#ibis.expr.types.generic.Value.try_cast).\n\n>>> ibis.literal(\"a string\").cast(\"int64\")  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n  ...\nConversionException: Conversion Error: Could not convert string 'a string' to INT64", "type": "function"}
{"source": "ibis/expr/types/generic.py::try_cast", "docstring": "Try cast expression to indicated data type.\n\nIf the cast fails for a row, the value is returned\nas null or NaN depending on target_type and backend behavior.\n\nParameters\n----------\ntarget_type\n    Type to try cast to. Anything accepted by [`ibis.dtype()`](./datatypes.qmd#ibis.dtype)\n\nReturns\n-------\nValue\n    Casted expression\n\nSee Also\n--------\n[`Value.cast()`](./expression-generic.qmd#ibis.expr.types.generic.Value.cast)\n[`ibis.dtype()`](./datatypes.qmd#ibis.dtype)\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"numbers\": [1, 2, 3, 4], \"strings\": [\"1.0\", \"2\", \"hello\", \"world\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 numbers \u2503 strings \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502 1.0     \u2502\n\u2502       2 \u2502 2       \u2502\n\u2502       3 \u2502 hello   \u2502\n\u2502       4 \u2502 world   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t = t.mutate(numbers_to_strings=_.numbers.try_cast(\"string\"))\n>>> t = t.mutate(strings_to_numbers=_.strings.try_cast(\"int\"))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 numbers \u2503 strings \u2503 numbers_to_strings \u2503 strings_to_numbers \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string  \u2502 string             \u2502 int64              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502 1.0     \u2502 1                  \u2502                  1 \u2502\n\u2502       2 \u2502 2       \u2502 2                  \u2502                  2 \u2502\n\u2502       3 \u2502 hello   \u2502 3                  \u2502               NULL \u2502\n\u2502       4 \u2502 world   \u2502 4                  \u2502               NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::coalesce", "docstring": "Return the first non-null value from `args`.\n\nParameters\n----------\nargs\n    Arguments from which to choose the first non-null value\n\nReturns\n-------\nValue\n    Coalesced expression\n\nSee Also\n--------\n[`ibis.coalesce()`](./expression-generic.qmd#ibis.coalesce)\n[`Value.fill_null()`](./expression-generic.qmd#ibis.expr.types.generic.Value.fill_null)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.coalesce(None, 4, 5).name(\"x\")\nx: Coalesce(...)", "type": "function"}
{"source": "ibis/expr/types/generic.py::typeof", "docstring": "Return the string name of the datatype of self.\n\nThe values of the returned strings are necessarily backend dependent.\ne.g. duckdb may say \"DOUBLE\", while sqlite may say \"real\".\n\nReturns\n-------\nStringValue\n    A string indicating the type of the value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> vals = ibis.examples.penguins.fetch().head(5).bill_length_mm\n>>> vals\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           39.1 \u2502\n\u2502           39.5 \u2502\n\u2502           40.3 \u2502\n\u2502           NULL \u2502\n\u2502           36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> vals.typeof()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 TypeOf(bill_length_mm) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 DOUBLE                 \u2502\n\u2502 DOUBLE                 \u2502\n\u2502 DOUBLE                 \u2502\n\u2502 DOUBLE                 \u2502\n\u2502 DOUBLE                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDifferent backends have different names for their native types\n\n>>> ibis.duckdb.connect().execute(ibis.literal(5.4).typeof())\n'DECIMAL(2,1)'\n>>> ibis.sqlite.connect().execute(ibis.literal(5.4).typeof())\n'real'", "type": "function"}
{"source": "ibis/expr/types/generic.py::fill_null", "docstring": "Replace `NULL`s with the given value. Does NOT affect `NaN` and `inf` values.\n\nThis only replaces genuine `NULL` values, it does NOT affect\n`NaN` and `inf` values for floating point types.\n\nParameters\n----------\nfill_value\n    Value with which to replace `NULL` values in `self`\n\nSee Also\n--------\n[`Value.coalesce()`](./expression-generic.qmd#ibis.expr.types.generic.Value.coalesce)\n[`ibis.coalesce()`](./expression-generic.qmd#ibis.coalesce)\n[`Value.isnull()`](./expression-generic.qmd#ibis.expr.types.generic.Value.isnull)\n[`FloatingValue.isnan()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isnan)\n[`FloatingValue.isinf()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isinf)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"f\": [None, \"-inf\", \"3.0\", \"inf\", \"nan\"]})\n>>> t = t.mutate(f=ibis._.f.cast(float))\n>>> t = t.mutate(filled=t.f.fill_null(99))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f       \u2503 filled  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502    99.0 \u2502\n\u2502    -inf \u2502    -inf \u2502\n\u2502     3.0 \u2502     3.0 \u2502\n\u2502     inf \u2502     inf \u2502\n\u2502     nan \u2502     nan \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIf you want to fill all `NaN` and `inf` values as well, use something like\nthe following:\n\n>>> t.mutate(filled2=ibis.or_(t.f.isnull(), t.f.isnan(), t.f.isinf()).ifelse(99, t.f))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f       \u2503 filled  \u2503 filled2 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502    99.0 \u2502    99.0 \u2502\n\u2502    -inf \u2502    -inf \u2502    99.0 \u2502\n\u2502     3.0 \u2502     3.0 \u2502     3.0 \u2502\n\u2502     inf \u2502     inf \u2502    99.0 \u2502\n\u2502     nan \u2502     nan \u2502    99.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nValue\n    `self` filled with `fill_value` where it is `NULL`", "type": "function"}
{"source": "ibis/expr/types/generic.py::fillna", "docstring": "DEPRECATED: use `fill_null` instead, which acts exactly the same.", "type": "function"}
{"source": "ibis/expr/types/generic.py::nullif", "docstring": "Set values to null if they equal the values `null_if_expr`.\n\nCommonly used to avoid divide-by-zero problems by replacing zero with\n`NULL` in the divisor.\n\nEquivalent to `(self == null_if_expr).ifelse(ibis.null(), self)`.\n\nParameters\n----------\nnull_if_expr\n    Expression indicating what values should be NULL\n\nReturns\n-------\nValue\n    Value expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> vals = ibis.examples.penguins.fetch().head(5).sex\n>>> vals\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sex    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 male   \u2502\n\u2502 female \u2502\n\u2502 female \u2502\n\u2502 NULL   \u2502\n\u2502 female \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> vals.nullif(\"male\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 NullIf(sex, 'male') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL                \u2502\n\u2502 female              \u2502\n\u2502 female              \u2502\n\u2502 NULL                \u2502\n\u2502 female              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::between", "docstring": "Check if this expression is between `lower` and `upper`, inclusive.\n\nParameters\n----------\nlower\n    Lower bound, inclusive\nupper\n    Upper bound, inclusive\n\nReturns\n-------\nBooleanValue\n    Expression indicating membership in the provided range\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().limit(5)\n>>> t.bill_length_mm.between(35, 38)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Between(bill_length_mm, 35, 38) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                           \u2502\n\u2502 False                           \u2502\n\u2502 False                           \u2502\n\u2502 NULL                            \u2502\n\u2502 True                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::isin", "docstring": "Check whether this expression is in `values`.\n\n`NULL` values in the input are propagated in the output.\nIf the `values` argument contains any `NULL` values,\nthen ibis follows the SQL behavior of returning `NULL` (not False)\nwhen `self` is not present.\nSee examples below for details.\n\nParameters\n----------\nvalues\n    Values or expression to check for membership.\n\nReturns\n-------\nBooleanValue\n    True if `self` is contained in `values`, False otherwise.\n\nSee Also\n--------\n[`Value.notin()`](./expression-generic.qmd#ibis.expr.types.generic.Value.notin)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"a\": [1, 2, 3, None],\n...         \"b\": [1, 2, 9, None],\n...     },\n...     schema={\"a\": int, \"b\": int},\n... )\n\nChecking for values in literals:\n\n>>> t.mutate(\n...     a_in_12=t.a.isin([1, 2]),\n...     a_in_12None=t.a.isin([1, 2, None]),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_in_12 \u2503 a_in_12None \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean \u2502 boolean     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 True    \u2502 True        \u2502\n\u2502     2 \u2502     2 \u2502 True    \u2502 True        \u2502\n\u2502     3 \u2502     9 \u2502 False   \u2502 NULL        \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL    \u2502 NULL        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nChecking for values in columns of the same table:\n\n>>> t.mutate(\n...     a_in_b=t.a.isin(t.b),\n...     a_in_b_no_null=t.a.isin(t.b.fill_null(0)),\n...     a_in_b_plus_1=t.a.isin(t.b + 1),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_in_b  \u2503 a_in_b_no_null \u2503 a_in_b_plus_1 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean \u2502 boolean        \u2502 boolean       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 True    \u2502 True           \u2502 NULL          \u2502\n\u2502     2 \u2502     2 \u2502 True    \u2502 True           \u2502 True          \u2502\n\u2502     3 \u2502     9 \u2502 NULL    \u2502 False          \u2502 True          \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL    \u2502 NULL           \u2502 NULL          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nChecking for values in a column from a different table:\n\n>>> t2 = ibis.memtable({\"x\": [1, 2, 99], \"y\": [1, 2, None]})\n>>> t.mutate(\n...     a_in_x=t.a.isin(t2.x),\n...     a_in_y=t.a.isin(t2.y),\n...     a_in_y_plus_1=t.a.isin(t2.y + 1),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_in_x  \u2503 a_in_y  \u2503 a_in_y_plus_1 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean \u2502 boolean \u2502 boolean       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 True    \u2502 True    \u2502 NULL          \u2502\n\u2502     2 \u2502     2 \u2502 True    \u2502 True    \u2502 True          \u2502\n\u2502     3 \u2502     9 \u2502 False   \u2502 NULL    \u2502 True          \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL    \u2502 NULL    \u2502 NULL          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::notin", "docstring": "Check whether this expression is not in `values`.\n\nOpposite of [`Value.isin()`](./expression-generic.qmd#ibis.expr.types.generic.Value.isin).\n\n`NULL` values in the input are propagated in the output.\nIf the `values` argument contains any `NULL` values,\nthen ibis follows the SQL behavior of returning `NULL` (not False)\nwhen `self` is present.\nSee examples below for details.\n\nParameters\n----------\nvalues\n    Values or expression to check for lack of membership.\n\nReturns\n-------\nBooleanValue\n    True if self is not in `values`, False otherwise.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"a\": [1, 2, 3, None],\n...         \"b\": [1, 2, 9, None],\n...     },\n...     schema={\"a\": int, \"b\": int},\n... )\n\nChecking for values in literals:\n\n>>> t.mutate(\n...     a_notin_12=t.a.notin([1, 2]),\n...     a_notin_12None=t.a.notin([1, 2, None]),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_notin_12 \u2503 a_notin_12None \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean    \u2502 boolean        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 False      \u2502 False          \u2502\n\u2502     2 \u2502     2 \u2502 False      \u2502 False          \u2502\n\u2502     3 \u2502     9 \u2502 True       \u2502 NULL           \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL       \u2502 NULL           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nChecking for values in columns of the same table:\n\n>>> t.mutate(\n...     a_notin_b=t.a.notin(t.b),\n...     a_notin_b_no_null=t.a.notin(t.b.fill_null(0)),\n...     a_notin_b_plus_1=t.a.notin(t.b + 1),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_notin_b \u2503 a_notin_b_no_null \u2503 a_notin_b_plus_1 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean   \u2502 boolean           \u2502 boolean          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 False     \u2502 False             \u2502 NULL             \u2502\n\u2502     2 \u2502     2 \u2502 False     \u2502 False             \u2502 False            \u2502\n\u2502     3 \u2502     9 \u2502 NULL      \u2502 True              \u2502 False            \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL      \u2502 NULL              \u2502 NULL             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nChecking for values in a column from a different table:\n\n>>> t2 = ibis.memtable({\"x\": [1, 2, 99], \"y\": [1, 2, None]})\n>>> t.mutate(\n...     a_notin_x=t.a.notin(t2.x),\n...     a_notin_y=t.a.notin(t2.y),\n...     a_notin_y_plus_1=t.a.notin(t2.y + 1),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b     \u2503 a_notin_x \u2503 a_notin_y \u2503 a_notin_y_plus_1 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 boolean   \u2502 boolean   \u2502 boolean          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     1 \u2502 False     \u2502 False     \u2502 NULL             \u2502\n\u2502     2 \u2502     2 \u2502 False     \u2502 False     \u2502 False            \u2502\n\u2502     3 \u2502     9 \u2502 True      \u2502 NULL      \u2502 False            \u2502\n\u2502  NULL \u2502  NULL \u2502 NULL      \u2502 NULL      \u2502 NULL             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::substitute", "docstring": "Replace values given in `values` with `replacement`.\n\nThis is similar to the pandas `replace` method.\n\nParameters\n----------\nvalue\n    Expression or dict.\nreplacement\n    If an expression is passed to value, this must be\n    passed.\nelse_\n    If an original value does not match `value`, then `else_` is used.\n    The default of `None` means leave the original value unchanged.\n\nReturns\n-------\nValue\n    Replaced values\n\nSee Also\n--------\n[`Value.cases()`](./expression-generic.qmd#ibis.expr.types.generic.Value.case)\n[`ibis.cases()`](./expression-generic.qmd#ibis.cases)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.island.value_counts().order_by(\"island\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 island_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Biscoe    \u2502          168 \u2502\n\u2502 Dream     \u2502          124 \u2502\n\u2502 Torgersen \u2502           52 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.island.substitute({\"Torgersen\": \"torg\", \"Biscoe\": \"bisc\"}).name(\n...     \"island\"\n... ).value_counts().order_by(\"island\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island \u2503 island_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Dream  \u2502          124 \u2502\n\u2502 bisc   \u2502          168 \u2502\n\u2502 torg   \u2502           52 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::over", "docstring": "Construct a window expression.\n\nParameters\n----------\nwindow\n    Window specification\nrows\n    Whether to use the `ROWS` window clause\nrange\n    Whether to use the `RANGE` window clause\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nValue\n    A window function expression", "type": "function"}
{"source": "ibis/expr/types/generic.py::isnull", "docstring": "Whether this expression is `NULL`. Does NOT detect `NaN` and `inf` values.\n\nFor FloatingValue types, use [`FloatingValue.isnan()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isnan)\nand [`FloatingValue.isinf()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isinf) to detect `NaN` and `inf` values.\n\nSee Also\n--------\n[`Value.fill_null()`](./expression-generic.qmd#ibis.expr.types.generic.Value.fill_null)\n[`FloatingValue.isnan()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isnan)\n[`FloatingValue.isinf()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isinf)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"f\": [None, \"-inf\", \"3.0\", \"inf\", \"nan\"]})\n>>> t = t.mutate(f=ibis._.f.cast(float))\n>>> t.mutate(\n...     isnull=t.f.isnull(),\n...     isnan=t.f.isnan(),\n...     isinf=t.f.isinf(),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f       \u2503 isnull  \u2503 isnan   \u2503 isinf   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 boolean \u2502 boolean \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502 True    \u2502 NULL    \u2502 NULL    \u2502\n\u2502    -inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     3.0 \u2502 False   \u2502 False   \u2502 False   \u2502\n\u2502     inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     nan \u2502 False   \u2502 True    \u2502 False   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::notnull", "docstring": "Return whether this expression is not NULL.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().limit(5)\n>>> t.bill_depth_mm\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_depth_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          18.7 \u2502\n\u2502          17.4 \u2502\n\u2502          18.0 \u2502\n\u2502          NULL \u2502\n\u2502          19.3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.bill_depth_mm.notnull()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 NotNull(bill_depth_mm) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                   \u2502\n\u2502 True                   \u2502\n\u2502 True                   \u2502\n\u2502 False                  \u2502\n\u2502 True                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::case", "docstring": "DEPRECATED: use `value.cases()` or `ibis.cases()` instead.", "type": "function"}
{"source": "ibis/expr/types/generic.py::cases", "docstring": "Create a multi-branch if-else expression.\n\nEquivalent to a SQL `CASE` statement.\n\nParameters\n----------\nbranch\n    First (`condition`, `result`) pair. Required.\nbranches\n    Additional (`condition`, `result`) pairs. We look through the test\n    values in order and return the result corresponding to the first\n    test value that matches `self`. If none match, we return `else_`.\nelse_\n    Value to return if none of the case conditions evaluate to `True`.\n    Defaults to `NULL`.\n\nReturns\n-------\nValue\n    A value expression\n\nSee Also\n--------\n[`Value.substitute()`](./expression-generic.qmd#ibis.expr.types.generic.Value.substitute)\n[`ibis.cases()`](./expression-generic.qmd#ibis.cases)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"left\": [5, 6, 7, 8, 9, 10],\n...         \"symbol\": [\"+\", \"-\", \"*\", \"/\", \"bogus\", None],\n...         \"right\": [1, 2, 3, 4, 5, 6],\n...     }\n... )\n\nNote that we never hit the `None` case, because `x = NULL` is always\n`NULL`, which is not truthy. If you want to replace `NULL`s, you should use\n`.fill_null(some_value)` prior to `cases()`.\n\n>>> t.mutate(\n...     result=(\n...         t.symbol.cases(\n...             (\"+\", t.left + t.right),\n...             (\"-\", t.left - t.right),\n...             (\"*\", t.left * t.right),\n...             (\"/\", t.left / t.right),\n...             (None, -999),\n...         )\n...     )\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 left  \u2503 symbol \u2503 right \u2503 result  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 int64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     5 \u2502 +      \u2502     1 \u2502     6.0 \u2502\n\u2502     6 \u2502 -      \u2502     2 \u2502     4.0 \u2502\n\u2502     7 \u2502 *      \u2502     3 \u2502    21.0 \u2502\n\u2502     8 \u2502 /      \u2502     4 \u2502     2.0 \u2502\n\u2502     9 \u2502 bogus  \u2502     5 \u2502    NULL \u2502\n\u2502    10 \u2502 NULL   \u2502     6 \u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::collect", "docstring": "Aggregate this expression's elements into an array.\n\nThis function is called `array_agg`, `list_agg`, or `list` in other systems.\n\nParameters\n----------\nwhere\n    An optional filter expression. If provided, only rows where `where`\n    is `True` will be included in the aggregate.\norder_by\n    An ordering key (or keys) to use to order the rows before\n    aggregating. If not provided, the order of the items in the result\n    is undefined and backend specific.\ninclude_null\n    Whether to include null values when performing this aggregation. Set\n    to `True` to include nulls in the result.\ndistinct\n    Whether to collect only distinct elements.\n\nReturns\n-------\nArrayScalar\n    An array of all the collected elements.\n\nExamples\n--------\nBasic collect usage\n\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"key\": list(\"aaabb\"), \"value\": [1, 1, 2, 3, 5]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 key    \u2503 value \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502\n\u2502 a      \u2502     1 \u2502\n\u2502 a      \u2502     2 \u2502\n\u2502 b      \u2502     3 \u2502\n\u2502 b      \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCollect all elements into an array scalar:\n\n>>> t.value.collect().to_pandas()\n[1, 1, 2, 3, 5]\n\nCollect only unique elements:\n\n>>> t.value.collect(distinct=True).to_pandas()  # doctest: +SKIP\n[1, 2, 3, 5]\n\nCollect elements in a specified order:\n\n>>> t.value.collect(order_by=_.value.desc()).to_pandas()\n[5, 3, 2, 1, 1]\n\nCollect elements per group, filtering out values <= 1:\n\n>>> t.group_by(\"key\").agg(v=t.value.collect(where=_.value > 1)).order_by(\"key\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 key    \u2503 v                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 array<int64>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 [2]                  \u2502\n\u2502 b      \u2502 [3, 5]               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::identical_to", "docstring": "Return whether this expression is identical to other.\n\nCorresponds to `IS NOT DISTINCT FROM` in SQL.\n\nParameters\n----------\nother\n    Expression to compare to\n\nReturns\n-------\nBooleanValue\n    Whether this expression is not distinct from `other`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> one = ibis.literal(1)\n>>> two = ibis.literal(2)\n>>> two.identical_to(one + one)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 True \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::group_concat", "docstring": "Concatenate values using the indicated separator to produce a string.\n\nParameters\n----------\nsep\n    The separator to use to join strings.\nwhere\n    An optional filter expression. If provided, only rows where `where`\n    is `True` will be included in the aggregate.\norder_by\n    An ordering key (or keys) to use to order the rows before\n    aggregating. If not provided, the order of the items in the result\n    is undefined and backend specific.\n\nReturns\n-------\nStringScalar\n    Concatenated string expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().limit(5)\n>>> t[[\"bill_length_mm\", \"bill_depth_mm\"]]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503 bill_depth_mm \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           39.1 \u2502          18.7 \u2502\n\u2502           39.5 \u2502          17.4 \u2502\n\u2502           40.3 \u2502          18.0 \u2502\n\u2502           NULL \u2502          NULL \u2502\n\u2502           36.7 \u2502          19.3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.bill_length_mm.group_concat()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 39.1,39.5,40.3,36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.bill_length_mm.group_concat(sep=\": \")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 39.1: 39.5: 40.3: 36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.bill_length_mm.group_concat(sep=\": \", where=t.bill_depth_mm > 18)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 39.1: 36.7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::asc", "docstring": "Sort an expression in ascending order.\n\nParameters\n----------\nnulls_first\n    Whether to sort `NULL` values first\n\nReturns\n-------\nValue\n    Sorted expression\n\nSee Also\n--------\n[`ibis.asc()`](./expression-generic.qmd#ibis.asc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2, 3, None]})\n>>> t.order_by(t.a.asc())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1.0 \u2502\n\u2502     2.0 \u2502\n\u2502     3.0 \u2502\n\u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.order_by(t.a.asc(nulls_first=True))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502\n\u2502     1.0 \u2502\n\u2502     2.0 \u2502\n\u2502     3.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::desc", "docstring": "Sort an expression in descending order.\n\nParameters\n----------\nnulls_first\n    Whether to sort `NULL` values first.\n\nReturns\n-------\nValue\n    Sorted expression\n\nSee Also\n--------\n[`ibis.desc()`](./expression-generic.qmd#ibis.desc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2, 3, None]})\n>>> t.order_by(t.a.desc())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3.0 \u2502\n\u2502     2.0 \u2502\n\u2502     1.0 \u2502\n\u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.order_by(t.a.desc(nulls_first=True))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502\n\u2502     3.0 \u2502\n\u2502     2.0 \u2502\n\u2502     1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::to_pandas", "docstring": "Convert a table expression to a pandas DataFrame.\n\nParameters\n----------\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nDataFrame\n    The result of executing the expression as a pandas DataFrame", "type": "function"}
{"source": "ibis/expr/types/generic.py::as_scalar", "docstring": "Inform ibis that the expression should be treated as a scalar.\n\nIf the expression is a literal, it will be returned as is. If it depends\non a table, it will be turned to a scalar subquery.\n\nReturns\n-------\nScalar\n    A scalar subquery or a literal\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> max_gentoo_weight = t.filter(t.species == \"Gentoo\").body_mass_g.max()\n>>> light_penguins = t.filter(t.body_mass_g < max_gentoo_weight / 2)\n>>> light_penguins.species.value_counts().order_by(\"species\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species   \u2503 species_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie    \u2502            15 \u2502\n\u2502 Chinstrap \u2502             2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::as_table", "docstring": "Promote the scalar expression to a table.\n\nReturns\n-------\nTable\n    A table expression\n\nExamples\n--------\nPromote an aggregation to a table\n\n>>> import ibis\n>>> import ibis.expr.types as ir\n>>> t = ibis.table(dict(a=\"str\"), name=\"t\")\n>>> expr = t.a.length().sum().name(\"len\").as_table()\n>>> isinstance(expr, ir.Table)\nTrue\n\nPromote a literal value to a table\n\n>>> import ibis.expr.types as ir\n>>> lit = ibis.literal(1).name(\"a\").as_table()\n>>> isinstance(lit, ir.Table)\nTrue", "type": "function"}
{"source": "ibis/expr/types/generic.py::preview", "docstring": "Print a subset as a single-column Rich Table.\n\nThis is an explicit version of what you get when you inspect\nthis object in interactive mode, except with this version you\ncan pass formatting options. The options are the same as those exposed\nin `ibis.options.interactive`.\n\nParameters\n----------\nmax_rows\n    Maximum number of rows to display\nmax_length\n    Maximum length for pretty-printed arrays and maps.\nmax_string\n    Maximum length for pretty-printed strings.\nmax_depth\n    Maximum depth for nested data types.\nconsole_width\n    Width of the console in characters. If not specified, the width\n    will be inferred from the console.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.examples.penguins.fetch()\n>>> t.island.preview(max_rows=3, max_string=5)  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 stri\u2026  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Torg\u2026  \u2502\n\u2502 Torg\u2026  \u2502\n\u2502 Torg\u2026  \u2502\n\u2502 \u2026      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::as_scalar", "docstring": "Inform ibis that the expression should be treated as a scalar.\n\nCreates a scalar subquery from the column expression. Since ibis cannot\nbe sure that the column expression contains only one value, the column\nexpression is wrapped in a scalar subquery and treated as a scalar.\n\nNote that the execution of the scalar subquery will fail if the column\nexpression contains more than one value.\n\nReturns\n-------\nScalar\n    A scalar subquery\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> heavy_gentoo = t.filter(t.species == \"Gentoo\", t.body_mass_g > 6200)\n>>> from_that_island = t.filter(t.island == heavy_gentoo.island.as_scalar())\n>>> from_that_island.species.value_counts().order_by(\"species\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 species_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502            44 \u2502\n\u2502 Gentoo  \u2502           124 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::as_table", "docstring": "Promote the expression to a [Table](./expression-tables.qmd#ibis.expr.types.Table).\n\nReturns\n-------\nTable\n    A table expression\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table(dict(a=\"str\"), name=\"t\")\n>>> expr = t.a.length().name(\"len\").as_table()\n>>> expected = t.select(len=t.a.length())\n>>> expr.equals(expected)\nTrue", "type": "function"}
{"source": "ibis/expr/types/generic.py::_bind_to_parent_table", "docstring": "Bind an expr to the parent table of `self`.", "type": "function"}
{"source": "ibis/expr/types/generic.py::approx_nunique", "docstring": "Return the approximate number of distinct elements in `self`.\n\n::: {.callout-note}\n## The result may or may not be exact\n\nWhether the result is an approximation depends on the backend.\n\n::: {.callout-warning}\n## Do not depend on the results being exact\n:::\n\n:::\n\nParameters\n----------\nwhere\n    Filter in values when `where` is `True`\n\nReturns\n-------\nScalar\n    An approximate count of the distinct elements of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.approx_nunique()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 92 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.approx_nunique(where=t.species == \"Adelie\")\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 61 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::approx_median", "docstring": "Return an approximate of the median of `self`.\n\n::: {.callout-note}\n## The result may or may not be exact\n\nWhether the result is an approximation depends on the backend.\n\n::: {.callout-warning}\n## Do not depend on the results being exact\n:::\n\n:::\n\nParameters\n----------\nwhere\n    Filter in values when `where` is `True`\n\nReturns\n-------\nScalar\n    An approximation of the median of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.approx_median()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4030.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.approx_median(where=t.species == \"Chinstrap\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3700.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::mode", "docstring": "Return the mode of a column.\n\nParameters\n----------\nwhere\n    Filter in values when `where` is `True`\n\nReturns\n-------\nScalar\n    The mode of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.mode()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3800 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.mode(where=(t.species == \"Gentoo\") & (t.sex == \"male\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5550 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::max", "docstring": "Return the maximum of a column.\n\nParameters\n----------\nwhere\n    Filter in values when `where` is `True`\n\nReturns\n-------\nScalar\n    The maximum value in `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.max()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6300 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.max(where=t.species == \"Chinstrap\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4800 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::min", "docstring": "Return the minimum of a column.\n\nParameters\n----------\nwhere\n    Filter in values when `where` is `True`\n\nReturns\n-------\nScalar\n    The minimum value in `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.min()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2700 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.min(where=t.species == \"Adelie\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2850 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::argmax", "docstring": "Return the value of `self` that maximizes `key`.\n\nIf more than one value maximizes `key`, the returned value is backend\nspecific. The result may be `NULL`.\n\nParameters\n----------\nkey\n    Key to use for `max` computation.\nwhere\n    Keep values when `where` is `True`\n\nReturns\n-------\nScalar\n    The value of `self` that maximizes `key`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.species.argmax(t.body_mass_g)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Gentoo \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.species.argmax(t.body_mass_g, where=t.island == \"Dream\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Chinstrap \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::argmin", "docstring": "Return the value of `self` that minimizes `key`.\n\nIf more than one value minimizes `key`, the returned value is backend\nspecific. The result may be `NULL`.\n\nParameters\n----------\nkey\n    Key to use for `min` computation.\nwhere\n    Keep values when `where` is `True`\n\nReturns\n-------\nScalar\n    The value of `self` that minimizes `key`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.species.argmin(t.body_mass_g)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Chinstrap \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.species.argmin(t.body_mass_g, where=t.island == \"Biscoe\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Adelie \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::median", "docstring": "Return the median of the column.\n\nParameters\n----------\nwhere\n    Optional boolean expression. If given, only the values where\n    `where` evaluates to true will be considered for the median.\n\nReturns\n-------\nScalar\n    Median of the column\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n\nCompute the median of `bill_depth_mm`\n\n>>> t.bill_depth_mm.median()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 17.3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.group_by(t.species).agg(median_bill_depth=t.bill_depth_mm.median()).order_by(\n...     ibis.desc(\"median_bill_depth\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species   \u2503 median_bill_depth \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Chinstrap \u2502             18.45 \u2502\n\u2502 Adelie    \u2502             18.40 \u2502\n\u2502 Gentoo    \u2502             15.00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIn addition to numeric types, any orderable non-numeric types such as\nstrings and dates work with `median`.\n\n>>> t.group_by(t.island).agg(median_species=t.species.median()).order_by(\n...     ibis.desc(\"median_species\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 median_species \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Biscoe    \u2502 Gentoo         \u2502\n\u2502 Dream     \u2502 Chinstrap      \u2502\n\u2502 Torgersen \u2502 Adelie         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::quantile", "docstring": "Return value at the given quantile.\n\nThe output of this method is a continuous quantile if the input is\nnumeric, otherwise the output is a discrete quantile.\n\nParameters\n----------\nquantile\n    `0 <= quantile <= 1`, or an array of such values\n    indicating the quantile or quantiles to compute\nwhere\n    Boolean filter for input values\n\nReturns\n-------\nScalar\n    Quantile of the input\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n\nCompute the 99th percentile of `bill_depth`\n\n>>> t.bill_depth_mm.quantile(0.99)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 21.1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.group_by(t.species).agg(p99_bill_depth=t.bill_depth_mm.quantile(0.99)).order_by(\n...     ibis.desc(\"p99_bill_depth\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species   \u2503 p99_bill_depth \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 float64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie    \u2502         21.200 \u2502\n\u2502 Chinstrap \u2502         20.733 \u2502\n\u2502 Gentoo    \u2502         17.256 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIn addition to numeric types, any orderable non-numeric types such as\nstrings and dates work with `quantile`.\n\nLet's compute the 99th percentile of the `species` column\n\n>>> t.group_by(t.island).agg(p99_species=t.species.quantile(0.99)).order_by(\n...     ibis.desc(\"p99_species\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 island    \u2503 p99_species \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Biscoe    \u2502 Gentoo      \u2502\n\u2502 Dream     \u2502 Chinstrap   \u2502\n\u2502 Torgersen \u2502 Adelie      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::nunique", "docstring": "Compute the number of distinct rows in an expression.\n\nParameters\n----------\nwhere\n    Filter expression\n\nReturns\n-------\nIntegerScalar\n    Number of distinct elements in an expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.nunique()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 94 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> t.body_mass_g.nunique(where=t.species == \"Adelie\")\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 55 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::topk", "docstring": "Computes a Table of the top values by a metric (defaults to count).\n\n::: {.callout-note title=\"Changed in version 9.5.0\"}\nAdded `name` parameter.\n:::\n\nParameters\n----------\nk\n    The number of rows to return.\n    If `None`, all values are returned in descending order.\nby\n    The metric to compute \"top\" by. Defaults to `count`.\nname\n    The name to use for the metric column.\n    If not provided, a suitable name will be generated.\n\nReturns\n-------\nTable\n    The top `k` values.\n\nSee Also\n--------\n[`Column.value_counts`](./expression-generic.qmd#ibis.expr.types.generic.Column.value_counts)\n[`Table.topk`](./expression-tables.qmd#ibis.expr.types.relations.Table.topk)\n[`Table.value_counts`](./expression-tables.qmd#ibis.expr.types.relations.Table.value_counts)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.diamonds.fetch()\n\nCompute the top 3 diamond colors by frequency:\n\n>>> t.color.topk(3)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 color  \u2503 color_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 G      \u2502       11292 \u2502\n\u2502 E      \u2502        9797 \u2502\n\u2502 F      \u2502        9542 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCompute the top 3 diamond colors by mean price:\n\n>>> t.color.topk(3, by=t.price.mean())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 color  \u2503 Mean(price) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 J      \u2502 5323.818020 \u2502\n\u2502 I      \u2502 5091.874954 \u2502\n\u2502 H      \u2502 4486.669196 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRank all the colors by max carat:\n\n>>> t.color.topk(k=5, by=t.carat.max(), name=\"max_carat\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 color  \u2503 max_carat \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 J      \u2502      5.01 \u2502\n\u2502 H      \u2502      4.13 \u2502\n\u2502 I      \u2502      4.01 \u2502\n\u2502 D      \u2502      3.40 \u2502\n\u2502 E      \u2502      3.05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::arbitrary", "docstring": "Select an arbitrary value in a column.\n\nReturns an arbitrary (nondeterministic, backend-specific) value from\nthe column. The value will be non-NULL, except if the column is empty\nor all values are NULL.\n\nParameters\n----------\nwhere\n    A filter expression\n\nReturns\n-------\nScalar\n    An expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2, 2], \"b\": list(\"aaa\"), \"c\": [4.0, 4.1, 4.2]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503 c       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502     4.0 \u2502\n\u2502     2 \u2502 a      \u2502     4.1 \u2502\n\u2502     2 \u2502 a      \u2502     4.2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.group_by(\"a\").agg(arb=t.b.arbitrary(), c=t.c.sum()).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 arb    \u2503 c       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502     4.0 \u2502\n\u2502     2 \u2502 a      \u2502     8.3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::count", "docstring": "Compute the number of rows in an expression.\n\nParameters\n----------\nwhere\n    Filter expression\n\nReturns\n-------\nIntegerScalar\n    Number of elements in an expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"color\": [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Blue\"],\n...     }\n... )\n>>> t.count()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 6 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.count(where=t.color == \"Blue\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 3 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::value_counts", "docstring": "Compute a frequency table.\n\nParameters\n----------\nname\n    The name to use for the frequency column.\n    If not provided, a suitable name will be generated.\n\nReturns\n-------\nTable\n    The frequency table.\n\nSee Also\n--------\n[`Column.topk`](./expression-generic.qmd#ibis.expr.types.generic.Column.topk)\n[`Table.value_counts`](./expression-tables.qmd#ibis.expr.types.relations.Table.value_counts)\n[`Table.topk`](./expression-tables.qmd#ibis.expr.types.relations.Table.topk)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"chars\": [\"a\", \"a\", \"b\", \"c\", \"c\", \"c\", \"d\", \"d\", \"d\", \"d\"]})\n\nCompute the count of each unique value in \"chars\", ordered by \"chars\":\n\n>>> t.chars.value_counts().order_by(\"chars\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 chars  \u2503 chars_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502           2 \u2502\n\u2502 b      \u2502           1 \u2502\n\u2502 c      \u2502           3 \u2502\n\u2502 d      \u2502           4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCompute the count of each unique value in \"chars\" as a column named\n\"freq\", ordered by \"freq\":\n\n>>> t.chars.value_counts(name=\"freq\").order_by(\"freq\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 chars  \u2503 freq  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 b      \u2502     1 \u2502\n\u2502 a      \u2502     2 \u2502\n\u2502 c      \u2502     3 \u2502\n\u2502 d      \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n::: {.callout-note title=\"Added in version 9.5.0\"}\n:::", "type": "function"}
{"source": "ibis/expr/types/generic.py::first", "docstring": "Return the first value of a column.\n\nParameters\n----------\nwhere\n    An optional filter expression. If provided, only rows where `where`\n    is `True` will be included in the aggregate.\norder_by\n    An ordering key (or keys) to use to order the rows before\n    aggregating. If not provided, the meaning of `first` is undefined\n    and will be backend specific.\ninclude_null\n    Whether to include null values when performing this aggregation. Set\n    to `True` to include nulls in the result.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"chars\": [\"a\", \"b\", \"c\", \"d\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 chars  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502\n\u2502 b      \u2502\n\u2502 c      \u2502\n\u2502 d      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.chars.first()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 a \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.chars.first(where=t.chars != \"a\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 b \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::last", "docstring": "Return the last value of a column.\n\nParameters\n----------\nwhere\n    An optional filter expression. If provided, only rows where `where`\n    is `True` will be included in the aggregate.\norder_by\n    An ordering key (or keys) to use to order the rows before\n    aggregating. If not provided, the meaning of `last` is undefined\n    and will be backend specific.\ninclude_null\n    Whether to include null values when performing this aggregation. Set\n    to `True` to include nulls in the result.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"chars\": [\"a\", \"b\", \"c\", \"d\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 chars  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502\n\u2502 b      \u2502\n\u2502 c      \u2502\n\u2502 d      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.chars.last()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 d \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.chars.last(where=t.chars != \"d\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 c \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::rank", "docstring": "Compute position of first element within each equal-value group in sorted order.\n\nEquivalent to SQL's `RANK()` window function.\n\nReturns\n-------\nInt64Column\n    The min rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=t.values.rank())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      3 \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::dense_rank", "docstring": "Position of first element within each group of equal values.\n\nValues are returned in sorted order and duplicate values are ignored.\n\nEquivalent to SQL's `DENSE_RANK()`.\n\nReturns\n-------\nIntegerColumn\n    The rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=t.values.dense_rank())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      3 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::percent_rank", "docstring": "Return the relative rank of the values in the column.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(percent_rank=t.values.percent_rank())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 percent_rank \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502          0.0 \u2502\n\u2502      1 \u2502          0.0 \u2502\n\u2502      2 \u2502          0.4 \u2502\n\u2502      2 \u2502          0.4 \u2502\n\u2502      2 \u2502          0.4 \u2502\n\u2502      3 \u2502          1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::cume_dist", "docstring": "Return the cumulative distribution over a window.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(cume_dist=t.values.cume_dist())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 cume_dist \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502  0.333333 \u2502\n\u2502      1 \u2502  0.333333 \u2502\n\u2502      2 \u2502  0.833333 \u2502\n\u2502      2 \u2502  0.833333 \u2502\n\u2502      2 \u2502  0.833333 \u2502\n\u2502      3 \u2502  1.000000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::ntile", "docstring": "Return the integer number of a partitioning of the column values.\n\nParameters\n----------\nbuckets\n    Number of buckets to partition into\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(ntile=t.values.ntile(3))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 ntile \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      3 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::cummin", "docstring": "Return the cumulative min over a window.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(cummin=t.values.cummin())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummin \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      2 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      1 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      1 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      1 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502      1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(cummin=t.values.cummin(where=t.grouper != \"c\", group_by=t.grouper)).order_by(\n...     t.id\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummin \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      2 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      1 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      2 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      2 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502   NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::cummax", "docstring": "Return the cumulative max over a window.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(cummax=t.values.cummax())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummax \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      3 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      3 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      3 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      3 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502      3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(cummax=t.values.cummax(where=t.grouper != \"c\", group_by=t.grouper)).order_by(\n...     t.id\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummax \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      3 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      3 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      2 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      3 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502   NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::lag", "docstring": "Return the row located at `offset` rows **before** the current row.\n\nParameters\n----------\noffset\n    Index of row to select\ndefault\n    Value used if no row exists at `offset`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\"year\": [2007, 2008, 2009, 2010], \"total\": [1899.6, 1928.2, 2037.9, 1955.2]}\n... )\n>>> t.mutate(total_lead=t.total.lag())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 total   \u2503 total_lead \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64 \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502  1899.6 \u2502       NULL \u2502\n\u2502  2008 \u2502  1928.2 \u2502     1899.6 \u2502\n\u2502  2009 \u2502  2037.9 \u2502     1928.2 \u2502\n\u2502  2010 \u2502  1955.2 \u2502     2037.9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(total_lead=t.total.lag(2, 0))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 total   \u2503 total_lead \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64 \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502  1899.6 \u2502        0.0 \u2502\n\u2502  2008 \u2502  1928.2 \u2502        0.0 \u2502\n\u2502  2009 \u2502  2037.9 \u2502     1899.6 \u2502\n\u2502  2010 \u2502  1955.2 \u2502     1928.2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::lead", "docstring": "Return the row located at `offset` rows **after** the current row.\n\nParameters\n----------\noffset\n    Index of row to select\ndefault\n    Value used if no row exists at `offset`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\"year\": [2007, 2008, 2009, 2010], \"total\": [1899.6, 1928.2, 2037.9, 1955.2]}\n... )\n>>> t.mutate(total_lead=t.total.lead())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 total   \u2503 total_lead \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64 \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502  1899.6 \u2502     1928.2 \u2502\n\u2502  2008 \u2502  1928.2 \u2502     2037.9 \u2502\n\u2502  2009 \u2502  2037.9 \u2502     1955.2 \u2502\n\u2502  2010 \u2502  1955.2 \u2502       NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(total_lead=t.total.lead(2, 0))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 year  \u2503 total   \u2503 total_lead \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64 \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2007 \u2502  1899.6 \u2502     2037.9 \u2502\n\u2502  2008 \u2502  1928.2 \u2502     1955.2 \u2502\n\u2502  2009 \u2502  2037.9 \u2502        0.0 \u2502\n\u2502  2010 \u2502  1955.2 \u2502        0.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::nth", "docstring": "Return the `n`th value (0-indexed) over a window.\n\n`.nth(0)` is equivalent to `.first()`. Negative will result in `NULL`.\nIf the value of `n` is greater than the number of rows in the window,\n`NULL` will be returned.\n\nParameters\n----------\nn\n    Desired rank value\n\nReturns\n-------\nColumn\n    The nth value over a window\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 3, 4, 5, 6]})\n>>> t.mutate(nth=t.values.nth(2))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 nth   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     3 \u2502\n\u2502      2 \u2502     3 \u2502\n\u2502      3 \u2502     3 \u2502\n\u2502      4 \u2502     3 \u2502\n\u2502      5 \u2502     3 \u2502\n\u2502      6 \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(nth=t.values.nth(7))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 nth   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502  NULL \u2502\n\u2502      2 \u2502  NULL \u2502\n\u2502      3 \u2502  NULL \u2502\n\u2502      4 \u2502  NULL \u2502\n\u2502      5 \u2502  NULL \u2502\n\u2502      6 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/generic.py::to_list", "docstring": "Convert a column expression to a list.\n\nParameters\n----------\nkwargs\n    Same as keyword arguments to [`to_pyarrow`](#ibis.expr.types.core.Expr.to_pyarrow)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.bill_length_mm.to_list(limit=5)\n[39.1, 39.5, 40.3, None, 36.7]\n\n::: {.callout-note title=\"Added in version 10.0.0\"}\n:::", "type": "function"}
{"source": "ibis/expr/types/core.py::Expr", "docstring": "Base expression class.", "type": "class"}
{"source": "ibis/expr/types/core.py::_binop", "docstring": "Try to construct a binary operation.\n\nParameters\n----------\nop_class\n    The `ops.Binary` subclass for the operation\nleft\n    Left operand\nright\n    Right operand\n\nReturns\n-------\nir.Value\n    A value expression\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.expr.operations as ops\n>>> expr = _binop(ops.TimeAdd, ibis.time(\"01:00\"), ibis.interval(hours=1))\n>>> expr\nTimeAdd(datetime.time(1, 0), 1h): datetime.time(1, 0) + 1 h\n>>> _binop(ops.TimeAdd, 1, ibis.interval(hours=1))\nTimeAdd(datetime.time(0, 0, 1), 1h): datetime.time(0, 0, 1) + 1 h", "type": "function"}
{"source": "ibis/expr/types/core.py::equals", "docstring": "Return whether this expression is _structurally_ equivalent to `other`.\n\nIf you want to produce an equality expression, use `==` syntax.\n\nParameters\n----------\nother\n    Another expression\n\nExamples\n--------\n>>> import ibis\n>>> t1 = ibis.table(dict(a=\"int\"), name=\"t\")\n>>> t2 = ibis.table(dict(a=\"int\"), name=\"t\")\n>>> t1.equals(t2)\nTrue\n>>> v = ibis.table(dict(a=\"string\"), name=\"v\")\n>>> t1.equals(v)\nFalse", "type": "function"}
{"source": "ibis/expr/types/core.py::get_name", "docstring": "Return the name of this expression.", "type": "function"}
{"source": "ibis/expr/types/core.py::visualize", "docstring": "Visualize an expression as a GraphViz graph in the browser.\n\nParameters\n----------\nformat\n    Image output format. These are specified by the `graphviz` Python\n    library.\nlabel_edges\n    Show operation input names as edge labels\nverbose\n    Print the graphviz DOT code to stderr if [](`True`)\nnode_attr\n    Mapping of `(attribute, value)` pairs set for all nodes.\n    Options are specified by the `graphviz` Python library.\nnode_attr_getter\n    Callback taking a node and returning a mapping of `(attribute, value)` pairs\n    for that node. Options are specified by the `graphviz` Python library.\nedge_attr\n    Mapping of `(attribute, value)` pairs set for all edges.\n    Options are specified by the `graphviz` Python library.\nedge_attr_getter\n    Callback taking two adjacent nodes and returning a mapping of `(attribute, value)` pairs\n    for the edge between those nodes. Options are specified by the `graphviz` Python library.\n\nExamples\n--------\nOpen the visualization of an expression in default browser:\n\n>>> import ibis\n>>> import ibis.expr.operations as ops\n>>> left = ibis.table(dict(a=\"int64\", b=\"string\"), name=\"left\")\n>>> right = ibis.table(dict(b=\"string\", c=\"int64\", d=\"string\"), name=\"right\")\n>>> expr = left.inner_join(right, \"b\").select(left.a, b=right.c, c=right.d)\n>>> expr.visualize(\n...     format=\"svg\",\n...     label_edges=True,\n...     node_attr={\"fontname\": \"Roboto Mono\", \"fontsize\": \"10\"},\n...     node_attr_getter=lambda node: isinstance(node, ops.Field) and {\"shape\": \"oval\"},\n...     edge_attr={\"fontsize\": \"8\"},\n...     edge_attr_getter=lambda u, v: isinstance(u, ops.Field) and {\"color\": \"red\"},\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nRaises\n------\nImportError\n    If `graphviz` is not installed.", "type": "function"}
{"source": "ibis/expr/types/core.py::pipe", "docstring": "Compose `f` with `self`.\n\nParameters\n----------\nf\n    If the expression needs to be passed as anything other than the\n    first argument to the function, pass a tuple with the argument\n    name. For example, (f, 'data') if the function f expects a 'data'\n    keyword\nargs\n    Positional arguments to `f`\nkwargs\n    Keyword arguments to `f`\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.memtable(\n...     {\n...         \"a\": [5, 10, 15],\n...         \"b\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n>>> f = lambda a: (a + 1).name(\"a\")\n>>> g = lambda a: (a * 2).name(\"a\")\n>>> result1 = t.a.pipe(f).pipe(g)\n>>> result1\nr0 := InMemoryTable\ndata:\n    PandasDataFrameProxy:\n        a  b\n    0   5  a\n    1  10  b\n    2  15  c\na: r0.a + 1 * 2\n\n>>> result2 = g(f(t.a))  # equivalent to the above\n>>> result1.equals(result2)\nTrue\n\nReturns\n-------\nExpr\n    Result type of passed function", "type": "function"}
{"source": "ibis/expr/types/core.py::_find_backends", "docstring": "Return the possible backends for an expression.\n\nReturns\n-------\nlist[BaseBackend]\n    A list of the backends found.", "type": "function"}
{"source": "ibis/expr/types/core.py::_find_backend", "docstring": "Find the backend attached to an expression.\n\nParameters\n----------\nuse_default\n    If [](`True`) and the default backend isn't set, initialize the\n    default backend and use that. This should only be set to `True` for\n    `.execute()`. For other contexts such as compilation, this option\n    doesn't make sense so the default value is [](`False`).\n\nReturns\n-------\nBaseBackend\n    A backend that is attached to the expression", "type": "function"}
{"source": "ibis/expr/types/core.py::get_backend", "docstring": "Get the current Ibis backend of the expression.\n\nReturns\n-------\nBaseBackend\n    The Ibis backend.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.duckdb.connect()\n>>> t = con.create_table(\"t\", {\"id\": [1, 2, 3]})\n>>> t.get_backend()  # doctest: +ELLIPSIS\n<ibis.backends.duckdb.Backend object at 0x...>\n\nSee Also\n--------\n[`ibis.get_backend()`](./connection.qmd#ibis.get_backend)", "type": "function"}
{"source": "ibis/expr/types/core.py::execute", "docstring": "Execute an expression against its backend if one exists.\n\nParameters\n----------\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value\nkwargs\n    Keyword arguments\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.examples.penguins.fetch()\n>>> t.execute()\n       species     island  bill_length_mm  ...  body_mass_g     sex  year\n0       Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1       Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2       Adelie  Torgersen            40.3  ...       3250.0  female  2007\n3       Adelie  Torgersen             NaN  ...          NaN    None  2007\n4       Adelie  Torgersen            36.7  ...       3450.0  female  2007\n..         ...        ...             ...  ...          ...     ...   ...\n339  Chinstrap      Dream            55.8  ...       4000.0    male  2009\n340  Chinstrap      Dream            43.5  ...       3400.0  female  2009\n341  Chinstrap      Dream            49.6  ...       3775.0    male  2009\n342  Chinstrap      Dream            50.8  ...       4100.0    male  2009\n343  Chinstrap      Dream            50.2  ...       3775.0  female  2009\n[344 rows x 8 columns]\n\nScalar parameters can be supplied dynamically during execution.\n>>> species = ibis.param(\"string\")\n>>> expr = t.filter(t.species == species).order_by(t.bill_length_mm)\n>>> expr.execute(limit=3, params={species: \"Gentoo\"})\n  species  island  bill_length_mm  ...  body_mass_g     sex  year\n0  Gentoo  Biscoe            40.9  ...         4650  female  2007\n1  Gentoo  Biscoe            41.7  ...         4700  female  2009\n2  Gentoo  Biscoe            42.0  ...         4150  female  2007\n<BLANKLINE>\n[3 rows x 8 columns]\n\nSee Also\n--------\n[`Table.to_pandas()`](./expression-tables.qmd#ibis.expr.types.relations.Table.to_pandas)\n[`Value.to_pandas()`](./expression-generic.qmd#ibis.expr.types.generic.Value.to_pandas)", "type": "function"}
{"source": "ibis/expr/types/core.py::to_sql", "docstring": "Compile to a formatted SQL string.\n\nParameters\n----------\ndialect\n    SQL dialect to use for compilation.\n    Uses the dialect bound to self if not specified,\n    or the default dialect if no dialect is bound.\npretty\n    Whether to use pretty formatting.\nkwargs\n    Scalar parameters\n\nReturns\n-------\nstr\n    Formatted SQL string\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table({\"a\": \"int\", \"b\": \"int\"}, name=\"t\")\n>>> expr = t.mutate(c=t.a + t.b)\n>>> expr.to_sql()  # doctest: +SKIP\nSELECT\n  \"t0\".\"a\",\n  \"t0\".\"b\",\n  \"t0\".\"a\" + \"t0\".\"b\" AS \"c\"\nFROM \"t\" AS \"t0\"\n\nYou can also specify the SQL dialect to use for compilation:\n>>> expr.to_sql(dialect=\"mysql\")  # doctest: +SKIP\nSELECT\n  `t0`.`a`,\n  `t0`.`b`,\n  `t0`.`a` + `t0`.`b` AS `c`\nFROM `t` AS `t0`\n\nSee Also\n--------\n[`Value.to_sql()`](./expression-generic.qmd#ibis.expr.types.generic.Value.to_sql)\n[`Table.to_sql()`](./expression-tables.qmd#ibis.expr.types.relations.Table.to_sql)\n[`ibis.to_sql()`](./expression-generic.qmd#ibis.to_sql)\n[`Value.compile()`](./expression-generic.qmd#ibis.expr.types.generic.Value.compile)\n[`Table.compile()`](./expression-tables.qmd#ibis.expr.types.relations.Table.compile)", "type": "function"}
{"source": "ibis/expr/types/core.py::compile", "docstring": "Compile `expr` to a SQL string (for SQL backends) or a LazyFrame (for the polars backend).\n\nParameters\n----------\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value\npretty\n    In case of SQL backends, return a pretty formatted SQL query.\n\nReturns\n-------\nstr | pl.LazyFrame\n    A SQL string or a LazyFrame object, depending on the backend of self.\n\nExamples\n--------\n>>> import ibis\n>>> d = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n>>> con = ibis.duckdb.connect()\n>>> t = con.create_table(\"t\", d)\n>>> expr = t.mutate(c=t.a + t.b)\n>>> expr.compile()\n'SELECT \"t0\".\"a\", \"t0\".\"b\", \"t0\".\"a\" + \"t0\".\"b\" AS \"c\" FROM \"memory\".\"main\".\"t\" AS \"t0\"'\n\nIf you want to see the pretty formatted SQL query, set `pretty` to `True`.\n>>> expr.compile(pretty=True)\n'SELECT\\n  \"t0\".\"a\",\\n  \"t0\".\"b\",\\n  \"t0\".\"a\" + \"t0\".\"b\" AS \"c\"\\nFROM \"memory\".\"main\".\"t\" AS \"t0\"'\n\nIf the expression does not have a backend, an error will be raised.\n>>> t = ibis.memtable(d)\n>>> expr = t.mutate(c=t.a + t.b)\n>>> expr.compile()  # quartodoc: +EXPECTED_FAILURE\nTraceback (most recent call last):\n...\nibis.common.exceptions.IbisError: Expression depends on no backends, and ...\n\nSee Also\n--------\n[`Value.compile()`](./expression-generic.qmd#ibis.expr.types.generic.Value.compile)\n[`Table.compile()`](./expression-tables.qmd#ibis.expr.types.relations.Table.compile)\n[`Value.to_sql()`](./expression-generic.qmd#ibis.expr.types.generic.Value.to_sql)\n[`Table.to_sql()`](./expression-tables.qmd#ibis.expr.types.relations.Table.to_sql)", "type": "function"}
{"source": "ibis/expr/types/core.py::to_pyarrow_batches", "docstring": "Execute expression and return a RecordBatchReader.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nchunk_size\n    Maximum number of rows in each returned record batch.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresults\n    RecordBatchReader", "type": "function"}
{"source": "ibis/expr/types/core.py::to_pyarrow", "docstring": "Execute expression to a pyarrow object.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresult\n    If the passed expression is a Table, a pyarrow table is returned.\n    If the passed expression is a Column, a pyarrow array is returned.\n    If the passed expression is a Scalar, a pyarrow scalar is returned.", "type": "function"}
{"source": "ibis/expr/types/core.py::to_polars", "docstring": "Execute expression and return results as a polars dataframe.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nDataFrame\n    A polars dataframe holding the results of the executed expression.", "type": "function"}
{"source": "ibis/expr/types/core.py::to_pandas_batches", "docstring": "Execute expression and return an iterator of pandas DataFrames.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nchunk_size\n    Maximum number of rows in each returned `DataFrame`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nIterator[pd.DataFrame]", "type": "function"}
{"source": "ibis/expr/types/core.py::to_parquet", "docstring": "Write the results of executing the given expression to a parquet file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nSee https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetWriter.html for details.\n\nParameters\n----------\npath\n    A string or Path where the Parquet file will be written.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.parquet.ParquetWriter\n\nExamples\n--------\nWrite out an expression to a single parquet file.\n\n>>> import ibis\n>>> import tempfile\n>>> penguins = ibis.examples.penguins.fetch()\n>>> penguins.to_parquet(tempfile.mktemp())\n\nPartition on a single column.\n\n>>> penguins.to_parquet(tempfile.mkdtemp(), partition_by=\"year\")\n\nPartition on multiple columns.\n\n>>> penguins.to_parquet(tempfile.mkdtemp(), partition_by=(\"year\", \"island\"))\n\n::: {.callout-note}\n## Hive-partitioned output is currently only supported when using DuckDB\n:::", "type": "function"}
{"source": "ibis/expr/types/core.py::to_xlsx", "docstring": "Write a table to an Excel file.\n\nParameters\n----------\npath\n    Excel output path.\nsheet\n    The name of the sheet to write to, eg 'Sheet3'.\nheader\n    Whether to include the column names as the first row.\nparams\n    Additional Ibis expression parameters to pass to the backend's\n    write function.\nkwargs\n    Additional arguments passed to the backend's write function.\n\nNotes\n-----\nRequires DuckDB >= 1.2.0.\n\nSee Also\n--------\n[DuckDB's `excel` extension docs for writing](https://duckdb.org/docs/stable/extensions/excel.html#writing-xlsx-files)\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> con = ibis.duckdb.connect()\n>>> t = con.create_table(\n...     \"t\",\n...     ibis.memtable({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]}),\n...     temp=True,\n... )\n>>> t.to_xlsx(\"/tmp/test.xlsx\")\n>>> os.path.exists(\"/tmp/test.xlsx\")\nTrue", "type": "function"}
{"source": "ibis/expr/types/core.py::to_parquet_dir", "docstring": "Write the results of executing the given expression to a parquet file in a directory.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nSee https://arrow.apache.org/docs/python/generated/pyarrow.dataset.write_dataset.html for details.\n\nParameters\n----------\ndirectory\n    The data target. A string or Path to the directory where the parquet file will be written.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.dataset.write_dataset", "type": "function"}
{"source": "ibis/expr/types/core.py::to_csv", "docstring": "Write the results of executing the given expression to a CSV file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nSee https://arrow.apache.org/docs/python/generated/pyarrow.csv.CSVWriter.html for details.\n\nParameters\n----------\npath\n    The data target. A string or Path where the CSV file will be written.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.csv.CSVWriter", "type": "function"}
{"source": "ibis/expr/types/core.py::to_delta", "docstring": "Write the results of executing the given expression to a Delta Lake table.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\npath\n    The data target. A string or Path to the Delta Lake table directory.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to deltalake.writer.write_deltalake method", "type": "function"}
{"source": "ibis/expr/types/core.py::to_json", "docstring": "Write the results of `expr` to a json file of [{column -> value}, ...] objects.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\npath\n    The data target. A string or Path where the JSON file will be written.\nkwargs\n    Additional, backend-specific keyword arguments.", "type": "function"}
{"source": "ibis/expr/types/core.py::to_torch", "docstring": "Execute an expression and return results as a dictionary of torch tensors.\n\nParameters\n----------\nparams\n    Parameters to substitute into the expression.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nkwargs\n    Keyword arguments passed into the backend's `to_torch` implementation.\n\nReturns\n-------\ndict[str, torch.Tensor]\n    A dictionary of torch tensors, keyed by column name.", "type": "function"}
{"source": "ibis/expr/types/core.py::unbind", "docstring": "Return an expression built on `UnboundTable` instead of backend-specific objects.\n\nExamples\n--------\n>>> import ibis\n>>> import pandas as pd\n>>> duckdb_con = ibis.duckdb.connect()\n>>> polars_con = ibis.polars.connect()\n>>> for backend in (duckdb_con, polars_con):\n...     t = backend.create_table(\"t\", pd.DataFrame({\"a\": [1, 2, 3]}))\n>>> bound_table = duckdb_con.table(\"t\")\n>>> bound_table.get_backend().name\n'duckdb'\n>>> unbound_table = bound_table.unbind()\n>>> polars_con.execute(unbound_table)\n   a\n0  1\n1  2\n2  3", "type": "function"}
{"source": "ibis/expr/types/core.py::as_table", "docstring": "Convert an expression to a table.", "type": "function"}
{"source": "ibis/expr/types/core.py::as_scalar", "docstring": "Convert an expression to a scalar.", "type": "function"}
{"source": "ibis/expr/types/rich.py::capture_rich_renderable", "docstring": "Convert a rich renderable (has a __rich_console__(), etc) to a string.", "type": "function"}
{"source": "ibis/expr/types/rich.py::to_rich", "docstring": "Truncate, evaluate, and render an Ibis expression as a rich object.", "type": "function"}
{"source": "ibis/expr/types/rich.py::_with_rich_display_disabled", "docstring": "Workaround to keep rich from doing spurious display() calls in Jupyter.\n\nWhen you display(ibis.Table), without this, an extra output cell is created\nin the notebook. With this, there is no extra output cell.\n\nSee https://github.com/Textualize/rich/pull/3329", "type": "function"}
{"source": "ibis/expr/types/rich.py::FixedTextJupyterMixin", "docstring": "JupyterMixin adds a spurious newline to text, this fixes the issue.", "type": "class"}
{"source": "ibis/expr/types/rich.py::FixedTextJupyterMixin", "docstring": "No-op when rich is not installed.", "type": "class"}
{"source": "ibis/expr/types/dataframe_interchange.py::IbisDataFrame", "docstring": "An implementation of the dataframe interchange protocol.\n\nThis is a thin shim around the pyarrow implementation to allow for:\n\n- Accessing a few of the metadata queries without executing the expression.\n- Caching the execution on the dataframe object to avoid re-execution if\n  multiple methods are accessed.\n\nThe dataframe interchange protocol may be found here:\nhttps://data-apis.org/dataframe-protocol/latest/API.html", "type": "class"}
{"source": "ibis/expr/types/dataframe_interchange.py::_pyarrow_df", "docstring": "Returns the pyarrow implementation of the __dataframe__ protocol.\n\nIf the backing ibis Table hasn't been executed yet, this will result\nin executing and caching the result.", "type": "function"}
{"source": "ibis/expr/types/dataframe_interchange.py::_empty_pyarrow_df", "docstring": "A pyarrow implementation of the __dataframe__ protocol for an empty table.\n\nUsed for returning dtype information without executing the backing ibis\nexpression.", "type": "function"}
{"source": "ibis/expr/types/dataframe_interchange.py::_get_dtype", "docstring": "Get the dtype info for a column named `name`.", "type": "function"}
{"source": "ibis/expr/types/dataframe_interchange.py::_pyarrow_col", "docstring": "Returns the pyarrow implementation of the __dataframe__ protocol's Column type.\n\nIf the backing ibis Table hasn't been executed yet, this will result\nin executing and caching the result.", "type": "function"}
{"source": "ibis/expr/types/structs.py::struct", "docstring": "Create a struct expression.\n\nIf any of the inputs are Columns, then the output will be a `StructColumn`.\nOtherwise, the output will be a `StructScalar`.\n\nParameters\n----------\nvalue\n    Either a `{str: Value}` mapping, or an iterable of tuples of the form\n    `(str, Value)`.\ntype\n    An instance of `ibis.expr.datatypes.DataType` or a string indicating\n    the Ibis type of `value`. This is only used if all of the input values\n    are Python literals. eg `struct<a: float, b: string>`.\n\nReturns\n-------\nStructValue\n    An StructScalar or StructColumn expression.\n\nExamples\n--------\nCreate a struct scalar literal from a `dict` with the type inferred\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.struct(dict(a=1, b=\"foo\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 {'a': 1, 'b': 'foo'} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSpecify a type (note the 1 is now a `float`):\n\n>>> ibis.struct(dict(a=1, b=\"foo\"), type=\"struct<a: float, b: string>\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 {'a': 1.0, 'b': 'foo'} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a struct column from a column and a scalar literal\n\n>>> t = ibis.memtable({\"a\": [1, 2, 3]})\n>>> ibis.struct([(\"a\", t.a), (\"b\", \"foo\")])\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StructColumn({'a': a, 'b': 'foo'}) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 struct<a: int64, b: string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 'foo'}               \u2502\n\u2502 {'a': 2, 'b': 'foo'}               \u2502\n\u2502 {'a': 3, 'b': 'foo'}               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/structs.py::StructValue", "docstring": "A Struct is a nested type with ordered fields of any type.\n\nFor example, a Struct might have a field `a` of type `int64` and a field `b`\nof type `string`.\n\nStructs can be constructed with [`ibis.struct()`](#ibis.expr.types.struct).\n\nExamples\n--------\nConstruct a `Struct` column with fields `a: int64` and `b: string`\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [{\"a\": 1, \"b\": \"foo\"}, {\"a\": 3, \"b\": None}, None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s                           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 struct<a: int64, b: string> \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 'foo'}        \u2502\n\u2502 {'a': 3, 'b': None}         \u2502\n\u2502 NULL                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can use dot notation (`.`) or square-bracket syntax (`[]`) to access\nstruct column fields\n\n>>> t.s.a\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s[\"a\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "class"}
{"source": "ibis/expr/types/structs.py::__getitem__", "docstring": "Extract the `name` field from this struct.\n\nParameters\n----------\nname\n    The name of the field to access.\n\nReturns\n-------\nValue\n    An expression with the type of the field being accessed.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [{\"a\": 1, \"b\": \"foo\"}, {\"a\": 3, \"b\": None}, None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s                           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 struct<a: int64, b: string> \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 'foo'}        \u2502\n\u2502 {'a': 3, 'b': None}         \u2502\n\u2502 NULL                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s[\"a\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s[\"b\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 foo    \u2502\n\u2502 NULL   \u2502\n\u2502 NULL   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s[\"foo_bar\"]\nTraceback (most recent call last):\n    ...\nKeyError: 'foo_bar'", "type": "function"}
{"source": "ibis/expr/types/structs.py::__getattr__", "docstring": "Extract the `name` field from this struct.\n\nParameters\n----------\nname\n    The name of the field to access.\n\nReturns\n-------\nValue\n    An expression with the type of the field being accessed.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [{\"a\": 1, \"b\": \"foo\"}, {\"a\": 3, \"b\": None}, None]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s                           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 struct<a: int64, b: string> \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1, 'b': 'foo'}        \u2502\n\u2502 {'a': 3, 'b': None}         \u2502\n\u2502 NULL                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.a\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.b\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 foo    \u2502\n\u2502 NULL   \u2502\n\u2502 NULL   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.foo_bar\nTraceback (most recent call last):\n    ...\nAttributeError: foo_bar", "type": "function"}
{"source": "ibis/expr/types/structs.py::names", "docstring": "Return the field names of the struct.", "type": "function"}
{"source": "ibis/expr/types/structs.py::types", "docstring": "Return the field types of the struct.", "type": "function"}
{"source": "ibis/expr/types/structs.py::fields", "docstring": "Return a mapping from field name to field type of the struct.", "type": "function"}
{"source": "ibis/expr/types/structs.py::lift", "docstring": "Project the fields of `self` into a table.\n\nThis method is useful when analyzing data that has deeply nested\nstructs or arrays of structs. `lift` can be chained to avoid repeating\ncolumn names and table references.\n\nReturns\n-------\nTable\n    A projection with this struct expression's fields.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"pos\": [\n...             {\"lat\": 10.1, \"lon\": 30.3},\n...             {\"lat\": 10.2, \"lon\": 30.2},\n...             {\"lat\": 10.3, \"lon\": 30.1},\n...         ]\n...     }\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 pos                                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 struct<lat: float64, lon: float64> \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'lat': 10.1, 'lon': 30.3}         \u2502\n\u2502 {'lat': 10.2, 'lon': 30.2}         \u2502\n\u2502 {'lat': 10.3, 'lon': 30.1}         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.pos.lift()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 lat     \u2503 lon     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    10.1 \u2502    30.3 \u2502\n\u2502    10.2 \u2502    30.2 \u2502\n\u2502    10.3 \u2502    30.1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`Table.unpack`](./expression-tables.qmd#ibis.expr.types.relations.Table.unpack)", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::area", "docstring": "Compute the area of a geospatial value.\n\nReturns\n-------\nFloatingValue\n    The area of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.area()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoArea(geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  7.903953e+07 \u2502\n\u2502  1.439095e+08 \u2502\n\u2502  3.168508e+07 \u2502\n\u2502  8.023733e+06 \u2502\n\u2502  5.041488e+07 \u2502\n\u2502  4.093479e+07 \u2502\n\u2502  3.934104e+07 \u2502\n\u2502  2.682802e+06 \u2502\n\u2502  3.416422e+07 \u2502\n\u2502  4.404143e+07 \u2502\n\u2502             \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::as_binary", "docstring": "Get the geometry as well-known bytes (WKB) without the SRID data.\n\nReturns\n-------\nBinaryValue\n    Binary value", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::as_ewkt", "docstring": "Get the geometry as well-known text (WKT) with the SRID data.\n\nReturns\n-------\nStringValue\n    String value", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::as_text", "docstring": "Get the geometry as well-known text (WKT) without the SRID data.\n\nReturns\n-------\nStringValue\n    String value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.as_text()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoAsText(geom)                                                              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                                                                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 POLYGON ((933100.9183527103 192536.08569720192, 933091.0114800561 192572.17\u2026 \u2502\n\u2502 MULTIPOLYGON (((1033269.2435912937 172126.0078125, 1033439.6426391453 17088\u2026 \u2502\n\u2502 POLYGON ((1026308.7695066631 256767.6975403726, 1026495.5934945047 256638.6\u2026 \u2502\n\u2502 POLYGON ((992073.4667968601 203714.07598876953, 992068.6669922024 203711.50\u2026 \u2502\n\u2502 POLYGON ((935843.3104932606 144283.33585065603, 936046.5648079664 144173.41\u2026 \u2502\n\u2502 POLYGON ((966568.7466657609 158679.85468779504, 966615.255504474 158662.292\u2026 \u2502\n\u2502 POLYGON ((1010804.2179628164 218919.64069513977, 1011049.1648243815 218914.\u2026 \u2502\n\u2502 POLYGON ((1005482.2763733566 221686.46616631746, 1005304.8982993066 221499.\u2026 \u2502\n\u2502 POLYGON ((1043803.993348822 216615.9250395149, 1043849.7083857208 216473.16\u2026 \u2502\n\u2502 POLYGON ((1044355.0717166215 190734.32089698315, 1044612.1216432452 190156.\u2026 \u2502\n\u2502 \u2026                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::as_ewkb", "docstring": "Get the geometry as well-known bytes (WKB) with the SRID data.\n\nReturns\n-------\nBinaryValue\n    WKB value", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::contains", "docstring": "Check if the geometry contains the `right`.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` contains `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n>>> p = shapely.Point(935996.821, 191376.75)  # centroid for zone 1\n>>> plit = ibis.literal(p, \"geometry\")\n>>> t.geom.contains(plit).name(\"contains\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 contains \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True     \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 \u2026        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::contains_properly", "docstring": "Check if the first geometry contains the second one.\n\nExcludes common border points.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether self contains right excluding border points.", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::covers", "docstring": "Check if the first geometry covers the second one.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` covers `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nPolygon area center in zone 1\n\n>>> z1_ctr_buff = shapely.Point(935996.821, 191376.75).buffer(10)\n>>> z1_ctr_buff_lit = ibis.literal(z1_ctr_buff, \"geometry\")\n>>> t.geom.covers(z1_ctr_buff_lit).name(\"covers\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 covers  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True    \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 \u2026       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::covered_by", "docstring": "Check if the first geometry is covered by the second one.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` is covered by `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nPolygon area center in zone 1\n\n>>> pol_big = shapely.Point(935996.821, 191376.75).buffer(10000)\n>>> pol_big_lit = ibis.literal(pol_big, \"geometry\")\n>>> t.geom.covered_by(pol_big_lit).name(\"covered_by\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 covered_by \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True       \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 \u2026          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> pol_small = shapely.Point(935996.821, 191376.75).buffer(100)\n>>> pol_small_lit = ibis.literal(pol_small, \"geometry\")\n>>> t.geom.covered_by(pol_small_lit).name(\"covered_by\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 covered_by \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 \u2026          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::crosses", "docstring": "Check if the geometries have at least one, but not all, interior points in common.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` and `right` have at least one common interior point.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nLine from center of zone 1 to center of zone 2\n\n>>> line = shapely.LineString([[935996.821, 191376.75], [1031085.719, 164018.754]])\n>>> line_lit = ibis.literal(line, \"geometry\")\n>>> t.geom.crosses(line_lit).name(\"crosses\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 crosses \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True    \u2502\n\u2502 True    \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 \u2026       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.filter(t.geom.crosses(line_lit))[[\"zone\", \"LocationID\"]]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 zone                   \u2503 LocationID \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                 \u2502 int32      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Newark Airport         \u2502          1 \u2502\n\u2502 Jamaica Bay            \u2502          2 \u2502\n\u2502 Canarsie               \u2502         39 \u2502\n\u2502 East Flatbush/Farragut \u2502         71 \u2502\n\u2502 Erasmus                \u2502         85 \u2502\n\u2502 Flatbush/Ditmas Park   \u2502         89 \u2502\n\u2502 Flatlands              \u2502         91 \u2502\n\u2502 Green-Wood Cemetery    \u2502        111 \u2502\n\u2502 Sunset Park West       \u2502        228 \u2502\n\u2502 Windsor Terrace        \u2502        257 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::d_fully_within", "docstring": "Check if `self` is entirely within `distance` from `right`.\n\nParameters\n----------\nright\n    Right geometry\ndistance\n    Distance to check\n\nReturns\n-------\nBooleanValue\n    Whether `self` is within a specified distance from `right`.", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::disjoint", "docstring": "Check if the geometries have no points in common.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` and `right` are disjoint\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n>>> p = shapely.Point(935996.821, 191376.75)  # zone 1 centroid\n>>> plit = ibis.literal(p, \"geometry\")\n>>> t.geom.disjoint(plit).name(\"disjoint\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 disjoint \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False    \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 True     \u2502\n\u2502 \u2026        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::d_within", "docstring": "Check if `self` is partially within `distance` from `right`.\n\nParameters\n----------\nright\n    Right geometry\ndistance\n    Distance to check\n\nReturns\n-------\nBooleanValue\n    Whether `self` is partially within `distance` from `right`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n>>> penn_station = shapely.Point(986345.399, 211974.446)\n\nCheck zones within 1000 feet of the Penn Station centroid\n\n>>> t.geom.d_within(penn_station, distance=1000).name(\"d_within_1000\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 d_within_1000 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 False         \u2502\n\u2502 \u2026             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> filtered = t.filter(\n...     t.geom.distance(penn_station) > 0.0,\n...     t.geom.d_within(penn_station, distance=1000),\n... )\n>>> filtered.zone\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 zone          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 East Chelsea  \u2502\n\u2502 Midtown South \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::geo_equals", "docstring": "Check if the geometries are equal.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` equals `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.geo_equals(t.geom)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoEquals(geom, geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 True                  \u2502\n\u2502 \u2026                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::geometry_n", "docstring": "Get the 1-based Nth geometry of a multi geometry.\n\nParameters\n----------\nn\n    Nth geometry index\n\nReturns\n-------\nGeoSpatialValue\n    Geometry value", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::geometry_type", "docstring": "Get the type of a geometry.\n\nReturns\n-------\nStringValue\n    String representing the type of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.geometry_type()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoGeometryType(geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 POLYGON               \u2502\n\u2502 MULTIPOLYGON          \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 POLYGON               \u2502\n\u2502 \u2026                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::intersects", "docstring": "Check if the geometries share any points.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` intersects `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n>>> p = shapely.Point(935996.821, 191376.75)  # zone 1 centroid\n>>> plit = ibis.literal(p, \"geometry\")\n>>> t.geom.intersects(plit).name(\"intersects\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 intersects \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True       \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 False      \u2502\n\u2502 \u2026          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::is_valid", "docstring": "Check if the geometry is valid.\n\nReturns\n-------\nBooleanValue\n    Whether `self` is valid\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.is_valid()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoIsValid(geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 True             \u2502\n\u2502 \u2026                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::ordering_equals", "docstring": "Check if two geometries are equal and have the same point ordering.\n\nReturns true if the two geometries are equal and the coordinates\nare in the same order.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether points and orderings are equal.", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::overlaps", "docstring": "Check if the geometries share space, have the same dimension, and are not completely contained by each other.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Overlaps indicator\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nPolygon center in an edge point of zone 1\n\n>>> p_edge_buffer = shapely.Point(933100.918, 192536.086).buffer(100)\n>>> buff_lit = ibis.literal(p_edge_buffer, \"geometry\")\n>>> t.geom.overlaps(buff_lit).name(\"overlaps\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 overlaps \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True     \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 False    \u2502\n\u2502 \u2026        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::touches", "docstring": "Check if the geometries have at least one point in common, but do not intersect.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether self and right are touching\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nEdge point of zone 1\n\n>>> p_edge = shapely.Point(933100.9183527103, 192536.08569720192)\n>>> p_edge_lit = ibis.literal(p_edge, \"geometry\")\n>>> t.geom.touches(p_edge_lit).name(\"touches\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 touches \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True    \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 False   \u2502\n\u2502 \u2026       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::distance", "docstring": "Compute the distance between two geospatial expressions.\n\nParameters\n----------\nright\n    Right geometry or geography\n\nReturns\n-------\nFloatingValue\n    Distance between `self` and `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nPenn station zone centroid\n\n>>> penn_station = shapely.Point(986345.399, 211974.446)\n>>> t.geom.distance(penn_station).name(\"distance_penn\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 distance_penn \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  47224.139856 \u2502\n\u2502  55992.665470 \u2502\n\u2502  54850.880098 \u2502\n\u2502   8011.846870 \u2502\n\u2502  84371.995209 \u2502\n\u2502  54196.904809 \u2502\n\u2502  15965.509896 \u2502\n\u2502  20566.442476 \u2502\n\u2502  54070.543584 \u2502\n\u2502  56994.826531 \u2502\n\u2502             \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::length", "docstring": "Compute the length of a geospatial expression.\n\nReturns zero for polygons.\n\nReturns\n-------\nFloatingValue\n    Length of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> con = ibis.get_backend()\n>>> con.load_extension(\"spatial\")\n>>> import shapely\n>>> line = shapely.LineString([[0, 0], [1, 0], [1, 1]])\n>>> line_lit = ibis.literal(line, type=\"geometry\")\n>>> line_lit.length()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.length()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoLength(geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502             0.0 \u2502\n\u2502               \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::perimeter", "docstring": "Compute the perimeter of a geospatial expression.\n\nReturns\n-------\nFloatingValue\n    Perimeter of `self`", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::max_distance", "docstring": "Returns the 2-dimensional max distance between two geometries in projected units.\n\nIf `self` and `right` are the same geometry the function will return\nthe distance between the two vertices most far from each other in that\ngeometry.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nFloatingValue\n    Maximum distance", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::union", "docstring": "Merge two geometries into a union geometry.\n\nReturns the pointwise union of the two geometries.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nGeoSpatialValue\n    Union of geometries\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n\nPenn station zone centroid\n\n>>> penn_station = shapely.Point(986345.399, 211974.446)\n>>> t.geom.centroid().union(penn_station).name(\"union_centroid_penn\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 union_centroid_penn                                              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <MULTIPOINT ((935996.821 191376.75), (986345.399 211974.446))>   \u2502\n\u2502 <MULTIPOINT ((1031085.719 164018.754), (986345.399 211974.446))> \u2502\n\u2502 <MULTIPOINT ((1026452.617 254265.479), (986345.399 211974.446))> \u2502\n\u2502 <MULTIPOINT ((990633.981 202959.782), (986345.399 211974.446))>  \u2502\n\u2502 <MULTIPOINT ((931871.37 140681.351), (986345.399 211974.446))>   \u2502\n\u2502 <MULTIPOINT ((964319.735 157998.936), (986345.399 211974.446))>  \u2502\n\u2502 <MULTIPOINT ((1006496.679 216719.218), (986345.399 211974.446))> \u2502\n\u2502 <MULTIPOINT ((1005551.571 222936.088), (986345.399 211974.446))> \u2502\n\u2502 <MULTIPOINT ((1043002.677 212969.849), (986345.399 211974.446))> \u2502\n\u2502 <MULTIPOINT ((1042223.605 186706.496), (986345.399 211974.446))> \u2502\n\u2502 \u2026                                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::x", "docstring": "Return the X coordinate of `self`, or NULL if not available.\n\nInput must be a point.\n\nReturns\n-------\nFloatingValue\n    X coordinate of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.centroid().x()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoX(GeoCentroid(geom)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            9.359968e+05 \u2502\n\u2502            1.031086e+06 \u2502\n\u2502            1.026453e+06 \u2502\n\u2502            9.906340e+05 \u2502\n\u2502            9.318714e+05 \u2502\n\u2502            9.643197e+05 \u2502\n\u2502            1.006497e+06 \u2502\n\u2502            1.005552e+06 \u2502\n\u2502            1.043003e+06 \u2502\n\u2502            1.042224e+06 \u2502\n\u2502                       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::y", "docstring": "Return the Y coordinate of `self`, or NULL if not available.\n\nInput must be a point.\n\nReturns\n-------\nFloatingValue\n    Y coordinate of `self`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.centroid().y()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoY(GeoCentroid(geom)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           191376.749531 \u2502\n\u2502           164018.754403 \u2502\n\u2502           254265.478659 \u2502\n\u2502           202959.782391 \u2502\n\u2502           140681.351376 \u2502\n\u2502           157998.935612 \u2502\n\u2502           216719.218169 \u2502\n\u2502           222936.087552 \u2502\n\u2502           212969.849014 \u2502\n\u2502           186706.496469 \u2502\n\u2502                       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::x_min", "docstring": "Return the X minima of a geometry.\n\nReturns\n-------\nFloatingValue\n    X minima", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::x_max", "docstring": "Return the X maxima of a geometry.\n\nReturns\n-------\nFloatingValue\n    X maxima", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::y_min", "docstring": "Return the Y minima of a geometry.\n\nReturns\n-------\nFloatingValue\n    Y minima", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::y_max", "docstring": "Return the Y maxima of a geometry.\n\nReturns\n-------\nFloatingValue\n    Y maxima", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::start_point", "docstring": "Return the first point of a `LINESTRING` geometry as a `POINT`.\n\nReturn `NULL` if the input parameter is not a `LINESTRING`\n\nReturns\n-------\nPointValue\n    Start point\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> con = ibis.get_backend()\n>>> con.load_extension(\"spatial\")\n>>> import shapely\n>>> line = shapely.LineString([[0, 0], [1, 0], [1, 1]])\n>>> line_lit = ibis.literal(line, type=\"geometry\")\n>>> line_lit.start_point()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 <POINT (0 0)> \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::end_point", "docstring": "Return the last point of a `LINESTRING` geometry as a `POINT`.\n\nReturn `NULL` if the input parameter is not a `LINESTRING`\n\nReturns\n-------\nPointValue\n    End point\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> con = ibis.get_backend()\n>>> con.load_extension(\"spatial\")\n>>> import shapely\n>>> line = shapely.LineString([[0, 0], [1, 0], [1, 1]])\n>>> line_lit = ibis.literal(line, type=\"geometry\")\n>>> line_lit.end_point()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 <POINT (1 1)> \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::point_n", "docstring": "Return the Nth point in a single linestring in the geometry.\n\nNegative values are counted backwards from the end of the LineString,\nso that -1 is the last point. Returns NULL if there is no linestring in\nthe geometry.\n\nParameters\n----------\nn\n    Nth point index\n\nReturns\n-------\nPointValue\n    Nth point in `self`", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::n_points", "docstring": "Return the number of points in a geometry. Works for all geometries.\n\nReturns\n-------\nIntegerValue\n    Number of points\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.n_points()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoNPoints(geom) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              232 \u2502\n\u2502             2954 \u2502\n\u2502              121 \u2502\n\u2502               88 \u2502\n\u2502              170 \u2502\n\u2502              277 \u2502\n\u2502              182 \u2502\n\u2502               40 \u2502\n\u2502              189 \u2502\n\u2502              157 \u2502\n\u2502                \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::n_rings", "docstring": "Return the number of rings for polygons and multipolygons.\n\nOuter rings are counted as well.\n\nReturns\n-------\nIntegerValue\n    Number of rings", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::srid", "docstring": "Return the spatial reference identifier for the ST_Geometry.\n\nReturns\n-------\nIntegerValue\n    SRID", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::set_srid", "docstring": "Set the spatial reference identifier for the `ST_Geometry`.\n\nParameters\n----------\nsrid\n    SRID integer value\n\nReturns\n-------\nGeoSpatialValue\n    `self` with SRID set to `srid`", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::buffer", "docstring": "Return all points whose distance from this geometry is less than or equal to `radius`.\n\nCalculations are in the Spatial Reference System of this Geometry.\n\nParameters\n----------\nradius\n    Floating expression\n\nReturns\n-------\nGeoSpatialValue\n    Geometry expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> p = t.x_cent.point(t.y_cent)\n>>> p.buffer(10)  # note buff.area.mean() ~ pi * r^2\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoBuffer(GeoPoint(x_cent, y_cent), 10.0)                                    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POLYGON ((936006.821 191376.75, 936006.629 191374.799, 936006.06            \u2502\n\u2502 191372.923...>                                                               \u2502\n\u2502 <POLYGON ((1031095.719 164018.754, 1031095.526 164016.803, 1031094.957       \u2502\n\u2502 16401...>                                                                    \u2502\n\u2502 <POLYGON ((1026462.617 254265.479, 1026462.425 254263.528, 1026461.856       \u2502\n\u2502 25426...>                                                                    \u2502\n\u2502 <POLYGON ((990643.981 202959.782, 990643.788 202957.831, 990643.219          \u2502\n\u2502 202955.9...>                                                                 \u2502\n\u2502 <POLYGON ((931881.37 140681.351, 931881.178 140679.4, 931880.609             \u2502\n\u2502 140677.525,...>                                                              \u2502\n\u2502 <POLYGON ((964329.735 157998.936, 964329.543 157996.985, 964328.974          \u2502\n\u2502 157995.1...>                                                                 \u2502\n\u2502 <POLYGON ((1006506.679 216719.218, 1006506.487 216717.267, 1006505.918       \u2502\n\u2502 21671...>                                                                    \u2502\n\u2502 <POLYGON ((1005561.571 222936.088, 1005561.379 222934.137, 1005560.81        \u2502\n\u2502 222932...>                                                                   \u2502\n\u2502 <POLYGON ((1043012.677 212969.849, 1043012.485 212967.898, 1043011.916       \u2502\n\u2502 21296...>                                                                    \u2502\n\u2502 <POLYGON ((1042233.605 186706.496, 1042233.413 186704.546, 1042232.844       \u2502\n\u2502 18670...>                                                                    \u2502\n\u2502 \u2026                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::centroid", "docstring": "Returns the centroid of the geometry.\n\nReturns\n-------\nPointValue\n    The centroid\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.centroid()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoCentroid(geom)                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 point:geometry                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POINT (935996.821 191376.75)>   \u2502\n\u2502 <POINT (1031085.719 164018.754)> \u2502\n\u2502 <POINT (1026452.617 254265.479)> \u2502\n\u2502 <POINT (990633.981 202959.782)>  \u2502\n\u2502 <POINT (931871.37 140681.351)>   \u2502\n\u2502 <POINT (964319.735 157998.936)>  \u2502\n\u2502 <POINT (1006496.679 216719.218)> \u2502\n\u2502 <POINT (1005551.571 222936.088)> \u2502\n\u2502 <POINT (1043002.677 212969.849)> \u2502\n\u2502 <POINT (1042223.605 186706.496)> \u2502\n\u2502 \u2026                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::envelope", "docstring": "Returns a geometry representing the bounding box of `self`.\n\nReturns\n-------\nPolygonValue\n    A polygon\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.envelope()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoEnvelope(geom)                                                            \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 polygon:geometry                                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POLYGON ((931553.491 183788.05, 941810.009 183788.05, 941810.009            \u2502\n\u2502 197256.211...>                                                               \u2502\n\u2502 <POLYGON ((1018052.359 151230.391, 1049019.806 151230.391, 1049019.806       \u2502\n\u2502 17247...>                                                                    \u2502\n\u2502 <POLYGON ((1022540.66 251648.652, 1031732.164 251648.652, 1031732.164        \u2502\n\u2502 257811...>                                                                   \u2502\n\u2502 <POLYGON ((988733.885 201170.618, 992114.154 201170.618, 992114.154          \u2502\n\u2502 205029.4...>                                                                 \u2502\n\u2502 <POLYGON ((927766.539 134554.848, 936499.881 134554.848, 936499.881          \u2502\n\u2502 145354.2...>                                                                 \u2502\n\u2502 <POLYGON ((958451.703 153868.426, 969746.332 153868.426, 969746.332          \u2502\n\u2502 161198.9...>                                                                 \u2502\n\u2502 <POLYGON ((1001260.812 213309.301, 1011389.066 213309.301, 1011389.066       \u2502\n\u2502 21982...>                                                                    \u2502\n\u2502 <POLYGON ((1004114.386 221499.117, 1006968.78 221499.117, 1006968.78         \u2502\n\u2502 224422....>                                                                  \u2502\n\u2502 <POLYGON ((1040414.414 208318.344, 1046392.971 208318.344, 1046392.971       \u2502\n\u2502 22002...>                                                                    \u2502\n\u2502 <POLYGON ((1038120.442 182170.756, 1047431.161 182170.756, 1047431.161       \u2502\n\u2502 19073...>                                                                    \u2502\n\u2502 \u2026                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::within", "docstring": "Check if the first geometry is completely inside of the second.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nBooleanValue\n    Whether `self` is in `right`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import shapely\n>>> t = ibis.examples.zones.fetch()\n>>> penn_station_buf = shapely.Point(986345.399, 211974.446).buffer(5000)\n>>> t.filter(t.geom.within(penn_station_buf))[\"zone\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 zone                         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 East Chelsea                 \u2502\n\u2502 Flatiron                     \u2502\n\u2502 Garment District             \u2502\n\u2502 Midtown South                \u2502\n\u2502 Penn Station/Madison Sq West \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::azimuth", "docstring": "Return the angle in radians from the horizontal of the vector defined by the inputs.\n\nAngle is computed clockwise from down-to-up on the clock: 12=0; 3=PI/2; 6=PI; 9=3PI/2.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nFloatingValue\n    azimuth", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::intersection", "docstring": "Return the intersection of two geometries.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nGeoSpatialValue\n    Intersection of `self` and `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.intersection(t.geom.centroid())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoIntersection(geom, GeoCentroid(geom)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POINT (935996.821 191376.75)>           \u2502\n\u2502 <POINT (1031085.719 164018.754)>         \u2502\n\u2502 <POINT (1026452.617 254265.479)>         \u2502\n\u2502 <POINT (990633.981 202959.782)>          \u2502\n\u2502 <POINT (931871.37 140681.351)>           \u2502\n\u2502 <POINT (964319.735 157998.936)>          \u2502\n\u2502 <POINT (1006496.679 216719.218)>         \u2502\n\u2502 <POINT (1005551.571 222936.088)>         \u2502\n\u2502 <POINT (1043002.677 212969.849)>         \u2502\n\u2502 <POINT (1042223.605 186706.496)>         \u2502\n\u2502 \u2026                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::difference", "docstring": "Return the difference of two geometries.\n\nParameters\n----------\nright\n    Right geometry\n\nReturns\n-------\nGeoSpatialValue\n    Difference of `self` and `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.difference(t.geom.centroid())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoDifference(geom, GeoCentroid(geom))                                       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POLYGON ((933091.011 192572.175, 933088.585 192604.97, 933121.56            \u2502\n\u2502 192857.382...>                                                               \u2502\n\u2502 <MULTIPOLYGON (((1033439.643 170883.946, 1033473.265 170808.208, 1033504.66  \u2502\n\u2502 ...>                                                                         \u2502\n\u2502 <POLYGON ((1026495.593 256638.616, 1026567.23 256589.859, 1026729.235        \u2502\n\u2502 256481...>                                                                   \u2502\n\u2502 <POLYGON ((992068.667 203711.502, 992061.716 203711.772, 992049.866          \u2502\n\u2502 203627.2...>                                                                 \u2502\n\u2502 <POLYGON ((936046.565 144173.418, 936387.922 143967.756, 936481.134          \u2502\n\u2502 143911.7...>                                                                 \u2502\n\u2502 <POLYGON ((966615.256 158662.292, 966524.882 158822.266, 966153.394          \u2502\n\u2502 159414.4...>                                                                 \u2502\n\u2502 <POLYGON ((1011049.165 218914.083, 1011117.534 218916.104, 1011186.09        \u2502\n\u2502 218913...>                                                                   \u2502\n\u2502 <POLYGON ((1005304.898 221499.117, 1004958.187 221747.929, 1004935.368       \u2502\n\u2502 22176...>                                                                    \u2502\n\u2502 <POLYGON ((1043849.708 216473.163, 1043900.798 216332.234, 1043957.136       \u2502\n\u2502 21619...>                                                                    \u2502\n\u2502 <POLYGON ((1044612.122 190156.818, 1044849.742 190262.973, 1045120.559       \u2502\n\u2502 18965...>                                                                    \u2502\n\u2502 \u2026                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::simplify", "docstring": "Simplify a given geometry.\n\nParameters\n----------\ntolerance\n    Tolerance\npreserve_collapsed\n    Whether to preserve collapsed geometries\n\nReturns\n-------\nGeoSpatialValue\n    Simplified geometry", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::transform", "docstring": "Transform a geometry into a new SRID.\n\nParameters\n----------\nsrid\n    Integer expression\n\nReturns\n-------\nGeoSpatialValue\n    Transformed geometry", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::convert", "docstring": "Transform a geometry into a new SRID (CRS).\n\nCoordinates are assumed to always be XY (Longitude-Latitude).\n\nParameters\n----------\nsource\n    CRS/SRID of input geometry\ntarget\n    Target CRS/SRID\n\nReturns\n-------\nGeoSpatialValue\n    Transformed geometry\n\nSee Also\n--------\n[`flip_coordinates`](#ibis.expr.types.geospatial.GeoSpatialValue.flip_coordinates)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n\nData is originally in epsg:2263\n\n>>> t.geom.convert(\"EPSG:2263\", \"EPSG:4326\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoConvert(geom)                                                             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POLYGON ((-74.184 40.695, -74.184 40.695, -74.184 40.695, -74.184 40.696,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <MULTIPOLYGON (((-73.823 40.639, -73.823 40.636, -73.823 40.635, -73.823     \u2502\n\u2502 40....>                                                                      \u2502\n\u2502 <POLYGON ((-73.848 40.871, -73.847 40.871, -73.847 40.871, -73.846 40.871,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-73.972 40.726, -73.972 40.726, -73.972 40.726, -73.972 40.726,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-74.174 40.563, -74.173 40.562, -74.172 40.562, -74.172 40.562,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-74.064 40.602, -74.064 40.602, -74.064 40.603, -74.065 40.604,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-73.904 40.768, -73.903 40.768, -73.903 40.768, -73.903 40.768,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-73.923 40.775, -73.924 40.775, -73.925 40.775, -73.925 40.775,   \u2502\n\u2502 -...>                                                                        \u2502\n\u2502 <POLYGON ((-73.785 40.761, -73.785 40.761, -73.785 40.76, -73.784 40.76,     \u2502\n\u2502 -73...>                                                                      \u2502\n\u2502 <POLYGON ((-73.783 40.69, -73.782 40.688, -73.781 40.689, -73.781 40.687,    \u2502\n\u2502 -7...>                                                                       \u2502\n\u2502 \u2026                                                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::line_locate_point", "docstring": "Locate the distance a point falls along the length of a line.\n\nReturns a float between zero and one representing the location of the\nclosest point on the linestring to the given point, as a fraction of\nthe total 2d line length.\n\nParameters\n----------\nright\n    Point geometry\n\nReturns\n-------\nFloatingValue\n    Fraction of the total line length", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::line_substring", "docstring": "Clip a substring from a LineString.\n\nReturns a linestring that is a substring of the input one, starting\nand ending at the given fractions of the total 2d length. The second\nand third arguments are floating point values between zero and one.\nThis only works with linestrings.\n\nParameters\n----------\nstart\n    Start value\nend\n    End value\n\nReturns\n-------\nLineStringValue\n    Clipped linestring", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::line_merge", "docstring": "Merge a `MultiLineString` into a `LineString`.\n\nReturns a (set of) LineString(s) formed by sewing together the\nconstituent line work of a MultiLineString. If a geometry other than\na LineString or MultiLineString is given, this will return an empty\ngeometry collection.\n\nReturns\n-------\nGeoSpatialValue\n    Merged linestrings", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::flip_coordinates", "docstring": "Flip coordinates of a geometry so that x = y  and y = x.\n\nReturns\n-------\nGeoSpatialValue\n    New geometry with flipped coordinates\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.centroid().flip_coordinates()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoFlipCoordinates(GeoCentroid(geom)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 geospatial:geometry                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POINT (191376.75 935996.821)>        \u2502\n\u2502 <POINT (164018.754 1031085.719)>      \u2502\n\u2502 <POINT (254265.479 1026452.617)>      \u2502\n\u2502 <POINT (202959.782 990633.981)>       \u2502\n\u2502 <POINT (140681.351 931871.37)>        \u2502\n\u2502 <POINT (157998.936 964319.735)>       \u2502\n\u2502 <POINT (216719.218 1006496.679)>      \u2502\n\u2502 <POINT (222936.088 1005551.571)>      \u2502\n\u2502 <POINT (212969.849 1043002.677)>      \u2502\n\u2502 <POINT (186706.496 1042223.605)>      \u2502\n\u2502 \u2026                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/geospatial.py::unary_union", "docstring": "Aggregate a set of geometries into a union.\n\nThis corresponds to the aggregate version of the union.\nWe give it a different name (following the corresponding method\nin GeoPandas) to avoid name conflicts with the non-aggregate version.\n\nParameters\n----------\nwhere\n    Filter expression\n\nReturns\n-------\nGeoSpatialScalar\n    Union of geometries\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.geom.unary_union()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 <MULTIPOLYGON ...>                                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::negate", "docstring": "Negate a numeric expression.\n\nReturns\n-------\nNumericValue\n    A numeric value expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.negate()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Negate(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              1 \u2502\n\u2502              0 \u2502\n\u2502             -1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__neg__", "docstring": "Negate `self`.\n\nReturns\n-------\nNumericValue\n    `self` negated", "type": "function"}
{"source": "ibis/expr/types/numeric.py::round", "docstring": "Round values to an indicated number of decimal places.\n\nParameters\n----------\ndigits\n    The number of digits to round to.\n\n    Here's how the `digits` parameter affects the expression output\n    type:\n\n    - `digits` is `False`-y; `self.type()` is `decimal` \u2192 `decimal`\n    -   `digits` is nonzero; `self.type()` is `decimal` \u2192 `decimal`\n    - `digits` is `False`-y; `self.type()` is Floating  \u2192 `int64`\n    -   `digits` is nonzero; `self.type()` is Floating  \u2192 `float64`\n\nReturns\n-------\nNumericValue\n    The rounded expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1.22, 1.64, 2.15, 2.54]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    1.22 \u2502\n\u2502    1.64 \u2502\n\u2502    2.15 \u2502\n\u2502    2.54 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.values.round()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Round(values, 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                1 \u2502\n\u2502                2 \u2502\n\u2502                2 \u2502\n\u2502                3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.values.round(1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Round(values, 1) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              1.2 \u2502\n\u2502              1.6 \u2502\n\u2502              2.2 \u2502\n\u2502              2.5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::log", "docstring": "Compute $\\log_{\\texttt{base}}\\left(\\texttt{self}\\right)$.\n\nParameters\n----------\nbase\n    The base of the logarithm. If `None`, base `e` is used.\n\nReturns\n-------\nNumericValue\n    Logarithm of `arg` with base `base`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from math import e\n>>> t = ibis.memtable({\"values\": [e, e**2, e**3]})\n>>> t.values.log()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Log(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         1.0 \u2502\n\u2502         2.0 \u2502\n\u2502         3.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [10, 100, 1000]})\n>>> t.values.log(10)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Log(values, 10) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             1.0 \u2502\n\u2502             2.0 \u2502\n\u2502             3.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::clip", "docstring": "Trim values outside of `lower` and `upper` bounds.\n\n`NULL` values are preserved and are not replaced with bounds.\n\nParameters\n----------\nlower\n    Lower bound\nupper\n    Upper bound\n\nReturns\n-------\nNumericValue\n    Clipped input\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\"values\": [None, 2, 3, None, 5, None, None, 8]},\n...     schema=dict(values=\"int\"),\n... )\n>>> t.values.clip(lower=3, upper=6)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Clip(values, 3, 6) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502               NULL \u2502\n\u2502                  3 \u2502\n\u2502                  3 \u2502\n\u2502               NULL \u2502\n\u2502                  5 \u2502\n\u2502               NULL \u2502\n\u2502               NULL \u2502\n\u2502                  6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::abs", "docstring": "Return the absolute value of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n>>> t.values.abs()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Abs(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           1 \u2502\n\u2502           2 \u2502\n\u2502           3 \u2502\n\u2502           4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::ceil", "docstring": "Return the ceiling of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n>>> t.values.ceil()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Ceil(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            1 \u2502\n\u2502            2 \u2502\n\u2502            2 \u2502\n\u2502            3 \u2502\n\u2502            4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::degrees", "docstring": "Compute the degrees of `self` radians.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from math import pi\n>>> t = ibis.memtable({\"values\": [0, pi / 2, pi, 3 * pi / 2, 2 * pi]})\n>>> t.values.degrees()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Degrees(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             0.0 \u2502\n\u2502            90.0 \u2502\n\u2502           180.0 \u2502\n\u2502           270.0 \u2502\n\u2502           360.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::exp", "docstring": "Compute $e^\\texttt{self}$.\n\nReturns\n-------\nNumericValue\n    $e^\\texttt{self}$\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": range(4)})\n>>> t.values.exp()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Exp(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    1.000000 \u2502\n\u2502    2.718282 \u2502\n\u2502    7.389056 \u2502\n\u2502   20.085537 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::floor", "docstring": "Return the floor of an expression.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n>>> t.values.floor()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Floor(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             1 \u2502\n\u2502             1 \u2502\n\u2502             2 \u2502\n\u2502             2 \u2502\n\u2502             3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::log2", "docstring": "Compute $\\log_{2}\\left(\\texttt{self}\\right)$.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 4, 8]})\n>>> t.values.log2()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Log2(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          0.0 \u2502\n\u2502          1.0 \u2502\n\u2502          2.0 \u2502\n\u2502          3.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::log10", "docstring": "Compute $\\log_{10}\\left(\\texttt{self}\\right)$.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 10, 100]})\n>>> t.values.log10()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Log10(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           0.0 \u2502\n\u2502           1.0 \u2502\n\u2502           2.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::ln", "docstring": "Compute $\\ln\\left(\\texttt{self}\\right)$.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2.718281828, 3]})\n>>> t.values.ln()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Ln(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   0.000000 \u2502\n\u2502   1.000000 \u2502\n\u2502   1.098612 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::radians", "docstring": "Compute radians from `self` degrees.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [0, 90, 180, 270, 360]})\n>>> t.values.radians()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Radians(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        0.000000 \u2502\n\u2502        1.570796 \u2502\n\u2502        3.141593 \u2502\n\u2502        4.712389 \u2502\n\u2502        6.283185 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::sign", "docstring": "Return the sign of the input.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n>>> t.values.sign()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Sign(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           -1 \u2502\n\u2502            1 \u2502\n\u2502           -1 \u2502\n\u2502            1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::sqrt", "docstring": "Compute the square root of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 4, 9, 16]})\n>>> t.values.sqrt()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Sqrt(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          1.0 \u2502\n\u2502          2.0 \u2502\n\u2502          3.0 \u2502\n\u2502          4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::acos", "docstring": "Compute the arc cosine of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.acos()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Acos(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3.141593 \u2502\n\u2502     1.570796 \u2502\n\u2502     0.000000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::asin", "docstring": "Compute the arc sine of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.asin()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Asin(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    -1.570796 \u2502\n\u2502     0.000000 \u2502\n\u2502     1.570796 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::atan", "docstring": "Compute the arc tangent of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.atan()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Atan(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    -0.785398 \u2502\n\u2502     0.000000 \u2502\n\u2502     0.785398 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::atan2", "docstring": "Compute the two-argument version of arc tangent.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.atan2(0)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Atan2(values, 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        -1.570796 \u2502\n\u2502         0.000000 \u2502\n\u2502         1.570796 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::cos", "docstring": "Compute the cosine of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.cos()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Cos(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    0.540302 \u2502\n\u2502    1.000000 \u2502\n\u2502    0.540302 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::cot", "docstring": "Compute the cotangent of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, -2, 3]})\n>>> t.values.cot()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Cot(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -0.642093 \u2502\n\u2502    0.457658 \u2502\n\u2502   -7.015253 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::sin", "docstring": "Compute the sine of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.sin()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Sin(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -0.841471 \u2502\n\u2502    0.000000 \u2502\n\u2502    0.841471 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::tan", "docstring": "Compute the tangent of `self`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.tan()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Tan(values) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -1.557408 \u2502\n\u2502    0.000000 \u2502\n\u2502    1.557408 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__add__", "docstring": "Add `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__sub__", "docstring": "Subtract `other` from `self`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rsub__", "docstring": "Subtract `self` from `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__mul__", "docstring": "Multiply `self` and `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__truediv__", "docstring": "Divide `self` by `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rtruediv__", "docstring": "Divide `other` by `self`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__floordiv__", "docstring": "Floor divide `self` by `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rfloordiv__", "docstring": "Floor divide `other` by `self`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__pow__", "docstring": "Raise `self` to the `other`th power.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rpow__", "docstring": "Raise `other` to the `self`th power.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__mod__", "docstring": "Compute `self` modulo `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rmod__", "docstring": "Compute `other` modulo `self`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::point", "docstring": "Return a point constructed from the coordinate values.\n\nConstant coordinates result in construction of a `POINT` literal or\ncolumn.\n\nParameters\n----------\nright\n    Y coordinate\n\nReturns\n-------\nPointValue\n    Points\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.zones.fetch()\n>>> t.x_cent.point(t.y_cent)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 GeoPoint(x_cent, y_cent)         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 point:geometry                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 <POINT (935996.821 191376.75)>   \u2502\n\u2502 <POINT (1031085.719 164018.754)> \u2502\n\u2502 <POINT (1026452.617 254265.479)> \u2502\n\u2502 <POINT (990633.981 202959.782)>  \u2502\n\u2502 <POINT (931871.37 140681.351)>   \u2502\n\u2502 <POINT (964319.735 157998.936)>  \u2502\n\u2502 <POINT (1006496.679 216719.218)> \u2502\n\u2502 <POINT (1005551.571 222936.088)> \u2502\n\u2502 <POINT (1043002.677 212969.849)> \u2502\n\u2502 <POINT (1042223.605 186706.496)> \u2502\n\u2502 \u2026                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::kurtosis", "docstring": "Return the kurtosis of a numeric column.\n\nParameters\n----------\nwhere\n    Filter\nhow\n    Whether to include bias correction. `\"sample\"` includes the\n    correction while `\"pop\"` does not.\n\nReturns\n-------\nNumericScalar\n    Kurtosis of `arg`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"keys\": [\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"b\", \"b\"],\n...         \"values\": [1, 2, 3, 3, 6, 4, 5, 7],\n...     }\n... )\n>>> t.values.kurtosis()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 -0.88595 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.group_by(\"keys\").agg(kurt=t.values.kurtosis()).order_by(\"keys\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 keys   \u2503 kurt      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502 -1.699512 \u2502\n\u2502 b      \u2502 -1.289256 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::std", "docstring": "Return the standard deviation of a numeric column.\n\nParameters\n----------\nwhere\n    Filter\nhow\n    Sample or population standard deviation\n\nReturns\n-------\nNumericScalar\n    Standard deviation of `arg`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"values\": [1, 3, 3, 4, 5, 7],\n...     }\n... )\n>>> t.values.std()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2.041241 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(std_col=t.values.std())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 std_col  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502 2.041241 \u2502\n\u2502      3 \u2502 2.041241 \u2502\n\u2502      3 \u2502 2.041241 \u2502\n\u2502      4 \u2502 2.041241 \u2502\n\u2502      5 \u2502 2.041241 \u2502\n\u2502      7 \u2502 2.041241 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::var", "docstring": "Return the variance of a numeric column.\n\nParameters\n----------\nwhere\n    Filter\nhow\n    Sample or population variance\n\nReturns\n-------\nNumericScalar\n    Standard deviation of `arg`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"values\": [1, 3, 3, 4, 5, 7],\n...     }\n... )\n>>> t.values.var()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4.166667 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(var_col=t.values.var())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 var_col  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502 4.166667 \u2502\n\u2502      3 \u2502 4.166667 \u2502\n\u2502      3 \u2502 4.166667 \u2502\n\u2502      4 \u2502 4.166667 \u2502\n\u2502      5 \u2502 4.166667 \u2502\n\u2502      7 \u2502 4.166667 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::corr", "docstring": "Return the correlation of two numeric columns.\n\nParameters\n----------\nright\n    Numeric column\nwhere\n    Filter\nhow\n    Population or sample correlation\n\nReturns\n-------\nNumericScalar\n    The correlation of `left` and `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"left\": [1, 3, 3, 4, 5, 7],\n...         \"right\": [7, 5, 4, 3, 3, 1],\n...     }\n... )\n>>> t.left.corr(t.right, how=\"pop\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 -0.968 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(corr_col=t.left.corr(t.right, how=\"pop\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 left  \u2503 right \u2503 corr_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     7 \u2502   -0.968 \u2502\n\u2502     3 \u2502     5 \u2502   -0.968 \u2502\n\u2502     3 \u2502     4 \u2502   -0.968 \u2502\n\u2502     4 \u2502     3 \u2502   -0.968 \u2502\n\u2502     5 \u2502     3 \u2502   -0.968 \u2502\n\u2502     7 \u2502     1 \u2502   -0.968 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::cov", "docstring": "Return the covariance of two numeric columns.\n\nParameters\n----------\nright\n    Numeric column\nwhere\n    Filter\nhow\n    Population or sample covariance\n\nReturns\n-------\nNumericScalar\n    The covariance of `self` and `right`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"left\": [1, 3, 3, 4, 5, 7],\n...         \"right\": [7, 5, 4, 3, 3, 1],\n...     }\n... )\n>>> t.left.cov(t.right)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 -4.033333 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.left.cov(t.right, how=\"pop\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 -3.361111 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(cov_col=t.left.cov(t.right, how=\"pop\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 left  \u2503 right \u2503 cov_col   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 float64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     7 \u2502 -3.361111 \u2502\n\u2502     3 \u2502     5 \u2502 -3.361111 \u2502\n\u2502     3 \u2502     4 \u2502 -3.361111 \u2502\n\u2502     4 \u2502     3 \u2502 -3.361111 \u2502\n\u2502     5 \u2502     3 \u2502 -3.361111 \u2502\n\u2502     7 \u2502     1 \u2502 -3.361111 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::mean", "docstring": "Return the mean of a numeric column.\n\nParameters\n----------\nwhere\n    Filter\n\nReturns\n-------\nNumericScalar\n    The mean of the input expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(mean_col=t.values.mean())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 mean_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502 2.166667 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502 2.166667 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502 2.166667 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502 2.166667 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502 2.166667 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502 2.166667 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.mutate(mean_col=t.values.mean(where=t.grouper != \"c\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 mean_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      2.2 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      2.2 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      2.2 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      2.2 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      2.2 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502      2.2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::cummean", "docstring": "Return the cumulative mean of the input.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(cummean=t.values.cummean()).order_by(\"id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummean  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502 3.000000 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502 2.500000 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502 2.000000 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502 2.000000 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502 2.200000 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502 2.166667 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.mutate(cummean=t.values.cummean(where=t.grouper != \"c\", group_by=\"grouper\")).order_by(\n...     \"id\"\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cummean \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502     3.0 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502     2.5 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502     2.0 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502     2.0 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502     2.5 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502    NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::sum", "docstring": "Return the sum of a numeric column.\n\nParameters\n----------\nwhere\n    Filter\n\nReturns\n-------\nNumericScalar\n    The sum of the input expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(sum_col=t.values.sum())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 sum_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      13 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      13 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      13 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      13 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      13 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502      13 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.mutate(sum_col=t.values.sum(where=t.grouper != \"c\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 sum_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      11 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      11 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      11 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      11 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502      11 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502      11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::cumsum", "docstring": "Return the cumulative sum of the input.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"],\n...         \"values\": [3, 2, 1, 2, 3, 2],\n...     }\n... )\n>>> t.mutate(cumsum=t.values.cumsum())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cumsum \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      5 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      6 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      8 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502     11 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502     13 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.mutate(cumsum=t.values.cumsum(where=t.grouper != \"c\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 id    \u2503 grouper \u2503 values \u2503 cumsum \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string  \u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a       \u2502      3 \u2502      3 \u2502\n\u2502     2 \u2502 a       \u2502      2 \u2502      5 \u2502\n\u2502     3 \u2502 a       \u2502      1 \u2502      6 \u2502\n\u2502     4 \u2502 b       \u2502      2 \u2502      8 \u2502\n\u2502     5 \u2502 b       \u2502      3 \u2502     11 \u2502\n\u2502     6 \u2502 c       \u2502      2 \u2502     11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::bucket", "docstring": "Compute a discrete binning of a numeric array.\n\nParameters\n----------\nbuckets\n    List of buckets\nclosed\n    Which side of each interval is closed. For example:\n\n    ```python\n    buckets = [0, 100, 200]\n    closed = \"left\"  # 100 falls in 2nd bucket\n    closed = \"right\"  # 100 falls in 1st bucket\n    ```\nclose_extreme\n    Whether the extreme values fall in the last bucket\ninclude_over\n    Include values greater than the last bucket in the last bucket\ninclude_under\n    Include values less than the first bucket in the first bucket\n\nReturns\n-------\nIntegerColumn\n    A categorical column expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"values\": [-1, 3, 5, 6, 8, 10, 11],\n...     }\n... )\n>>> buckets = [0, 5, 10]\n>>> t.mutate(\n...     bucket_closed_left=t.values.bucket(buckets),\n...     bucket_closed_right=t.values.bucket(buckets, closed=\"right\"),\n...     bucket_over_under=t.values.bucket(buckets, include_over=True, include_under=True),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 bucket_closed_left \u2503 bucket_closed_right \u2503 bucket_over_under \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int8               \u2502 int8                \u2502 int8              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     -1 \u2502               NULL \u2502                NULL \u2502                 0 \u2502\n\u2502      3 \u2502                  0 \u2502                   0 \u2502                 1 \u2502\n\u2502      5 \u2502                  1 \u2502                   0 \u2502                 2 \u2502\n\u2502      6 \u2502                  1 \u2502                   1 \u2502                 2 \u2502\n\u2502      8 \u2502                  1 \u2502                   1 \u2502                 2 \u2502\n\u2502     10 \u2502                  1 \u2502                   1 \u2502                 2 \u2502\n\u2502     11 \u2502               NULL \u2502                NULL \u2502                 3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::histogram", "docstring": "Compute a histogram with fixed width bins.\n\nParameters\n----------\nnbins\n    If supplied, will be used to compute the binwidth\nbinwidth\n    If not supplied, computed from the data (actual max and min values)\nbase\n    The value of the first histogram bin. Defaults to the minimum value\n    of `column`.\neps\n    Allowed floating point epsilon for histogram base\n\nReturns\n-------\nColumn\n    Bucketed column\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"values\": [-1, 3, 5, 6, 8, 10, 11, 23, 25],\n...     }\n... )\n\nCompute a histogram with 5 bins.\n\n>>> t.mutate(histogram=t.values.histogram(nbins=5))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 histogram \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     -1 \u2502         0 \u2502\n\u2502      3 \u2502         0 \u2502\n\u2502      5 \u2502         1 \u2502\n\u2502      6 \u2502         1 \u2502\n\u2502      8 \u2502         1 \u2502\n\u2502     10 \u2502         2 \u2502\n\u2502     11 \u2502         2 \u2502\n\u2502     23 \u2502         4 \u2502\n\u2502     25 \u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCompute a histogram with a fixed bin width of 10.\n>>> t.mutate(histogram=t.values.histogram(binwidth=10))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 histogram \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     -1 \u2502         0 \u2502\n\u2502      3 \u2502         0 \u2502\n\u2502      5 \u2502         0 \u2502\n\u2502      6 \u2502         0 \u2502\n\u2502      8 \u2502         0 \u2502\n\u2502     10 \u2502         1 \u2502\n\u2502     11 \u2502         1 \u2502\n\u2502     23 \u2502         2 \u2502\n\u2502     25 \u2502         2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::approx_quantile", "docstring": "Compute one or more approximate quantiles of a column.\n\n::: {.callout-note}\n## The result may or may not be exact\n\nWhether the result is an approximation depends on the backend.\n:::\n\nParameters\n----------\nquantile\n    `0 <= quantile <= 1`, or an array of such values\n    indicating the quantile or quantiles to compute\nwhere\n    Boolean filter for input values\n\nReturns\n-------\nScalar\n    Quantile of the input\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n\nCompute the approximate 0.50 quantile of `bill_depth_mm`.\n\n>>> t.bill_depth_mm.approx_quantile(0.50)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 17.318 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCompute multiple approximate quantiles in one call - in this case the\nresult is an array.\n\n>>> t.bill_depth_mm.approx_quantile([0.25, 0.75])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [15.565625, 18.671875] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::as_timestamp", "docstring": "Convert an integral UNIX timestamp to a timestamp expression.\n\nParameters\n----------\nunit\n    The resolution of `arg`\n\nReturns\n-------\nTimestampValue\n    `self` converted to a timestamp\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"int_col\": [0, 1730501716, 2147483647]})\n>>> t.int_col.as_timestamp(\"s\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 TimestampFromUNIX(int_col, SECOND) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1970-01-01 00:00:00                \u2502\n\u2502 2024-11-01 22:55:16                \u2502\n\u2502 2038-01-19 03:14:07                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::as_interval", "docstring": "Convert an integer to an interval.\n\nParameters\n----------\nunit\n    Unit for the resulting interval\n\nReturns\n-------\nIntervalValue\n    An interval in units of `unit`\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"timestamp_col\": [\n...             datetime(2024, 1, 1, 0, 0, 0),\n...             datetime(2024, 1, 1, 0, 0, 0),\n...             datetime(2024, 1, 1, 0, 0, 0),\n...         ],\n...         \"int_col\": [1, 2, 3],\n...     }\n... )\n>>> t.int_col.as_interval(\"h\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 IntervalFromInteger(int_col, HOUR)                         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 interval('h')                                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MonthDayNano(months=0, days=0, nanoseconds=3600000000000)  \u2502\n\u2502 MonthDayNano(months=0, days=0, nanoseconds=7200000000000)  \u2502\n\u2502 MonthDayNano(months=0, days=0, nanoseconds=10800000000000) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n>>> t.mutate(timestamp_added_col=t.timestamp_col + t.int_col.as_interval(\"h\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp_col       \u2503 int_col \u2503 timestamp_added_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 int64   \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2024-01-01 00:00:00 \u2502       1 \u2502 2024-01-01 01:00:00 \u2502\n\u2502 2024-01-01 00:00:00 \u2502       2 \u2502 2024-01-01 02:00:00 \u2502\n\u2502 2024-01-01 00:00:00 \u2502       3 \u2502 2024-01-01 03:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::convert_base", "docstring": "Convert an integer from one base to another.\n\nParameters\n----------\nfrom_base\n    Numeric base of expression\nto_base\n    New base\n\nReturns\n-------\nIntegerValue\n    Converted expression", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__and__", "docstring": "Bitwise and `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__or__", "docstring": "Bitwise or `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__xor__", "docstring": "Bitwise xor `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__lshift__", "docstring": "Bitwise left shift `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rlshift__", "docstring": "Bitwise left shift `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rshift__", "docstring": "Bitwise right shift `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__rrshift__", "docstring": "Bitwise right shift `self` with `other`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::__invert__", "docstring": "Bitwise not of `self`.\n\nReturns\n-------\nIntegerValue\n    Inverted bits of `self`.", "type": "function"}
{"source": "ibis/expr/types/numeric.py::bit_and", "docstring": "Aggregate the column using the bitwise and operator.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"x\": [-1, 0, 1]})\n>>> t.x.bit_and()\n\u250c\u2500\u2500\u2500\u2510\n\u2502 0 \u2502\n\u2514\u2500\u2500\u2500\u2518\n>>> t.x.bit_and(where=t.x != 0)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::bit_or", "docstring": "Aggregate the column using the bitwise or operator.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"x\": [-1, 0, 1]})\n>>> t.x.bit_or()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 -1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> t.x.bit_or(where=t.x >= 0)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::bit_xor", "docstring": "Aggregate the column using the bitwise exclusive or operator.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"x\": [-1, 0, 1]})\n>>> t.x.bit_xor()\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 -2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n>>> t.x.bit_xor(where=t.x >= 0)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::isnan", "docstring": "Return whether the value is NaN. Does NOT detect `NULL` and `inf` values.\n\nSee Also\n--------\n[`Value.isnull()`](./expression-generic.qmd#ibis.expr.types.generic.Value.fill_null)\n[`FloatingValue.isinf()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isinf)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"f\": [None, \"-inf\", \"3.0\", \"inf\", \"nan\"]})\n>>> t = t.mutate(f=ibis._.f.cast(float))\n>>> t.mutate(\n...     isnull=t.f.isnull(),\n...     isnan=t.f.isnan(),\n...     isinf=t.f.isinf(),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f       \u2503 isnull  \u2503 isnan   \u2503 isinf   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 boolean \u2502 boolean \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502 True    \u2502 NULL    \u2502 NULL    \u2502\n\u2502    -inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     3.0 \u2502 False   \u2502 False   \u2502 False   \u2502\n\u2502     inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     nan \u2502 False   \u2502 True    \u2502 False   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/numeric.py::isinf", "docstring": "Return whether the value is +/-inf. Does NOT detect `NULL` and `inf` values.\n\nSee Also\n--------\n[`Value.isnull()`](./expression-generic.qmd#ibis.expr.types.generic.Value.fill_null)\n[`FloatingValue.isnan()`](./expression-numeric.qmd#ibis.expr.types.numeric.FloatingValue.isnan)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"f\": [None, \"-inf\", \"3.0\", \"inf\", \"nan\"]})\n>>> t = t.mutate(f=ibis._.f.cast(float))\n>>> t.mutate(\n...     isnull=t.f.isnull(),\n...     isnan=t.f.isnan(),\n...     isinf=t.f.isinf(),\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 f       \u2503 isnull  \u2503 isnan   \u2503 isinf   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 boolean \u2502 boolean \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    NULL \u2502 True    \u2502 NULL    \u2502 NULL    \u2502\n\u2502    -inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     3.0 \u2502 False   \u2502 False   \u2502 False   \u2502\n\u2502     inf \u2502 False   \u2502 False   \u2502 True    \u2502\n\u2502     nan \u2502 False   \u2502 True    \u2502 False   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/temporal_windows.py::WindowedTable", "docstring": "An intermediate table expression to hold windowing information.", "type": "class"}
{"source": "ibis/expr/types/groupby.py::GroupedTable", "docstring": "An intermediate table expression to hold grouping information.", "type": "class"}
{"source": "ibis/expr/types/groupby.py::aggregate", "docstring": "Compute aggregates over a group by.", "type": "function"}
{"source": "ibis/expr/types/groupby.py::having", "docstring": "Add a post-aggregation result filter `expr`.\n\n::: {.callout-warning}\n## Expressions like `x is None` return `bool` and **will not** generate a SQL comparison to `NULL`\n:::\n\nParameters\n----------\npredicates\n    Expressions that filters based on an aggregate value.\n\nReturns\n-------\nGroupedTable\n    A grouped table expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\"grouper\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"], \"values\": [1, 2, 3, 1, 2, 1]}\n... )\n>>> expr = (\n...     t.group_by(t.grouper)\n...     .having(t.count() < 3)\n...     .aggregate(values_count=t.count(), values_sum=t.values.sum())\n...     .order_by(t.grouper)\n... )\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 grouper \u2503 values_count \u2503 values_sum \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64        \u2502 int64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 b       \u2502            2 \u2502          3 \u2502\n\u2502 c       \u2502            1 \u2502          1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/groupby.py::order_by", "docstring": "Sort a grouped table expression by `expr`.\n\nNotes\n-----\nThis API call is ignored in aggregations.\n\nParameters\n----------\nby\n    Expressions to order the results by\n\nReturns\n-------\nGroupedTable\n    A sorted grouped GroupedTable", "type": "function"}
{"source": "ibis/expr/types/groupby.py::mutate", "docstring": "Return a table projection with window functions applied.\n\nAny arguments can be functions.\n\nParameters\n----------\nexprs\n    List of expressions\nkwexprs\n    Expressions\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 int64             \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502           39.1 \u2502          18.7 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.5 \u2502          17.4 \u2502               186 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           40.3 \u2502          18.0 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           NULL \u2502          NULL \u2502              NULL \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           36.7 \u2502          19.3 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.3 \u2502          20.6 \u2502               190 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           38.9 \u2502          17.8 \u2502               181 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           39.2 \u2502          19.6 \u2502               195 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           34.1 \u2502          18.1 \u2502               193 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502           42.0 \u2502          20.2 \u2502               190 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> (\n...     t.select(\"species\", \"bill_length_mm\")\n...     .group_by(\"species\")\n...     .mutate(centered_bill_len=ibis._.bill_length_mm - ibis._.bill_length_mm.mean())\n...     .order_by(s.all())\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 bill_length_mm \u2503 centered_bill_len \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 float64        \u2502 float64           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502           32.1 \u2502         -6.691391 \u2502\n\u2502 Adelie  \u2502           33.1 \u2502         -5.691391 \u2502\n\u2502 Adelie  \u2502           33.5 \u2502         -5.291391 \u2502\n\u2502 Adelie  \u2502           34.0 \u2502         -4.791391 \u2502\n\u2502 Adelie  \u2502           34.1 \u2502         -4.691391 \u2502\n\u2502 Adelie  \u2502           34.4 \u2502         -4.391391 \u2502\n\u2502 Adelie  \u2502           34.5 \u2502         -4.291391 \u2502\n\u2502 Adelie  \u2502           34.6 \u2502         -4.191391 \u2502\n\u2502 Adelie  \u2502           34.6 \u2502         -4.191391 \u2502\n\u2502 Adelie  \u2502           35.0 \u2502         -3.791391 \u2502\n\u2502 \u2026       \u2502              \u2026 \u2502                 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nTable\n    A table expression with window functions applied", "type": "function"}
{"source": "ibis/expr/types/groupby.py::select", "docstring": "Project new columns out of the grouped table.\n\nSee Also\n--------\n[`GroupedTable.mutate`](#ibis.expr.types.groupby.GroupedTable.mutate)", "type": "function"}
{"source": "ibis/expr/types/groupby.py::_selectables", "docstring": "Project new columns out of the grouped table.\n\nSee Also\n--------\n[`GroupedTable.mutate`](#ibis.expr.types.groupby.GroupedTable.mutate)", "type": "function"}
{"source": "ibis/expr/types/groupby.py::over", "docstring": "Apply a window over the input expressions.\n\nParameters\n----------\nwindow\n    Window to add to the input\nrows\n    Whether to use the `ROWS` window clause\nrange\n    Whether to use the `RANGE` window clause\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nGroupedTable\n    A new grouped table expression", "type": "function"}
{"source": "ibis/expr/types/groupby.py::count", "docstring": "Computing the number of rows per group.\n\nReturns\n-------\nTable\n    The aggregated table", "type": "function"}
{"source": "ibis/expr/types/json.py::JSONValue", "docstring": "A json-like collection with dynamic keys and values.\n\nExamples\n--------\nConstruct a table with a JSON column\n\n>>> import json, ibis\n>>> ibis.options.interactive = True\n>>> rows = [{\"js\": json.dumps({\"a\": [i, 1]})} for i in range(2)]\n>>> t = ibis.memtable(rows, schema=ibis.schema(dict(js=\"json\")))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 js                   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': [...]}         \u2502\n\u2502 {'a': [...]}         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExtract the `\"a\"` field\n\n>>> t.js[\"a\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 JSONGetItem(js, 'a') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [0, 1]               \u2502\n\u2502 [1, 1]               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExtract the first element of the JSON array at `\"a\"`\n\n>>> t.js[\"a\"][0]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 JSONGetItem(JSONGetItem(js, 'a'), 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0                                    \u2502\n\u2502 1                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExtract a non-existent field\n\n>>> t.js[\"a\"][\"foo\"]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 JSONGetItem(JSONGetItem(js, 'a'), 'foo') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL                                     \u2502\n\u2502 NULL                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTry to extract an array element, returns `NULL`\n\n>>> t.js[20]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 JSONGetItem(js, 20) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL                \u2502\n\u2502 NULL                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "class"}
{"source": "ibis/expr/types/json.py::__getitem__", "docstring": "Access an JSON object's value or JSON array's element at `key`.\n\nParameters\n----------\nkey\n    Object field name or integer array index\n\nReturns\n-------\nJSONValue\n    Element located at `key`", "type": "function"}
{"source": "ibis/expr/types/json.py::unwrap_as", "docstring": "Unwrap JSON into a specific data type.\n\nReturns\n-------\nValue\n    An Ibis expression of a more specific type than JSON\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> data = {\n...     \"jstring\": ['\"a\"', '\"\"', None, \"null\"],\n...     \"jbool\": [\"true\", \"false\", \"null\", None],\n...     \"jint\": [\"1\", \"null\", None, \"2\"],\n...     \"jfloat\": [\"42.42\", None, \"null\", \"37.37\"],\n...     \"jmap\": ['{\"a\": 1}', \"null\", None, \"{}\"],\n...     \"jarray\": [\"[]\", \"null\", None, '[{},\"1\",2]'],\n... }\n>>> t = ibis.memtable(data, schema=dict.fromkeys(data.keys(), \"json\"))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 jstring              \u2503 jbool                \u2503 jint                 \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 json                 \u2502 json                 \u2502 json                 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 'a'                  \u2502 True                 \u2502 1                    \u2502 \u2026 \u2502\n\u2502 ''                   \u2502 False                \u2502 None                 \u2502 \u2026 \u2502\n\u2502 NULL                 \u2502 None                 \u2502 NULL                 \u2502 \u2026 \u2502\n\u2502 None                 \u2502 NULL                 \u2502 2                    \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n>>> t.select(unwrapped=t.jstring.unwrap_as(str), original=t.jstring)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a         \u2502 'a'                  \u2502\n\u2502 ~         \u2502 ''                   \u2502\n\u2502 NULL      \u2502 NULL                 \u2502\n\u2502 NULL      \u2502 None                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.select(unwrapped=t.jbool.unwrap_as(\"bool\"), original=t.jbool)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean   \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True      \u2502 True                 \u2502\n\u2502 False     \u2502 False                \u2502\n\u2502 NULL      \u2502 None                 \u2502\n\u2502 NULL      \u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.select(\n...     unwrapped_int64=t.jint.unwrap_as(\"int64\"),\n...     unwrapped_int32=t.jint.unwrap_as(\"int32\"),\n...     original=t.jint,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped_int64 \u2503 unwrapped_int32 \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64           \u2502 int32           \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502               1 \u2502               1 \u2502 1                    \u2502\n\u2502            NULL \u2502            NULL \u2502 None                 \u2502\n\u2502            NULL \u2502            NULL \u2502 NULL                 \u2502\n\u2502               2 \u2502               2 \u2502 2                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can cast to a more specific type than the types available in standards-compliant JSON.\n\nHere's an example of casting JSON numbers to `float32`:\n\n>>> t.select(unwrapped=t.jfloat.unwrap_as(\"float32\"), original=t.jfloat)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float32   \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 42.419998 \u2502 42.42                \u2502\n\u2502      NULL \u2502 NULL                 \u2502\n\u2502      NULL \u2502 None                 \u2502\n\u2502 37.369999 \u2502 37.37                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can cast JSON objects to a more specific `map` type:\n\n>>> t.select(unwrapped=t.jmap.unwrap_as(\"map<string, int>\"), original=t.jmap)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped            \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 map<string, int64>   \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 {'a': 1}             \u2502 {'a': 1}             \u2502\n\u2502 NULL                 \u2502 None                 \u2502\n\u2502 NULL                 \u2502 NULL                 \u2502\n\u2502 {}                   \u2502 {}                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can cast JSON arrays to an array type as well. In this case the\narray values don't have a single element type so we cast to\n`array<json>`.\n\n>>> t.select(unwrapped=t.jarray.unwrap_as(\"array<json>\"), original=t.jarray)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 unwrapped             \u2503 original             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<json>           \u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 []                    \u2502 []                   \u2502\n\u2502 NULL                  \u2502 None                 \u2502\n\u2502 NULL                  \u2502 NULL                 \u2502\n\u2502 ['{}', '\"1\"', ... +1] \u2502 [{...}, '1', ... +1] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`JSONValue.str`](#ibis.expr.types.json.JSONValue.str)\n[`JSONValue.int`](#ibis.expr.types.json.JSONValue.int)\n[`JSONValue.float`](#ibis.expr.types.json.JSONValue.float)\n[`JSONValue.bool`](#ibis.expr.types.json.JSONValue.bool)\n[`JSONValue.map`](#ibis.expr.types.json.JSONValue.map)\n[`JSONValue.array`](#ibis.expr.types.json.JSONValue.array)\n[`Value.cast`](#ibis.expr.types.generic.Value.cast)", "type": "function"}
{"source": "ibis/expr/types/json.py::map", "docstring": "Cast JSON to a map of string to JSON.\n\nUse this property to unlock map functionality on JSON objects.\n\nReturns\n-------\nMapValue\n    Map of string to JSON", "type": "function"}
{"source": "ibis/expr/types/json.py::array", "docstring": "Cast JSON to an array of JSON.\n\nUse this property to unlock array functionality on JSON objects.\n\nReturns\n-------\nArrayValue\n    Array of JSON objects", "type": "function"}
{"source": "ibis/expr/types/json.py::int", "docstring": "Unwrap a JSON value into a backend-native int.\n\nAny non-float JSON values are returned as `NULL`.\n\nExamples\n--------\n>>> import json, ibis\n>>> ibis.options.interactive = True\n>>> data = [\n...     {\"name\": \"Alice\", \"json_data\": '{\"last_name\":\"Smith\",\"age\":40}'},\n...     {\"name\": \"Bob\", \"json_data\": '{\"last_name\":\"Jones\", \"age\":39}'},\n...     {\"name\": \"Charlie\", \"json_data\": '{\"last_name\":\"Davies\",\"age\":54}'},\n... ]\n>>> t = ibis.memtable(data, schema={\"name\": \"string\", \"json_data\": \"json\"})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'age': 40}  \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'age': 39}  \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'age': 54} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(age=t.json_data[\"age\"].int)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                          \u2503 age   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                               \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'age': 40}  \u2502    40 \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'age': 39}  \u2502    39 \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'age': 54} \u2502    54 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/json.py::float", "docstring": "Unwrap a JSON value into a backend-native float.\n\nAny non-float JSON values are returned as `NULL`.\n\n::: {.callout-warning}\n## The `float` property is lax with respect to integers\n\nThe `float` property will attempt to coerce integers to floating point numbers.\n:::\n\nExamples\n--------\n>>> import json, ibis\n>>> ibis.options.interactive = True\n>>> data = [\n...     {\"name\": \"Alice\", \"json_data\": '{\"last_name\":\"Smith\",\"salary\":42.42}'},\n...     {\"name\": \"Bob\", \"json_data\": '{\"last_name\":\"Jones\", \"salary\":37.37}'},\n...     {\"name\": \"Charlie\", \"json_data\": '{\"last_name\":\"Davies\",\"salary\":\"NA\"}'},\n...     {\"name\": \"Joan\", \"json_data\": '{\"last_name\":\"Davies\",\"salary\":78}'},\n... ]\n>>> t = ibis.memtable(data, schema={\"name\": \"string\", \"json_data\": \"json\"})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'salary': 42.42} \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'salary': 37.37} \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'salary': 'NA'} \u2502\n\u2502 Joan    \u2502 {'last_name': 'Davies', 'salary': 78}   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(salary=t.json_data[\"salary\"].float)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                               \u2503 salary  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                                    \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'salary': 42.42} \u2502   42.42 \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'salary': 37.37} \u2502   37.37 \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'salary': 'NA'} \u2502    NULL \u2502\n\u2502 Joan    \u2502 {'last_name': 'Davies', 'salary': 78}   \u2502   78.00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/json.py::bool", "docstring": "Unwrap a JSON value into a backend-native boolean.\n\nAny non-boolean JSON values are returned as `NULL`.\n\nExamples\n--------\n>>> import json, ibis\n>>> ibis.options.interactive = True\n>>> data = [\n...     {\"name\": \"Alice\", \"json_data\": '{\"last_name\":\"Smith\",\"is_bot\":false}'},\n...     {\"name\": \"Bob\", \"json_data\": '{\"last_name\":\"Jones\",\"is_bot\":true}'},\n...     {\"name\": \"Charlie\", \"json_data\": '{\"last_name\":\"Davies\",\"is_bot\":false}'},\n... ]\n>>> t = ibis.memtable(data, schema={\"name\": \"string\", \"json_data\": \"json\"})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'is_bot': False}  \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'is_bot': True}   \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'is_bot': False} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(is_bot=t.json_data[\"is_bot\"].bool)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data                                \u2503 is_bot  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                                     \u2502 boolean \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith', 'is_bot': False}  \u2502 False   \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones', 'is_bot': True}   \u2502 True    \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies', 'is_bot': False} \u2502 False   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/json.py::str", "docstring": "Unwrap a JSON string into a backend-native string.\n\nAny non-string JSON values are returned as `NULL`.\n\nReturns\n-------\nStringValue\n    A string expression\n\nExamples\n--------\n>>> import json, ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\"js\": ['\"a\"', '\"b\"', \"1\", \"{}\", '[{\"a\": 1}]']},\n...     schema=ibis.schema(dict(js=\"json\")),\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 js                   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 json                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 'a'                  \u2502\n\u2502 'b'                  \u2502\n\u2502 1                    \u2502\n\u2502 {}                   \u2502\n\u2502 [{...}]              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.js.str\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 UnwrapJSONString(js) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a                    \u2502\n\u2502 b                    \u2502\n\u2502 NULL                 \u2502\n\u2502 NULL                 \u2502\n\u2502 NULL                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nNote the difference between `.string` and `.cast(\"string\")`.\n\nThe latter preserves quotes for JSON string values and returns a valid\nJSON string.\n\n>>> t.js.cast(\"string\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Cast(js, string) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \"a\"              \u2502\n\u2502 \"b\"              \u2502\n\u2502 1                \u2502\n\u2502 {}               \u2502\n\u2502 [{\"a\": 1}]       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nHere's a more complex example with a table containing a JSON column\nwith nested fields.\n\n>>> data = [\n...     {\"name\": \"Alice\", \"json_data\": '{\"last_name\":\"Smith\"}'},\n...     {\"name\": \"Bob\", \"json_data\": '{\"last_name\":\"Jones\"}'},\n...     {\"name\": \"Charlie\", \"json_data\": '{\"last_name\":\"Davies\"}'},\n... ]\n>>> t = ibis.memtable(data, schema={\"name\": \"string\", \"json_data\": \"json\"})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith'}  \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones'}  \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies'} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(last_name=t.json_data[\"last_name\"].str)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name    \u2503 json_data               \u2503 last_name \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 json                    \u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice   \u2502 {'last_name': 'Smith'}  \u2502 Smith     \u2502\n\u2502 Bob     \u2502 {'last_name': 'Jones'}  \u2502 Jones     \u2502\n\u2502 Charlie \u2502 {'last_name': 'Davies'} \u2502 Davies    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::__getitem__", "docstring": "Index or slice a string expression.\n\nParameters\n----------\nkey\n    [](`int`), [](`slice`) or integer scalar expression\n\nReturns\n-------\nStringValue\n    Indexed or sliced string value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"food\": [\"bread\", \"cheese\", \"rice\"], \"idx\": [1, 2, 4]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 food   \u2503 idx   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 bread  \u2502     1 \u2502\n\u2502 cheese \u2502     2 \u2502\n\u2502 rice   \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.food[0]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Substring(food, 0, 1) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 b                     \u2502\n\u2502 c                     \u2502\n\u2502 r                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.food[:3]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringSlice(food, 3) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 bre                  \u2502\n\u2502 che                  \u2502\n\u2502 ric                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.food[3:5]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringSlice(food, 3, 5) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ad                      \u2502\n\u2502 es                      \u2502\n\u2502 e                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.food[7]\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Substring(food, 7, 1) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ~                     \u2502\n\u2502 ~                     \u2502\n\u2502 ~                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::length", "docstring": "Compute the length of a string.\n\nReturns\n-------\nIntegerValue\n    The length of each string in the expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aaa\", \"a\", \"aa\"]})\n>>> t.s.length()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringLength(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int32           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502               3 \u2502\n\u2502               1 \u2502\n\u2502               2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::lower", "docstring": "Convert string to all lowercase.\n\nReturns\n-------\nStringValue\n    Lowercase string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"AAA\", \"a\", \"AA\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 AAA    \u2502\n\u2502 a      \u2502\n\u2502 AA     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.lower()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Lowercase(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 aaa          \u2502\n\u2502 a            \u2502\n\u2502 aa           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::upper", "docstring": "Convert string to all uppercase.\n\nReturns\n-------\nStringValue\n    Uppercase string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aaa\", \"A\", \"aa\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 aaa    \u2502\n\u2502 A      \u2502\n\u2502 aa     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.upper()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Uppercase(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 AAA          \u2502\n\u2502 A            \u2502\n\u2502 AA           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::reverse", "docstring": "Reverse the characters of a string.\n\nReturns\n-------\nStringValue\n    Reversed string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc    \u2502\n\u2502 def    \u2502\n\u2502 ghi    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.reverse()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Reverse(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 cba        \u2502\n\u2502 fed        \u2502\n\u2502 ihg        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::ascii_str", "docstring": "Return the numeric ASCII code of the first character of a string.\n\nReturns\n-------\nIntegerValue\n    ASCII code of the first character of the input\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n>>> t.s.ascii_str()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringAscii(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int32          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             97 \u2502\n\u2502            100 \u2502\n\u2502            103 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::strip", "docstring": "Remove whitespace from left and right sides of a string.\n\nReturns\n-------\nStringValue\n    Stripped string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \\ta\\t  \u2502\n\u2502 \\nb\\n  \u2502\n\u2502 \\vc\\t  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.strip()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Strip(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a        \u2502\n\u2502 b        \u2502\n\u2502 c        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::lstrip", "docstring": "Remove whitespace from the left side of string.\n\nReturns\n-------\nStringValue\n    Left-stripped string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \\ta\\t  \u2502\n\u2502 \\nb\\n  \u2502\n\u2502 \\vc\\t  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.lstrip()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 LStrip(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a\\t       \u2502\n\u2502 b\\n       \u2502\n\u2502 c\\t       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::rstrip", "docstring": "Remove whitespace from the right side of string.\n\nReturns\n-------\nStringValue\n    Right-stripped string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \\ta\\t  \u2502\n\u2502 \\nb\\n  \u2502\n\u2502 \\vc\\t  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.rstrip()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RStrip(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \\ta       \u2502\n\u2502 \\nb       \u2502\n\u2502 \\vc       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::capitalize", "docstring": "Uppercase the first letter, lowercase the rest.\n\nThis API matches the semantics of the Python [](`str.capitalize`)\nmethod.\n\nReturns\n-------\nStringValue\n    Capitalized string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aBC\", \" abc\", \"ab cd\", None]})\n>>> t.s.capitalize()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Capitalize(s) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Abc           \u2502\n\u2502  abc          \u2502\n\u2502 Ab cd         \u2502\n\u2502 NULL          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::contains", "docstring": "Return whether the expression contains `substr`.\n\nParameters\n----------\nsubstr\n    Substring for which to check\n\nReturns\n-------\nBooleanValue\n    Boolean indicating the presence of `substr` in the expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"bab\", \"ddd\", \"eaf\"]})\n>>> t.s.contains(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringContains(s, 'a') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                   \u2502\n\u2502 False                  \u2502\n\u2502 True                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::hashbytes", "docstring": "Compute the binary hash value of the input.\n\nParameters\n----------\nhow\n    Hash algorithm to use\n\nReturns\n-------\nBinaryValue\n    Binary expression\n\nExamples\n--------\n>>> import ibis\n>>> str_lit = ibis.literal(\"hello\")\n>>> result = str_lit.hashbytes(\"md5\")  # b']A@*\\xbcK*v\\xb9q\\x9d\\x91\\x10\\x17\\xc5\\x92'", "type": "function"}
{"source": "ibis/expr/types/strings.py::hexdigest", "docstring": "Return the hash digest of the input as a hex encoded string.\n\nParameters\n----------\nhow\n    Hash algorithm to use\n\nReturns\n-------\nStringValue\n    Hexadecimal representation of the hash as a string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"species\": [\"Adelie\", \"Chinstrap\", \"Gentoo\"]})\n>>> t.species.hexdigest()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 HexDigest(species)                                               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                                                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a4d7d46b27480037bc1e513e0e157cbf258baae6ee69e3110d0f9ff418b57a3c \u2502\n\u2502 cb97d113ca69899ae4f1fb581f4a90d86989db77b4a33873d604b0ee412b4cc9 \u2502\n\u2502 b5e90cdff65949fe6bc226823245f7698110e563a12363fc57b3eed3e4a0a612 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::substr", "docstring": "Extract a substring.\n\nParameters\n----------\nstart\n    First character to start splitting, indices start at 0\nlength\n    Maximum length of each substring. If not supplied, searches the\n    entire string\n\nReturns\n-------\nStringValue\n    Found substring\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n>>> t.s.substr(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Substring(s, 2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 c               \u2502\n\u2502 fg              \u2502\n\u2502 jlk             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::left", "docstring": "Return the `nchars` left-most characters.\n\nParameters\n----------\nnchars\n    Maximum number of characters to return\n\nReturns\n-------\nStringValue\n    Characters from the start\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n>>> t.s.left(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Substring(s, 0, 2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ab                 \u2502\n\u2502 de                 \u2502\n\u2502 hi                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::right", "docstring": "Return up to `nchars` from the end of each string.\n\nParameters\n----------\nnchars\n    Maximum number of characters to return\n\nReturns\n-------\nStringValue\n    Characters from the end\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n>>> t.s.right(2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StrRight(s, 2) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 bc             \u2502\n\u2502 fg             \u2502\n\u2502 lk             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::repeat", "docstring": "Repeat a string `n` times.\n\nParameters\n----------\nn\n    Number of repetitions\n\nReturns\n-------\nStringValue\n    Repeated string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"a\", \"bb\", \"c\"]})\n>>> t.s.repeat(5)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Repeat(s, 5) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 aaaaa        \u2502\n\u2502 bbbbbbbbbb   \u2502\n\u2502 ccccc        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::translate", "docstring": "Replace `from_str` characters in `self` characters in `to_str`.\n\nTo avoid unexpected behavior, `from_str` should be shorter than\n`to_str`.\n\nParameters\n----------\nfrom_str\n    Characters in `arg` to replace\nto_str\n    Characters to use for replacement\n\nReturns\n-------\nStringValue\n    Translated string\n\nExamples\n--------\n>>> import ibis\n>>> table = ibis.table(dict(string_col=\"string\"))\n>>> result = table.string_col.translate(\"a\", \"b\")", "type": "function"}
{"source": "ibis/expr/types/strings.py::find", "docstring": "Return the position of the first occurrence of substring.\n\nParameters\n----------\nsub\n    Substring to search for\nstart\n    Zero based index of where to start the search\nend\n    Zero based index of where to stop the search. Currently not\n    implemented.\n\nReturns\n-------\nIntegerValue\n    Position of `substr` in `arg` starting from `start`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t.s.find(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringFind(s, 'a') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                  0 \u2502\n\u2502                  1 \u2502\n\u2502                  2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.find(\"z\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringFind(s, 'z') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 -1 \u2502\n\u2502                 -1 \u2502\n\u2502                 -1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::lpad", "docstring": "Pad `arg` by truncating on the right or padding on the left.\n\nParameters\n----------\nwidth\n    Length of output string\nfillchar\n    Pad character\n\nReturns\n-------\nStringValue\n    Left-padded string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n>>> t.s.lpad(5, \"-\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 LPad(s, 5, '-') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 --abc           \u2502\n\u2502 --def           \u2502\n\u2502 -ghij           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::rpad", "docstring": "Pad `self` by truncating or padding on the right.\n\nParameters\n----------\nself\n    String to pad\nwidth\n    Length of output string\nfillchar\n    Pad character\n\nReturns\n-------\nStringValue\n    Right-padded string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n>>> t.s.rpad(5, \"-\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RPad(s, 5, '-') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc--           \u2502\n\u2502 def--           \u2502\n\u2502 ghij-           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::find_in_set", "docstring": "Find the first occurrence of `str_list` within a list of strings.\n\nNo string in `str_list` can have a comma.\n\nParameters\n----------\nstr_list\n    Sequence of strings\n\nReturns\n-------\nIntegerValue\n    Position of `str_list` in `self`. Returns -1 if `self` isn't found\n    or if `self` contains `','`.\n\nExamples\n--------\n>>> import ibis\n>>> table = ibis.table(dict(string_col=\"string\"))\n>>> result = table.string_col.find_in_set([\"a\", \"b\"])", "type": "function"}
{"source": "ibis/expr/types/strings.py::join", "docstring": "Join a list of strings using `self` as the separator.\n\nParameters\n----------\nstrings\n    Strings to join with `arg`\n\nReturns\n-------\nStringValue\n    Joined string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"arr\": [[\"a\", \"b\", \"c\"], None, [], [\"b\", None]]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 arr                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b', ... +1]   \u2502\n\u2502 NULL                 \u2502\n\u2502 []                   \u2502\n\u2502 ['b', None]          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.literal(\"|\").join(t.arr)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ArrayStringJoin(arr, '|') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a|b|c                     \u2502\n\u2502 NULL                      \u2502\n\u2502 NULL                      \u2502\n\u2502 b                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n[`ArrayValue.join`](./expression-collections.qmd#ibis.expr.types.arrays.ArrayValue.join)", "type": "function"}
{"source": "ibis/expr/types/strings.py::startswith", "docstring": "Determine whether `self` starts with `start`.\n\nParameters\n----------\nstart\n    prefix to check for\n\nReturns\n-------\nBooleanValue\n    Boolean indicating whether `self` starts with `start`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.startswith(\"Ibis\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StartsWith(s, 'Ibis') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                  \u2502\n\u2502 False                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::endswith", "docstring": "Determine if `self` ends with `end`.\n\nParameters\n----------\nend\n    Suffix to check for\n\nReturns\n-------\nBooleanValue\n    Boolean indicating whether `self` ends with `end`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.endswith(\"project\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 EndsWith(s, 'project') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                   \u2502\n\u2502 False                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::like", "docstring": "Match `patterns` against `self`, case-sensitive.\n\nThis function is modeled after the SQL `LIKE` directive. Use `%` as a\nmultiple-character wildcard or `_` as a single-character wildcard.\n\nUse `re_search` or `rlike` for regular expression-based matching.\n\nParameters\n----------\npatterns\n    If `pattern` is a list, then if any pattern matches the input then\n    the corresponding row in the output is `True`.\n\nReturns\n-------\nBooleanValue\n    Column indicating matches\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.like(\"%project\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringSQLLike(s, '%project') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                         \u2502\n\u2502 False                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::ilike", "docstring": "Match `patterns` against `self`, case-insensitive.\n\nThis function is modeled after SQL's `ILIKE` directive. Use `%` as a\nmultiple-character wildcard or `_` as a single-character wildcard.\n\nUse `re_search` or `rlike` for regular expression-based matching.\n\nParameters\n----------\npatterns\n    If `pattern` is a list, then if any pattern matches the input then\n    the corresponding row in the output is `True`.\n\nReturns\n-------\nBooleanValue\n    Column indicating matches\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.ilike(\"%PROJect\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringSQLILike(s, '%PROJect') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 True                          \u2502\n\u2502 False                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::re_search", "docstring": "Return whether `self` contains the regex `pattern`.\n\nReturns `True` if the regex matches any part of a string and `False` otherwise.\n\nParameters\n----------\npattern\n    Regular expression use for searching\n\nReturns\n-------\nBooleanValue\n    Indicator of matches\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\", \"GitHub Actions\"]})\n>>> t.s.re_search(\".+Hub\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexSearch(s, '.+Hub') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 boolean                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 False                   \u2502\n\u2502 True                    \u2502\n\u2502 True                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::re_extract", "docstring": "Return the specified match at `index` from a regex `pattern`.\n\nParameters\n----------\npattern\n    Regular expression pattern string\nindex\n    The index of the match group to return.\n\n    The behavior of this function follows the behavior of Python's\n    [`match objects`](https://docs.python.org/3/library/re.html#match-objects):\n    when `index` is zero and there's a match, return the entire match,\n    otherwise return the content of the `index`-th match group.\n\nReturns\n-------\nStringValue\n    Extracted match or whole string if `index` is zero\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n\nExtract a specific group\n\n>>> t.s.re_extract(r\"^(a)bc\", 1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexExtract(s, '^(a)bc', 1) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a                            \u2502\n\u2502 ~                            \u2502\n\u2502 ~                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nExtract the entire match\n\n>>> t.s.re_extract(r\"^(a)bc\", 0)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexExtract(s, '^(a)bc', 0) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc                          \u2502\n\u2502 ~                            \u2502\n\u2502 ~                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::re_split", "docstring": "Split a string by a regular expression `pattern`.\n\nParameters\n----------\npattern\n    Regular expression string to split by\n\nReturns\n-------\nArrayValue\n    Array of strings from splitting by `pattern`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(dict(s=[\"a.b\", \"b.....c\", \"c.........a\", \"def\"]))\n>>> t.s\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a.b         \u2502\n\u2502 b.....c     \u2502\n\u2502 c.........a \u2502\n\u2502 def         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s.re_split(r\"\\.+\").name(\"splits\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 splits               \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b']           \u2502\n\u2502 ['b', 'c']           \u2502\n\u2502 ['c', 'a']           \u2502\n\u2502 ['def']              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::re_replace", "docstring": "Replace all matches found by regex `pattern` with `replacement`.\n\nParameters\n----------\npattern\n    Regular expression string\nreplacement\n    Replacement string or regular expression\n\nReturns\n-------\nStringValue\n    Modified string\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\", \"this has  multi \\t whitespace\"]})\n>>> s = t.s\n\nReplace all \"a\"s that are at the beginning of the string with \"b\":\n\n>>> s.re_replace(\"^a\", \"b\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexReplace(s, '^a', 'b')    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 bbc                           \u2502\n\u2502 bac                           \u2502\n\u2502 bca                           \u2502\n\u2502 this has  multi \\t whitespace \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDouble up any \"a\"s or \"b\"s, using capture groups and backreferences:\n\n>>> s.re_replace(\"([ab])\", r\"\\0\\0\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexReplace(s, '()', '\\\\0\\\\0')     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 aabbc                               \u2502\n\u2502 bbaac                               \u2502\n\u2502 bbcaa                               \u2502\n\u2502 this haas  multi \\t whitespaace     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nNormalize all whitespace to a single space:\n\n>>> s.re_replace(r\"\\s+\", \" \")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 RegexReplace(s, '\\\\s+', ' ') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc                          \u2502\n\u2502 bac                          \u2502\n\u2502 bca                          \u2502\n\u2502 this has multi whitespace    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::replace", "docstring": "Replace each exact match of `pattern` with `replacement`.\n\nThis method transforms strings to strings. For replacing arbitrary\ntypes, see [`Value.substitute`](./expression-generic.qmd#ibis.expr.types.generic.Value.substitute).\n\nParameters\n----------\npattern\n    String pattern\nreplacement\n    String replacement\n\nReturns\n-------\nStringValue\n    Replaced string\n\nSee Also\n--------\n[`Value.substitute`](./expression-generic.qmd#ibis.expr.types.generic.Value.substitute)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t.s.replace(\"b\", \"z\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringReplace(s, 'b', 'z') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 azc                        \u2502\n\u2502 zac                        \u2502\n\u2502 zca                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::as_timestamp", "docstring": "Parse a string and return a timestamp.\n\nParameters\n----------\nformat_str\n    Format string in `strptime` format\n\nReturns\n-------\nTimestampValue\n    Parsed timestamp value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"ts\": [\"20170206\"]})\n>>> t.ts.as_timestamp(\"%Y%m%d\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringToTimestamp(ts, '%Y%m%d') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp('UTC')                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2017-02-06 00:00:00+00:00       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::as_date", "docstring": "Parse a string and return a date.\n\nParameters\n----------\nformat_str\n    Format string in `strptime` format\n\nReturns\n-------\nDateValue\n    Parsed date value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"ts\": [\"20170206\"]})\n>>> t.ts.as_date(\"%Y%m%d\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringToDate(ts, '%Y%m%d') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2017-02-06                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::as_time", "docstring": "Parse a string and return a time.\n\nParameters\n----------\nformat_str\n    Format string in `strptime` format\n\nReturns\n-------\nTimeValue\n    Parsed time value\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"ts\": [\"20:01:02\"]})\n>>> t.ts.as_time(\"%H:%M:%S\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringToTime(ts, '%H:%M:%S') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 time                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 20:01:02                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::protocol", "docstring": "Parse a URL and extract protocol.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.protocol()  # https\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::authority", "docstring": "Parse a URL and extract authority.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.authority()  # user:pass@example.com:80\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::userinfo", "docstring": "Parse a URL and extract user info.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.userinfo()  # user:pass\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::host", "docstring": "Parse a URL and extract host.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.host()  # example.com\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::file", "docstring": "Parse a URL and extract file.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\n...     \"https://example.com:80/docs/books/tutorial/index.html?name=networking\"\n... )\n>>> result = url.file()  # docs/books/tutorial/index.html?name=networking\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::path", "docstring": "Parse a URL and extract path.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\n...     \"https://example.com:80/docs/books/tutorial/index.html?name=networking\"\n... )\n>>> result = url.path()  # docs/books/tutorial/index.html\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::query", "docstring": "Parse a URL and returns query string or query string parameter.\n\nIf key is passed, return the value of the query string parameter named.\nIf key is absent, return the query string.\n\nParameters\n----------\nkey\n    Query component to extract\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\n...     \"https://example.com:80/docs/books/tutorial/index.html?name=networking\"\n... )\n>>> result = url.query()  # name=networking\n>>> query_name = url.query(\"name\")  # networking\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::fragment", "docstring": "Parse a URL and extract fragment identifier.\n\nExamples\n--------\n>>> import ibis\n>>> url = ibis.literal(\"https://example.com:80/docs/#DOWNLOADING\")\n>>> result = url.fragment()  # DOWNLOADING\n\nReturns\n-------\nStringValue\n    Extracted string value", "type": "function"}
{"source": "ibis/expr/types/strings.py::split", "docstring": "Split as string on `delimiter`.\n\n::: {.callout-note}\n## This API only works on backends with array support.\n:::\n\nParameters\n----------\ndelimiter\n    Value to split by\n\nReturns\n-------\nArrayValue\n    The string split by `delimiter`\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"col\": [\"a,b,c\", \"d,e\", \"f\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 col    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a,b,c  \u2502\n\u2502 d,e    \u2502\n\u2502 f      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.col.split(\",\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringSplit(col, ',') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array<string>         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['a', 'b', ... +1]    \u2502\n\u2502 ['d', 'e']            \u2502\n\u2502 ['f']                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::concat", "docstring": "Concatenate strings.\n\nNULLs are propagated. This methods is equivalent to using the `+` operator.\n\nParameters\n----------\nother\n    String to concatenate\nargs\n    Additional strings to concatenate\n\nReturns\n-------\nStringValue\n    All strings concatenated\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", None]})\n>>> t.s.concat(\"xyz\", \"123\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringConcat((s, 'xyz', '123')) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abcxyz123                       \u2502\n\u2502 NULL                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s + \"xyz\"\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringConcat((s, 'xyz')) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abcxyz                   \u2502\n\u2502 NULL                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::__add__", "docstring": "Concatenate strings.\n\nParameters\n----------\nother\n    String to concatenate\n\nReturns\n-------\nStringValue\n    All strings concatenated\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc    \u2502\n\u2502 bac    \u2502\n\u2502 bca    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s + \"z\"\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringConcat((s, 'z')) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abcz                   \u2502\n\u2502 bacz                   \u2502\n\u2502 bcaz                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.s + t.s\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringConcat((s, s)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abcabc               \u2502\n\u2502 bacbac               \u2502\n\u2502 bcabca               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::__radd__", "docstring": "Concatenate strings.\n\nParameters\n----------\nother\n    String to concatenate\n\nReturns\n-------\nStringValue\n    All strings concatenated\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 s      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abc    \u2502\n\u2502 bac    \u2502\n\u2502 bca    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> \"z\" + t.s\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 StringConcat(('z', s)) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 zabc                   \u2502\n\u2502 zbac                   \u2502\n\u2502 zbca                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/types/strings.py::convert_base", "docstring": "Convert a string representing an integer from one base to another.\n\nParameters\n----------\nfrom_base\n    Numeric base of the expression\nto_base\n    New base\n\nReturns\n-------\nIntegerValue\n    Converted expression", "type": "function"}
{"source": "ibis/expr/types/strings.py::levenshtein", "docstring": "Return the Levenshtein distance between two strings.\n\nParameters\n----------\nother\n    String to compare to\n\nReturns\n-------\nIntegerValue\n    The edit distance between the two strings\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> s = ibis.literal(\"kitten\")\n>>> s.levenshtein(\"sitting\")\n\u250c\u2500\u2500\u2500\u2510\n\u2502 3 \u2502\n\u2514\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/datatypes/cast.py::cast", "docstring": "Attempts to implicitly cast from source dtype to target dtype.", "type": "function"}
{"source": "ibis/expr/datatypes/cast.py::castable", "docstring": "Return whether source ir type is implicitly castable to target.", "type": "function"}
{"source": "ibis/expr/datatypes/cast.py::highest_precedence", "docstring": "Compute the highest precedence of `dtypes`.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::dtype", "docstring": "Create a DataType object.\n\nParameters\n----------\nvalue\n    The object to coerce to an Ibis DataType. Supported inputs include\n    strings, python type annotations, numpy dtypes, pandas dtypes, and\n    pyarrow types.\nnullable\n    Whether the type should be nullable. Defaults to True.\n    If `value` is a string prefixed by \"!\", the type is always non-nullable.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.dtype(\"int32\")\nInt32(nullable=True)\n>>> ibis.dtype(\"!int32\")\nInt32(nullable=False)\n>>> ibis.dtype(\"array<float>\")\nArray(value_type=Float64(nullable=True), length=None, nullable=True)\n\nDataType objects may also be created from Python types:\n\n>>> ibis.dtype(int, nullable=False)\nInt64(nullable=False)\n>>> ibis.dtype(list[float])\nArray(value_type=Float64(nullable=True), length=None, nullable=True)\n\nOr other type systems, like numpy/pandas/pyarrow types:\n\n>>> import pyarrow as pa\n>>> ibis.dtype(pa.int32())\nInt32(nullable=True)", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::DataType", "docstring": "Base class for all data types.\n\nDon't instantiate this class directly, use the\n[ibis.dtype](./datatypes.qmd#ibis.dtype) function instead.\nInstances are immutable.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.dtype(\"int32\")\nInt32(nullable=True)\n>>> isinstance(ibis.dtype(\"int32\"), ibis.DataType)\nTrue", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Unknown", "docstring": "An unknown type.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Primitive", "docstring": "Values with known size.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Variadic", "docstring": "Values with unknown size.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Parametric", "docstring": "Types that can be parameterized.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Null", "docstring": "Null values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Boolean", "docstring": "[](`True`) or [](`False`) values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Bounds", "docstring": "The lower and upper bound of a fixed-size value.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Numeric", "docstring": "Numeric types.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Integer", "docstring": "Integer values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::String", "docstring": "A type representing a string.\n\n::: {.callout-note}\n## The `length` attribute has **no** effect on the end-user API.\n\n`length` is supported so that fixed-length strings' metadata is preserved.\n:::\n\nNotes\n-----\nBecause of differences in the way different backends handle strings, we\ncannot assume that strings are UTF-8 encoded.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Binary", "docstring": "A type representing a sequence of bytes.\n\nNotes\n-----\nSome databases treat strings and blobs of equally, and some do not.\n\nFor example, Impala doesn't make a distinction between string and binary\ntypes but PostgreSQL has a `TEXT` type and a `BYTEA` type which are\ndistinct types that have different behavior.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Temporal", "docstring": "Data types related to time.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Date", "docstring": "Date values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Time", "docstring": "Time values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Timestamp", "docstring": "Timestamp values, with a timezone and a scale.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::SignedInteger", "docstring": "Signed integer values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UnsignedInteger", "docstring": "Unsigned integer values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Floating", "docstring": "Floating point values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Int8", "docstring": "Signed 8-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Int16", "docstring": "Signed 16-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Int32", "docstring": "Signed 32-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Int64", "docstring": "Signed 64-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UInt8", "docstring": "Unsigned 8-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UInt16", "docstring": "Unsigned 16-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UInt32", "docstring": "Unsigned 32-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UInt64", "docstring": "Unsigned 64-bit integers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Float16", "docstring": "16-bit floating point numbers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Float32", "docstring": "32-bit floating point numbers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Float64", "docstring": "64-bit floating point numbers.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Decimal", "docstring": "Fixed-precision decimal values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Interval", "docstring": "Interval values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Struct", "docstring": "Structured values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Array", "docstring": "Array values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Map", "docstring": "Associative array values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::JSON", "docstring": "JSON values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::GeoSpatial", "docstring": "Geospatial values.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Point", "docstring": "A point described by two coordinates.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::LineString", "docstring": "A sequence of 2 or more points.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::Polygon", "docstring": "A set of one or more closed line strings.\n\nThe first line string represents the shape (external ring) and the\nrest represent holes in that shape (internal rings).", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::MultiLineString", "docstring": "A set of one or more line strings.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::MultiPoint", "docstring": "A set of one or more points.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::MultiPolygon", "docstring": "A set of one or more polygons.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::UUID", "docstring": "A 128-bit number used to identify information in computer systems.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::MACADDR", "docstring": "Media Access Control (MAC) address of a network interface.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::INET", "docstring": "IP addresses.", "type": "class"}
{"source": "ibis/expr/datatypes/core.py::castable", "docstring": "Check whether this type is castable to another.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_numpy", "docstring": "Return the equivalent ibis datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_pandas", "docstring": "Return the equivalent ibis datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_pyarrow", "docstring": "Return the equivalent ibis datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_polars", "docstring": "Return the equivalent ibis datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::to_numpy", "docstring": "Return the equivalent numpy datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::to_pandas", "docstring": "Return the equivalent pandas datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::to_pyarrow", "docstring": "Return the equivalent pyarrow datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::to_polars", "docstring": "Return the equivalent polars datatype.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_array", "docstring": "Return True if an instance of an Array type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_binary", "docstring": "Return True if an instance of a Binary type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_boolean", "docstring": "Return True if an instance of a Boolean type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_date", "docstring": "Return True if an instance of a Date type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_decimal", "docstring": "Return True if an instance of a Decimal type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_enum", "docstring": "Return True if an instance of an Enum type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_fixed_length_array", "docstring": "Return True if an instance of an Array type and has a known length.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_float16", "docstring": "Return True if an instance of a Float16 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_float32", "docstring": "Return True if an instance of a Float32 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_float64", "docstring": "Return True if an instance of a Float64 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_floating", "docstring": "Return True if an instance of any Floating type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_geospatial", "docstring": "Return True if an instance of a Geospatial type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_inet", "docstring": "Return True if an instance of an Inet type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_int16", "docstring": "Return True if an instance of an Int16 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_int32", "docstring": "Return True if an instance of an Int32 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_int64", "docstring": "Return True if an instance of an Int64 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_int8", "docstring": "Return True if an instance of an Int8 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_integer", "docstring": "Return True if an instance of any Integer type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_interval", "docstring": "Return True if an instance of an Interval type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_json", "docstring": "Return True if an instance of a JSON type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_linestring", "docstring": "Return True if an instance of a LineString type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_macaddr", "docstring": "Return True if an instance of a MACADDR type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_map", "docstring": "Return True if an instance of a Map type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_multilinestring", "docstring": "Return True if an instance of a MultiLineString type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_multipoint", "docstring": "Return True if an instance of a MultiPoint type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_multipolygon", "docstring": "Return True if an instance of a MultiPolygon type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_nested", "docstring": "Return true if an instance of any nested (Array/Map/Struct) type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_null", "docstring": "Return true if an instance of a Null type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_numeric", "docstring": "Return true if an instance of a Numeric type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_point", "docstring": "Return true if an instance of a Point type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_polygon", "docstring": "Return true if an instance of a Polygon type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_primitive", "docstring": "Return true if an instance of a Primitive type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_signed_integer", "docstring": "Return true if an instance of a SignedInteger type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_string", "docstring": "Return true if an instance of a String type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_struct", "docstring": "Return true if an instance of a Struct type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_temporal", "docstring": "Return true if an instance of a Temporal type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_time", "docstring": "Return true if an instance of a Time type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_timestamp", "docstring": "Return true if an instance of a Timestamp type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_uint16", "docstring": "Return true if an instance of a UInt16 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_uint32", "docstring": "Return true if an instance of a UInt32 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_uint64", "docstring": "Return true if an instance of a UInt64 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_uint8", "docstring": "Return true if an instance of a UInt8 type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_unknown", "docstring": "Return true if an instance of an Unknown type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_unsigned_integer", "docstring": "Return true if an instance of an UnsignedInteger type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_uuid", "docstring": "Return true if an instance of a UUID type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::is_variadic", "docstring": "Return true if an instance of a Variadic type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::nbytes", "docstring": "Return the number of bytes used to store values of this type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_unit", "docstring": "Return a timestamp type with the given unit and timezone.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::unit", "docstring": "Return the unit of the timestamp.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::nbytes", "docstring": "Return the number of bytes used to store values of this type.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::resolution", "docstring": "The interval unit's name.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::from_tuples", "docstring": "Construct a `Struct` type from pairs.\n\nParameters\n----------\npairs\n    An iterable of pairs of field name and type\nnullable\n    Whether the type is nullable\n\nReturns\n-------\nStruct\n    Struct data type instance", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::names", "docstring": "Return the names of the struct's fields.", "type": "function"}
{"source": "ibis/expr/datatypes/core.py::types", "docstring": "Return the types of the struct's fields.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::infer", "docstring": "Infer the corresponding ibis dtype for a python object.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::infer_struct", "docstring": "Infer the [`Struct`](./datatypes.qmd#ibis.expr.datatypes.Struct) type of `value`.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::infer_map", "docstring": "Infer the [`Map`](./datatypes.qmd#ibis.expr.datatypes.Map) type of `value`.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::infer_list", "docstring": "Infer the [`Array`](./datatypes.qmd#ibis.expr.datatypes.Array) type of `value`.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::infer_decimal", "docstring": "Infer the [`Decimal`](./datatypes.qmd#ibis.expr.datatypes.Decimal) type of `value`.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::normalize", "docstring": "Ensure that the Python type underlying a literal resolves to a single type.", "type": "function"}
{"source": "ibis/expr/datatypes/value.py::normalizable", "docstring": "Check if a value can be normalized to a given type.", "type": "function"}
{"source": "ibis/expr/datatypes/parse.py::parse", "docstring": "Parse a type from a [](`str`) `text`.\n\nThe default `maxsize` parameter for caching is chosen to cache the most\ncommonly used types--there are about 30--along with some capacity for less\ncommon but repeatedly-used complex types.\n\nParameters\n----------\ntext\n    The type string to parse\ndefault_decimal_parameters\n    Default precision and scale for decimal types\n\nExamples\n--------\nParse an array type from a string\n\n>>> import ibis\n>>> import ibis.expr.datatypes as dt\n>>> dt.parse(\"array<int64>\")\nArray(value_type=Int64(nullable=True), length=None, nullable=True)\n\nYou can avoid parsing altogether by constructing objects directly\n\n>>> import ibis\n>>> import ibis.expr.datatypes as dt\n>>> ty = dt.parse(\"array<int64>\")\n>>> ty == dt.Array(dt.int64)\nTrue", "type": "function"}
{"source": "ibis/expr/operations/arrays.py::Array", "docstring": "Construct an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayLength", "docstring": "Compute the length of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArraySlice", "docstring": "Slice an array element.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayIndex", "docstring": "Return the element of an array at some index.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayConcat", "docstring": "Concatenate two or more arrays into a single array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayRepeat", "docstring": "Repeat the elements of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayMap", "docstring": "Apply a function to every element of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayFilter", "docstring": "Filter array elements with a function.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::Unnest", "docstring": "Unnest an array value into a column.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayContains", "docstring": "Return whether an array contains a specific value.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayPosition", "docstring": "Return the position of a specific value in an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayRemove", "docstring": "Remove an element from an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayDistinct", "docstring": "Return the unique elements of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArraySort", "docstring": "Sort the values of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayUnion", "docstring": "Return the union of two arrays.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayIntersect", "docstring": "Return the intersection of two arrays.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayZip", "docstring": "Zip two or more arrays into an array of structs.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayFlatten", "docstring": "Flatten a nested array one level.\n\nThe input expression must have at least one level of nesting for flattening\nto make sense.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::Range", "docstring": "Base class for range-generating operations.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::IntegerRange", "docstring": "Produce an array of integers from `start` to `stop`, moving by `step`.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::TimestampRange", "docstring": "Produce an array of timestamps from `start` to `stop`, moving by `step`.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayMin", "docstring": "Compute the minimum value of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayMax", "docstring": "Compute the maximum value of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayMode", "docstring": "Compute the mode of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArraySum", "docstring": "Compute the sum of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayMean", "docstring": "Compute the average of an array.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayAny", "docstring": "Compute whether any array element is true.", "type": "class"}
{"source": "ibis/expr/operations/arrays.py::ArrayAll", "docstring": "Compute whether all array elements are true.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::Map", "docstring": "Construct a map.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapLength", "docstring": "Compute the number of unique keys in a map.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapGet", "docstring": "Get a value from a map by key.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapContains", "docstring": "Check if a map contains a key.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapKeys", "docstring": "Get the keys of a map as an array.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapValues", "docstring": "Get the values of a map as an array.", "type": "class"}
{"source": "ibis/expr/operations/maps.py::MapMerge", "docstring": "Combine two maps into one.\n\nIf a key is present in both maps, the value from the first is kept.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampTruncate", "docstring": "Truncate a timestamp to a specified unit.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateTruncate", "docstring": "Truncate a date to a specified unit.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeTruncate", "docstring": "Truncate a time to a specified unit.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampBucket", "docstring": "Bucketize a timestamp to a specified interval.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::Strftime", "docstring": "Format a temporal value as a string.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::StringToTimestamp", "docstring": "Convert a string to a timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::StringToDate", "docstring": "Convert a string to a date.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::StringToTime", "docstring": "Convert a string to a time.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractTemporalField", "docstring": "Extract a field from a temporal value.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractDateField", "docstring": "Extract a field from a date.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractTimeField", "docstring": "Extract a field from a time.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractYear", "docstring": "Extract the year from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractIsoYear", "docstring": "Extract the ISO year from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractMonth", "docstring": "Extract the month from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractDay", "docstring": "Extract the day from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractDayOfYear", "docstring": "Extract the day of the year from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractQuarter", "docstring": "Extract the quarter from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractEpochSeconds", "docstring": "Extract seconds since the UNIX epoch from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractWeekOfYear", "docstring": "Extract the week of the year from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractHour", "docstring": "Extract the hour from a time or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractMinute", "docstring": "Extract the minute from a time or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractSecond", "docstring": "Extract the second from a time or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractMillisecond", "docstring": "Extract milliseconds from a time or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::ExtractMicrosecond", "docstring": "Extract microseconds from a time or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DayOfWeekIndex", "docstring": "Extract the index of the day of the week from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DayOfWeekName", "docstring": "Extract the name of the day of the week from a date or timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::Time", "docstring": "Extract the time from a timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::Date", "docstring": "Extract the date from a timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateFromYMD", "docstring": "Construct a date from year, month, and day.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeFromHMS", "docstring": "Construct a time from hours, minutes, and seconds.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampFromYMDHMS", "docstring": "Construct a timestamp from components.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampFromUNIX", "docstring": "Construct a timestamp from a UNIX timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateAdd", "docstring": "Add an interval to a date.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateSub", "docstring": "Subtract an interval from a date.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateDiff", "docstring": "Compute the difference between two dates.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeAdd", "docstring": "Add an interval to a time.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeSub", "docstring": "Subtract an interval from a time.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeDiff", "docstring": "Compute the difference between two times.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampAdd", "docstring": "Add an interval to a timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampSub", "docstring": "Subtract an interval from a timestamp.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampDiff", "docstring": "Compute the difference between two timestamps.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalBinary", "docstring": "Base class for interval binary operations.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalAdd", "docstring": "Add two intervals.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalSubtract", "docstring": "Subtract one interval from another.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalMultiply", "docstring": "Multiply an interval by a scalar.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalFloorDivide", "docstring": "Divide an interval by a scalar, rounding down.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::IntervalFromInteger", "docstring": "Construct an interval from an integer.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::BetweenTime", "docstring": "Check if a time is between two bounds.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TemporalDelta", "docstring": "Base class for temporal delta operations.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimeDelta", "docstring": "Compute the difference between two times as integer number of requested units.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::DateDelta", "docstring": "Compute the difference between two dates as integer number of requested units.", "type": "class"}
{"source": "ibis/expr/operations/temporal.py::TimestampDelta", "docstring": "Compute the difference between two timestamps as integer number of requested units.", "type": "class"}
{"source": "ibis/expr/operations/histograms.py::Bucket", "docstring": "Compute the bucket number of a numeric column.", "type": "class"}
{"source": "ibis/expr/operations/vectorized.py::ElementWiseVectorizedUDF", "docstring": "Node for element wise UDF.", "type": "class"}
{"source": "ibis/expr/operations/vectorized.py::ReductionVectorizedUDF", "docstring": "Node for reduction UDF.", "type": "class"}
{"source": "ibis/expr/operations/vectorized.py::AnalyticVectorizedUDF", "docstring": "Node for analytics UDF.", "type": "class"}
{"source": "ibis/expr/operations/window.py::WindowBoundary", "docstring": "Window boundary object.", "type": "class"}
{"source": "ibis/expr/operations/window.py::WindowFunction", "docstring": "Window function operation.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::LogicalBinary", "docstring": "Base class for logical binary operations.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Not", "docstring": "Logical negation.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::And", "docstring": "Logical AND.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Or", "docstring": "Logical OR.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Xor", "docstring": "Logical XOR.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Comparison", "docstring": "Base class for comparison operations.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Equals", "docstring": "Equality comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::NotEquals", "docstring": "Inequality comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::GreaterEqual", "docstring": "Greater than or equal to comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Greater", "docstring": "Greater than comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::LessEqual", "docstring": "Less than or equal to comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Less", "docstring": "Less than comparison.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::IdenticalTo", "docstring": "Identity comparison. Considers two NULL values **equal**.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::Between", "docstring": "Check if a value is within a range.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::InValues", "docstring": "Check if a value is in a set of values.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::IfElse", "docstring": "Ternary case expression.\n\nEquivalent to\n\n```python\nbool_expr.cases((True, true_expr), else_=false_or_null_expr)\n```\n\nMany backends implement this as a built-in function.", "type": "class"}
{"source": "ibis/expr/operations/logical.py::__init__", "docstring": "Construct a comparison operation between `left` and `right`.\n\nCasting rules for type promotions (for resolving the output type) may\ndepend on the target backend.\n\nTODO: how are overflows handled? Can we provide anything useful in\nIbis to help the user avoid them?", "type": "function"}
{"source": "ibis/expr/operations/subqueries.py::Subquery", "docstring": "Base class for subquery operations.", "type": "class"}
{"source": "ibis/expr/operations/subqueries.py::ExistsSubquery", "docstring": "Check if a subquery returns any rows.", "type": "class"}
{"source": "ibis/expr/operations/subqueries.py::ScalarSubquery", "docstring": "A subquery that returns a single scalar value.", "type": "class"}
{"source": "ibis/expr/operations/subqueries.py::InSubquery", "docstring": "Check if a value is in the result of a subquery.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Relation", "docstring": "Base class for relational operations.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Field", "docstring": "A field of a relation.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Project", "docstring": "Project a subset of columns from a relation.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::DropColumns", "docstring": "Drop columns from a relation.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::SelfReference", "docstring": "A self-referential relation.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Sort", "docstring": "Sort a table by a set of keys.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Filter", "docstring": "Filter a table by a set of predicates.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Limit", "docstring": "Limit and/or offset the number of records in a table.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Aggregate", "docstring": "Aggregate a table by a set of group by columns and metrics.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Set", "docstring": "Base class for set operations.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Union", "docstring": "Union two tables.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Intersection", "docstring": "Intersect two tables.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Difference", "docstring": "Subtract one table from another.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::PhysicalTable", "docstring": "Base class for tables with a name.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Namespace", "docstring": "Object to model namespaces for tables.\n\nMaps to the concept of database and/or catalog in SQL databases that support\nthem.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::UnboundTable", "docstring": "A table that is not bound to a specific backend.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::DatabaseTable", "docstring": "A table that is bound to a specific backend.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::InMemoryTable", "docstring": "A table whose data is stored in memory.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::SQLQueryResult", "docstring": "A table sourced from the result set of a SQL SELECT statement.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::View", "docstring": "A view created from an expression.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::SQLStringView", "docstring": "A view created from a SQL string.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::DummyTable", "docstring": "A table constructed from literal values.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::FillNull", "docstring": "Fill null values in the table.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::DropNull", "docstring": "Drop null values in the table.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Sample", "docstring": "Sample performs random sampling of records in a table.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::Distinct", "docstring": "Compute the distinct rows of a table.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::TableUnnest", "docstring": "Cross join unnest operation.", "type": "class"}
{"source": "ibis/expr/operations/relations.py::values", "docstring": "A mapping of column names to expressions which build up the relation.\n\nThis attribute is heavily used in rewrites as well as during field\ndereferencing in the API layer. The returned expressions must only\noriginate from parent relations, depending on the relation type.", "type": "function"}
{"source": "ibis/expr/operations/relations.py::schema", "docstring": "The schema of the relation.\n\nAll relations must have a well-defined schema.", "type": "function"}
{"source": "ibis/expr/operations/relations.py::fields", "docstring": "A mapping of column names to fields of the relation.\n\nThis calculated property shouldn't be overridden in subclasses since it\nis mostly used for convenience.", "type": "function"}
{"source": "ibis/expr/operations/generic.py::RowID", "docstring": "The row number of the returned result.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Cast", "docstring": "Explicitly cast a value to a specific data type.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::TryCast", "docstring": "Try to cast a value to a specific data type.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::TypeOf", "docstring": "Return the _database_ data type of the input expression.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::IsNull", "docstring": "Return true if values are null.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::NotNull", "docstring": "Returns true if values are not null.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::NullIf", "docstring": "Return NULL if an expression equals some specific value.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Coalesce", "docstring": "Return the first non-null expression from a tuple of expressions.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Greatest", "docstring": "Return the largest value from a tuple of expressions.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Least", "docstring": "Return the smallest value from a tuple of expressions.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Literal", "docstring": "A constant value.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Constant", "docstring": "A function that produces a constant.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::TimestampNow", "docstring": "Return the current timestamp.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::DateNow", "docstring": "Return the current date.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::RandomScalar", "docstring": "Return a random scalar between 0 and 1.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::RandomUUID", "docstring": "Return a random UUID.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::E", "docstring": "The mathematical constant e.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Pi", "docstring": "The mathematical constant pi.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::Hash", "docstring": "Return the hash of a value.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::HexDigest", "docstring": "Return the hexadecimal digest of a value.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::SimpleCase", "docstring": "Simple case statement.", "type": "class"}
{"source": "ibis/expr/operations/generic.py::SearchedCase", "docstring": "Searched case statement.", "type": "class"}
{"source": "ibis/expr/operations/core.py::Unary", "docstring": "A unary operation.", "type": "class"}
{"source": "ibis/expr/operations/core.py::Binary", "docstring": "A binary operation.", "type": "class"}
{"source": "ibis/expr/operations/core.py::dtype", "docstring": "Ibis datatype of the produced value expression.\n\nReturns\n-------\ndt.DataType", "type": "function"}
{"source": "ibis/expr/operations/core.py::shape", "docstring": "Shape of the produced value expression.\n\nPossible values are: \"scalar\" and \"columnar\"\n\nReturns\n-------\nds.Shape", "type": "function"}
{"source": "ibis/expr/operations/core.py::relations", "docstring": "Set of relations the value node depends on.", "type": "function"}
{"source": "ibis/expr/operations/structs.py::StructField", "docstring": "Extract a field from a struct value.", "type": "class"}
{"source": "ibis/expr/operations/structs.py::StructColumn", "docstring": "Construct a struct column from literals or expressions.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoSpatialBinOp", "docstring": "Geo Spatial base binary.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoSpatialUnOp", "docstring": "Geo Spatial base unary.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoDistance", "docstring": "Returns minimum distance between two geospatial operands.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoContains", "docstring": "Check if the first geo spatial data contains the second one.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoContainsProperly", "docstring": "Check if the left value contains the right one, with no shared no boundary points.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoCovers", "docstring": "Check if no point in the right operand is outside that of the left.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoCoveredBy", "docstring": "Check if no point in the left operand is outside that of the right.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoCrosses", "docstring": "Check if the inputs have some but not all interior points in common.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoDisjoint", "docstring": "Check if the Geometries do not spatially intersect.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoEquals", "docstring": "Returns True if the given geometries represent the same geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoGeometryN", "docstring": "Returns the Nth Geometry of a Multi geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoGeometryType", "docstring": "Returns the type of the geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoIntersects", "docstring": "Returns True if the Geometries/Geography \u201cspatially intersect in 2D\u201d.\n\n- (share any portion of space) and False if they don`t (they are Disjoint).", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoIsValid", "docstring": "Returns true if the geometry is well-formed.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoLineLocatePoint", "docstring": "Locate the distance a point falls along the length of a line.\n\nReturns a float between zero and one representing the location of\nthe closest point on the linestring to the given point, as a\nfraction of the total 2d line length.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoLineMerge", "docstring": "Merge a MultiLineString into a LineString.\n\nReturns a (set of) LineString(s) formed by sewing together the\nconstituent line work of a multilinestring. If a geometry other than\na linestring or multilinestring is given, this will return an empty\ngeometry collection.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoLineSubstring", "docstring": "Clip a substring from a LineString.\n\nReturns a linestring that is a substring of the input one, starting\nand ending at the given fractions of the total 2d length. The second\nand third arguments are floating point values between zero and one.\nThis only works with linestrings.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoOrderingEquals", "docstring": "Check if two geometries are equal and have the same point ordering.\n\nReturns true if the two geometries are equal and the coordinates are\nin the same order.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoOverlaps", "docstring": "Check if the inputs are of the same dimension but are not completely contained by each other.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoTouches", "docstring": "Check if the inputs have at least one point in common but their interiors do not intersect.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoUnaryUnion", "docstring": "Returns the pointwise union of the geometries in the column.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoUnion", "docstring": "Returns the pointwise union of the two geometries.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoArea", "docstring": "Area of the geo spatial data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoPerimeter", "docstring": "Perimeter of the geo spatial data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoLength", "docstring": "Length of geo spatial data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoMaxDistance", "docstring": "Returns the 2-dimensional max distance between two geometries in projected units.\n\nIf g1 and g2 is the same geometry the function will return the\ndistance between the two vertices most far from each other in that\ngeometry", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoX", "docstring": "Return the X coordinate of the point, or NULL if not available.\n\nInput must be a point", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoY", "docstring": "Return the Y coordinate of the point, or NULL if not available.\n\nInput must be a point", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoXMin", "docstring": "Returns Y minima of a bounding box 2d or 3d or a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoXMax", "docstring": "Returns X maxima of a bounding box 2d or 3d or a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoYMin", "docstring": "Returns Y minima of a bounding box 2d or 3d or a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoYMax", "docstring": "Returns Y maxima of a bounding box 2d or 3d or a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoStartPoint", "docstring": "Return the first point of a `LINESTRING` geometry as a POINT.\n\nReturns `NULL` if the input is not a LINESTRING.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoEndPoint", "docstring": "Return the last point of a `LINESTRING` geometry as a POINT.\n\nReturns `NULL` if the input is not a LINESTRING.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoPoint", "docstring": "Return a point constructed from the input coordinate values.\n\nConstant coordinates result in construction of a POINT literal.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoPointN", "docstring": "Return the Nth point in a single linestring in the geometry.\n\nNegative values are counted backwards from the end of the\nLineString, so that -1 is the last point. Returns NULL if there is\nno linestring in the geometry", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoNPoints", "docstring": "Return the number of points in a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoNRings", "docstring": "Return the number of rings for polygons or multipolygons.\n\nOuter rings are counted.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoSRID", "docstring": "Returns the spatial reference identifier for the ST_Geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoSetSRID", "docstring": "Set the spatial reference identifier for the ST_Geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoBuffer", "docstring": "Return all points whose distance from this geometry is less than or equal to `radius`.\n\nCalculations are in the Spatial Reference System of this geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoCentroid", "docstring": "Returns the geometric center of a geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoDFullyWithin", "docstring": "Check if the geometries are fully within `distance` of one another.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoDWithin", "docstring": "Check if the geometries are within `distance` of one another.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoEnvelope", "docstring": "The bounding box of the supplied geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoAzimuth", "docstring": "Return the angle in radians from the horizontal of the vector defined by the two inputs.\n\nAngle is computed clockwise from down-to-up: on the clock: 12=0;\n3=PI/2; 6=PI; 9=3PI/2.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoWithin", "docstring": "Returns True if the geometry A is completely inside geometry B.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoIntersection", "docstring": "Return a geometry that represents the point-set intersection of the inputs.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoDifference", "docstring": "Return a geometry that is the delta between the left and right inputs.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoSimplify", "docstring": "Returns a simplified version of the given geometry.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoTransform", "docstring": "Returns a transformed version of the given geometry into a new SRID.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoConvert", "docstring": "Returns a transformed version of the given geometry from source crs/srid to a target crs/srid.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoAsBinary", "docstring": "Return the Well-Known Binary (WKB) representation of the input, without SRID meta data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoAsEWKB", "docstring": "Return the Well-Known Binary representation of the input, with SRID meta data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoAsEWKT", "docstring": "Return the Well-Known Text representation of the input, with SRID meta data.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoAsText", "docstring": "Return the Well-Known Text (WKT) representation of the input, without SRID metadata.", "type": "class"}
{"source": "ibis/expr/operations/geospatial.py::GeoFlipCoordinates", "docstring": "Returns a new geometry with the coordinates of the input geometry \"flipped\" so that x = y and y = x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Add", "docstring": "Add two values.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Multiply", "docstring": "Multiply two values.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Power", "docstring": "Raise the left value to the power of the right value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Subtract", "docstring": "Subtract the right value from the left value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Divide", "docstring": "Divide the left value by the right value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::FloorDivide", "docstring": "Divide the left value by the right value and round down to the nearest integer.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Modulus", "docstring": "Return the remainder after the division of the left value by the right value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Negate", "docstring": "Negate the value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::IsNan", "docstring": "Check if the value is NaN.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::IsInf", "docstring": "Check if the value is infinite.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Abs", "docstring": "Absolute value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Ceil", "docstring": "Round up to the nearest integer value greater than or equal to this value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Floor", "docstring": "Round down to the nearest integer value less than or equal to this value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Round", "docstring": "Round a value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Clip", "docstring": "Clip a value to a specified range.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BaseConvert", "docstring": "Convert a number from one base to another.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::MathUnary", "docstring": "Base class for unary math operations.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Exp", "docstring": "Exponential function.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Sign", "docstring": "Sign of the value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Sqrt", "docstring": "Square root of the value.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Logarithm", "docstring": "Base class for logarithmic operations.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Log", "docstring": "Logarithm with a specific base.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Ln", "docstring": "Natural logarithm.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Log2", "docstring": "Logarithm base 2.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Log10", "docstring": "Logarithm base 10.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Degrees", "docstring": "Converts radians to degrees.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Radians", "docstring": "Converts degrees to radians.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::TrigonometricUnary", "docstring": "Trigonometric base unary.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::TrigonometricBinary", "docstring": "Trigonometric base binary.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Acos", "docstring": "Returns the arc cosine of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Asin", "docstring": "Returns the arc sine of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Atan", "docstring": "Returns the arc tangent of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Atan2", "docstring": "Returns the arc tangent of x and y.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Cos", "docstring": "Returns the cosine of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Cot", "docstring": "Returns the cotangent of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Sin", "docstring": "Returns the sine of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::Tan", "docstring": "Returns the tangent of x.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseNot", "docstring": "Bitwise NOT operation.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseBinary", "docstring": "Base class for bitwise binary operations.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseAnd", "docstring": "Bitwise AND operation.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseOr", "docstring": "Bitwise OR operation.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseXor", "docstring": "Bitwise XOR operation.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseLeftShift", "docstring": "Bitwise left shift operation.", "type": "class"}
{"source": "ibis/expr/operations/numeric.py::BitwiseRightShift", "docstring": "Bitwise right shift operation.", "type": "class"}
{"source": "ibis/expr/operations/sortkeys.py::SortKey", "docstring": "A sort key.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Reduction", "docstring": "Base class for reduction operations.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Count", "docstring": "Count the number of non-null elements of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::CountStar", "docstring": "Count the number of rows of a relation.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::CountDistinctStar", "docstring": "Count the number of distinct rows of a relation.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Arbitrary", "docstring": "Retrieve an arbitrary element.\n\nReturns a non-null value unless the column is empty or all values are NULL.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::First", "docstring": "Retrieve the first element.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Last", "docstring": "Retrieve the last element.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::BitAnd", "docstring": "Aggregate bitwise AND operation.\n\nAll elements in an integer column are ANDed together.\n\nThis can be used to determine which bit flags are set on all elements.\n\nSee Also\n--------\n* BigQuery [`BIT_AND`](https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#bit_and)\n* MySQL [`BIT_AND`](https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_bit-and)", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::BitOr", "docstring": "Aggregate bitwise OR operation.\n\nAll elements in an integer column are ORed together. This can be used\nto determine which bit flags are set on any element.\n\nSee Also\n--------\n* BigQuery [`BIT_OR`](https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#bit_or)\n* MySQL [`BIT_OR`](https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_bit-or)", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::BitXor", "docstring": "Aggregate bitwise XOR operation.\n\nAll elements in an integer column are XORed together. This can be used\nas a parity checksum of element values.\n\nSee Also\n--------\n* BigQuery [`BIT_XOR`](https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#bit_xor)\n* MySQL [`BIT_XOR`](https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_bit-xor)", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Sum", "docstring": "Compute the sum of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Mean", "docstring": "Compute the mean of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Median", "docstring": "Compute the median of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ApproxMedian", "docstring": "Compute the approximate median of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Quantile", "docstring": "Compute the quantile of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ApproxQuantile", "docstring": "Compute the approximate quantile of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::MultiQuantile", "docstring": "Compute multiple quantiles of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ApproxMultiQuantile", "docstring": "Compute multiple approximate quantiles of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::VarianceBase", "docstring": "Base class for variance and standard deviation.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::StandardDev", "docstring": "Compute the standard deviation of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Variance", "docstring": "Compute the variance of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Correlation", "docstring": "Correlation coefficient of two columns.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Covariance", "docstring": "Covariance of two columns.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Kurtosis", "docstring": "Compute the kurtosis of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Mode", "docstring": "Compute the mode of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Max", "docstring": "Compute the maximum of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Min", "docstring": "Compute the minimum of a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ArgMax", "docstring": "Compute the index of the maximum value in a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ArgMin", "docstring": "Compute the index of the minimum value in a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::GroupConcat", "docstring": "Concatenate strings in a group with a given separator character.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::CountDistinct", "docstring": "Count the number of distinct values in a column.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ApproxCountDistinct", "docstring": "Approximate number of unique values.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::ArrayCollect", "docstring": "Collect values into an array.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::All", "docstring": "Check if all values in a column are true.", "type": "class"}
{"source": "ibis/expr/operations/reductions.py::Any", "docstring": "Check if any value in a column is true.", "type": "class"}
{"source": "ibis/expr/operations/udf.py::_wrap", "docstring": "Wrap a function `fn` with `wrapper`, allowing zero arguments when used as part of a decorator.", "type": "function"}
{"source": "ibis/expr/operations/udf.py::scalar", "docstring": "Scalar user-defined functions.\n\n::: {.callout-note}\n## The `scalar` class itself is **not** a public API, its methods are.\n:::", "type": "class"}
{"source": "ibis/expr/operations/udf.py::agg", "docstring": "Aggregate user-defined functions.\n\n::: {.callout-note}\n## The `agg` class itself is **not** a public API, its methods are.\n:::", "type": "class"}
{"source": "ibis/expr/operations/udf.py::_base", "docstring": "Base class of the UDF.", "type": "function"}
{"source": "ibis/expr/operations/udf.py::_make_node", "docstring": "Construct a scalar user-defined function that is built-in to the backend.", "type": "function"}
{"source": "ibis/expr/operations/udf.py::builtin", "docstring": "Construct a scalar user-defined function that is built-in to the backend.\n\nParameters\n----------\nfn\n    The function to wrap.\nname\n    The name of the UDF in the backend if different from the function name.\ndatabase\n    The database in which the builtin function resides.\ncatalog\n    The catalog in which the builtin function resides.\nsignature\n    If present, a tuple of the form `((arg0type, arg1type, ...), returntype)`.\n    For example, a function taking an int and a float and returning a\n    string would be `((int, float), str)`. If not present, the signature\n    will be derived from the type annotations of the wrapped function.\n\n    For **builtin** UDFs, only the **return type** annotation is required.\n    See [the user guide](/how-to/extending/builtin.qmd#input-types) for\n    more information.\nkwargs\n    Additional backend-specific configuration arguments for the UDF.\n\nExamples\n--------\n>>> import ibis\n>>> @ibis.udf.scalar.builtin\n... def hamming(a: str, b: str) -> int:\n...     '''Compute the Hamming distance between two strings.'''\n>>> expr = hamming(\"duck\", \"luck\")\n>>> con = ibis.connect(\"duckdb://\")\n>>> con.execute(expr)\n1", "type": "function"}
{"source": "ibis/expr/operations/udf.py::python", "docstring": "Construct a **non-vectorized** scalar user-defined function that accepts Python scalar values as inputs.\n\n::: {.callout-warning collapse=\"true\"}\n## `python` UDFs are likely to be slow\n\n`python` UDFs are not vectorized: they are executed row by row with one\nPython function call per row\n\nThis calling pattern tends to be **much** slower than\n[`pandas`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pandas)\nor\n[`pyarrow`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pyarrow)-based\nvectorized UDFs.\n:::\n\nParameters\n----------\nfn\n    The function to wrap.\nname\n    The name of the UDF in the backend if different from the function name.\ndatabase\n    The database in which to create the UDF.\ncatalog\n    The catalog in which to create the UDF.\nsignature\n    If present, a tuple of the form `((arg0type, arg1type, ...), returntype)`.\n    For example, a function taking an int and a float and returning a\n    string would be `((int, float), str)`. If not present, the signature\n    will be derived from the type annotations of the wrapped function.\nkwargs\n    Additional backend-specific configuration arguments for the UDF.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(dict(int_col=[1, 2, 3], str_col=[\"a\", \"b\", \"c\"]))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 int_col \u2503 str_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502 a       \u2502\n\u2502       2 \u2502 b       \u2502\n\u2502       3 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> @ibis.udf.scalar.python\n... def str_magic(x: str) -> str:\n...     return f\"{x}_magic\"\n>>> @ibis.udf.scalar.python\n... def add_one_py(x: int) -> int:\n...     return x + 1\n>>> str_magic(t.str_col)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 str_magic_0(str_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a_magic              \u2502\n\u2502 b_magic              \u2502\n\u2502 c_magic              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> add_one_py(t.int_col)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 add_one_py_0(int_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     2 \u2502\n\u2502                     3 \u2502\n\u2502                     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDefine a UDF that adds one to an integer field that is part of a struct:\n\n>>> import ibis.expr.datatypes as dt\n>>> FieldType = dt.Struct({\"a\": \"int\"})\n>>> @ibis.udf.scalar.python\n... def add_one_py_struct(x: FieldType) -> int:\n...     return x[\"a\"] + 1\n>>> t = ibis.memtable({\"struct_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]})\n>>> add_one_py_struct(t.struct_col).name(\"added_one\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 added_one \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         2 \u2502\n\u2502         3 \u2502\n\u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSimilarly, you can operate on maps as well:\n\n>>> FieldType = dt.Map(dt.string, dt.int64)\n>>> @ibis.udf.scalar.python\n... def add_one_py_map(x: FieldType) -> int:\n...     return x[\"a\"] + 1\n>>> t = ibis.memtable(\n...     {\"map_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]},\n...     schema={\"map_col\": \"map<string, int>\"},\n... )\n>>> add_one_py_map(t.map_col).name(\"added_one\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 added_one \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         2 \u2502\n\u2502         3 \u2502\n\u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n- [`pandas`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pandas)\n- [`pyarrow`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pyarrow)", "type": "function"}
{"source": "ibis/expr/operations/udf.py::pandas", "docstring": "Construct a **vectorized** scalar user-defined function that accepts pandas Series' as inputs.\n\nParameters\n----------\nfn\n    The function to wrap.\nname\n    The name of the UDF in the backend if different from the function name.\ndatabase\n    The database in which to create the UDF.\ncatalog\n    The catalog in which to create the UDF.\nsignature\n    If present, a tuple of the form `((arg0type, arg1type, ...), returntype)`.\n    For example, a function taking an int and a float and returning a\n    string would be `((int, float), str)`. If not present, the signature\n    will be derived from the type annotations of the wrapped function.\nkwargs\n    Additional backend-specific configuration arguments for the UDF.\n\nExamples\n--------\n```python\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(dict(int_col=[1, 2, 3], str_col=[\"a\", \"b\", \"c\"]))\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 int_col \u2503 str_col \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 string  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502 a       \u2502\n\u2502       2 \u2502 b       \u2502\n\u2502       3 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> @ibis.udf.scalar.pandas\n... def str_cap(x: str) -> str:\n...     # note usage of pandas `str` method\n...     return x.str.capitalize()\n>>> str_cap(t.str_col)  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 string_cap_0(str_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 A                     \u2502\n\u2502 B                     \u2502\n\u2502 C                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nDefine a UDF that adds one to an integer field that is part of a struct:\n\n>>> import ibis.expr.datatypes as dt\n>>> FieldType = dt.Struct({\"a\": \"int\"})\n>>> @ibis.udf.scalar.pandas\n... def add_one_py_struct(x: FieldType) -> int:\n...     return x[\"a\"] + 1\n>>> t = ibis.memtable({\"struct_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]})\n>>> con = ibis.pyspark.connect()\n>>> expr = add_one_py_struct(t.struct_col).name(\"added_one\")\n>>> con.execute(expr)\n0    2\n1    3\n2    4\nName: added_one, dtype: int64\n\nSimilarly, you can operate on maps as well:\n\n>>> FieldType = dt.Map(dt.string, dt.int64)\n>>> @ibis.udf.scalar.pandas\n... def add_one_py_map(x: FieldType) -> int:\n...     return x.map(lambda d: d[\"a\"] + 1)\n>>> t = ibis.memtable(\n...     {\"map_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]},\n...     schema={\"map_col\": \"map<string, int>\"},\n... )\n>>> expr = add_one_py_map(t.map_col).name(\"added_one\")\n>>> con.execute(expr)\n0    2\n1    3\n2    4\nName: added_one, dtype: int64\n\nSee Also\n--------\n- [`python`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.python)\n- [`pyarrow`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pyarrow)", "type": "function"}
{"source": "ibis/expr/operations/udf.py::pyarrow", "docstring": "Construct a **vectorized** scalar user-defined function that accepts PyArrow Arrays as input.\n\nParameters\n----------\nfn\n    The function to wrap.\nname\n    The name of the UDF in the backend if different from the function name.\ndatabase\n    The database in which to create the UDF.\ncatalog\n    The catalog in which to create the UDF.\nsignature\n    If present, a tuple of the form `((arg0type, arg1type, ...), returntype)`.\n    For example, a function taking an int and a float and returning a\n    string would be `((int, float), str)`. If not present, the signature\n    will be derived from the type annotations of the wrapped function.\nkwargs\n    Additional backend-specific configuration arguments for the UDF.\n\nExamples\n--------\n>>> import ibis\n>>> import pyarrow.compute as pc\n>>> from datetime import date\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     dict(start_col=[date(2024, 4, 29)], end_col=[date(2025, 4, 29)]),\n... )\n>>> @ibis.udf.scalar.pyarrow\n... def weeks_between(start: date, end: date) -> int:\n...     return pc.weeks_between(start, end)\n>>> weeks_between(t.start_col, t.end_col)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 weeks_between_0(start_col, end_col) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                  52 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDefine a UDF that adds one to an integer field that is part of a struct:\n\n>>> import pyarrow.compute as pac\n>>> import ibis.expr.datatypes as dt\n>>> FieldType = dt.Struct({\"a\": \"int\"})\n>>> @ibis.udf.scalar.pyarrow\n... def add_one_py_struct(x: FieldType) -> int:\n...     return pac.add(x.combine_chunks().field(\"a\"), 1)\n>>> t = ibis.memtable({\"struct_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]})\n>>> add_one_py_struct(t.struct_col).name(\"added_one\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 added_one \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         2 \u2502\n\u2502         3 \u2502\n\u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSimilarly, you can operate on maps as well:\n\n>>> FieldType = dt.Map(dt.string, dt.int64)\n>>> @ibis.udf.scalar.pyarrow\n... def add_one_py_map(x: FieldType) -> int:\n...     return pac.add(pac.map_lookup(x, \"a\", occurrence=\"first\"), 1)\n>>> t = ibis.memtable(\n...     {\"map_col\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]},\n...     schema={\"map_col\": \"map<string, int>\"},\n... )\n>>> add_one_py_map(t.map_col).name(\"added_one\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 added_one \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         2 \u2502\n\u2502         3 \u2502\n\u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSee Also\n--------\n- [`python`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.python)\n- [`pandas`](/reference/scalar-udfs.qmd#ibis.expr.operations.udf.scalar.pandas)", "type": "function"}
{"source": "ibis/expr/operations/udf.py::builtin", "docstring": "Construct an aggregate user-defined function that is built-in to the backend.\n\nParameters\n----------\nfn\n    The function to wrap.\nname\n    The name of the UDF in the backend if different from the function name.\ndatabase\n    The database in which the builtin function resides.\ncatalog\n    The catalog in which the builtin function resides.\nsignature\n    If present, a tuple of the form `((arg0type, arg1type, ...), returntype)`.\n    For example, a function taking an int and a float and returning a\n    string would be `((int, float), str)`. If not present, the signature\n    will be derived from the type annotations of the wrapped function.\nkwargs\n    Additional backend-specific configuration arguments for the UDF.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> @ibis.udf.agg.builtin\n... def favg(a: float) -> float:\n...     '''Compute the average of a column using Kahan summation.'''\n>>> t = ibis.examples.penguins.fetch()\n>>> favg(t.bill_length_mm)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 43.92193 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/expr/operations/analytic.py::Analytic", "docstring": "Base class for analytic window function operations.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::ShiftBase", "docstring": "Base class for shift operations.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::Lag", "docstring": "Shift a column forward.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::Lead", "docstring": "Shift a column backward.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::RankBase", "docstring": "Base class for ranking operations.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::MinRank", "docstring": "Rank within an ordered partition.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::DenseRank", "docstring": "Rank within an ordered partition, consecutively.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::RowNumber", "docstring": "Compute the row number over a window, starting from 0.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::PercentRank", "docstring": "Compute the percentile rank over a window.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::CumeDist", "docstring": "Compute the cumulative distribution function of a column over a window.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::NTile", "docstring": "Compute the percentile of a column over a window.", "type": "class"}
{"source": "ibis/expr/operations/analytic.py::NthValue", "docstring": "Retrieve the Nth element of a column over a window.", "type": "class"}
{"source": "ibis/expr/operations/json.py::JSONGetItem", "docstring": "Get a value from a JSON object or array.", "type": "class"}
{"source": "ibis/expr/operations/json.py::ToJSONArray", "docstring": "Convert a value to an array of JSON objects.", "type": "class"}
{"source": "ibis/expr/operations/json.py::ToJSONMap", "docstring": "Convert a value to a map of string to JSON.", "type": "class"}
{"source": "ibis/expr/operations/json.py::UnwrapJSONString", "docstring": "Unwrap a JSON string into an engine-native string.", "type": "class"}
{"source": "ibis/expr/operations/json.py::UnwrapJSONInt64", "docstring": "Unwrap a JSON number into an engine-native int64.", "type": "class"}
{"source": "ibis/expr/operations/json.py::UnwrapJSONFloat64", "docstring": "Unwrap a JSON number into an engine-native float64.", "type": "class"}
{"source": "ibis/expr/operations/json.py::UnwrapJSONBoolean", "docstring": "Unwrap a JSON bool into an engine-native bool.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringUnary", "docstring": "Base class for string operations accepting one argument.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Uppercase", "docstring": "Convert a string to uppercase.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Lowercase", "docstring": "Convert a string to lowercase.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Reverse", "docstring": "Reverse a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Strip", "docstring": "Strip leading and trailing whitespace.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::LStrip", "docstring": "Strip leading whitespace.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RStrip", "docstring": "Strip trailing whitespace.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Capitalize", "docstring": "Capitalize the first letter of a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Substring", "docstring": "Extract a substring from a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringSlice", "docstring": "Extract a substring from a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StrRight", "docstring": "Extract a substring starting from the right of a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Repeat", "docstring": "Repeat a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringFind", "docstring": "Find the position of a substring in a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Translate", "docstring": "Translate characters in a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::LPad", "docstring": "Pad a string on the left.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RPad", "docstring": "Pad a string on the right.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::FindInSet", "docstring": "Find the position of a string in a list of comma-separated strings.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringJoin", "docstring": "Join strings with a separator.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ArrayStringJoin", "docstring": "Join strings in an array with a separator.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StartsWith", "docstring": "Check if a string starts with another string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::EndsWith", "docstring": "Check if a string ends with another string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringSQLLike", "docstring": "SQL LIKE string match operation.\n\nSimilar to globbing.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringSQLILike", "docstring": "Case-insensitive SQL LIKE string match operation.\n\nSimilar to case-insensitive globbing.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RegexSearch", "docstring": "Search a string with a regular expression.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RegexExtract", "docstring": "Extract a substring from a string using a regular expression.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RegexSplit", "docstring": "Split a string using a regular expression.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::RegexReplace", "docstring": "Replace a substring in a string using a regular expression.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringReplace", "docstring": "Replace a substring in a string with another string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringSplit", "docstring": "Split a string using a delimiter.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringConcat", "docstring": "Concatenate strings.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractProtocol", "docstring": "Extract the protocol from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractAuthority", "docstring": "Extract the authority from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractUserInfo", "docstring": "Extract the user info from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractHost", "docstring": "Extract the host from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractFile", "docstring": "Extract the file from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractPath", "docstring": "Extract the path from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractQuery", "docstring": "Extract the query from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::ExtractFragment", "docstring": "Extract the fragment from a URL.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringLength", "docstring": "Compute the length of a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringAscii", "docstring": "Compute the ASCII code of the first character of a string.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::StringContains", "docstring": "Check if a string contains a substring.", "type": "class"}
{"source": "ibis/expr/operations/strings.py::Levenshtein", "docstring": "Compute the Levenshtein distance between two strings.", "type": "class"}
{"source": "ibis/legacy/udf/vectorized.py::_coerce_to_dict", "docstring": "Coerce the following shapes to a tuple.\n\n- [](`list`)\n- `np.ndarray`\n- `pd.Series`", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::_coerce_to_np_array", "docstring": "Coerce the following shapes to an np.ndarray.\n\n- [](`list`)\n- `np.ndarray`\n- `pd.Series`", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::_coerce_to_series", "docstring": "Coerce the following shapes to a Series.\n\nThis method does NOT always return a new Series. If a Series is\npassed in, this method will return the original object.\n\n- [](`list`)\n- `np.ndarray`\n- `pd.Series`\n\nNote:\n\nParameters\n----------\ndata\n    Input\noutput_type\n    The type of the output\noriginal_index\n    Optional parameter containing the index of the output\n\nReturns\n-------\npd.Series\n    Output Series", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::_coerce_to_dataframe", "docstring": "Coerce the following shapes to a DataFrame.\n\nThis method does NOT always return a new DataFrame. If a DataFrame is\npassed in, this method will return the original object.\n\nThe following shapes are allowed:\n\n- A list/tuple of Series\n- A list/tuple np.ndarray\n- A list/tuple of scalars\n- A Series of list/tuple\n- pd.DataFrame\n\nNote:\n\nParameters\n----------\ndata\n    Input\noutput_type\n    A Struct containing the names and types of the output\noriginal_index\n    Optional parameter containing the index of the output\n\nReturns\n-------\npd.DataFrame\n    Output DataFrame\n\nExamples\n--------\n>>> import pandas as pd\n>>> _coerce_to_dataframe(pd.DataFrame({\"a\": [1, 2, 3]}), dt.Struct(dict(b=\"int32\")))  # noqa: E501\n   b\n0  1\n1  2\n2  3\n>>> _coerce_to_dataframe(pd.Series([[1, 2, 3]]), dt.Struct(dict.fromkeys(\"abc\", \"int32\")))  # noqa: E501\n   a  b  c\n0  1  2  3\n>>> _coerce_to_dataframe(\n...     pd.Series([range(3), range(3)]), dt.Struct(dict.fromkeys(\"abc\", \"int32\"))\n... )  # noqa: E501\n   a  b  c\n0  0  1  2\n1  0  1  2\n>>> _coerce_to_dataframe(\n...     [pd.Series(x) for x in [1, 2, 3]], dt.Struct(dict.fromkeys(\"abc\", \"int32\"))\n... )  # noqa: E501\n   a  b  c\n0  1  2  3\n>>> _coerce_to_dataframe([1, 2, 3], dt.Struct(dict.fromkeys(\"abc\", \"int32\")))  # noqa: E501\n   a  b  c\n0  1  2  3", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::UserDefinedFunction", "docstring": "Class representing a user defined function.\n\nThis class Implements __call__ that returns an ibis expr for the\nUDF.", "type": "class"}
{"source": "ibis/legacy/udf/vectorized.py::analytic", "docstring": "Define an analytic UDF that produces the same of rows as the input.\n\nParameters\n----------\ninput_type : List[ibis.expr.datatypes.DataType]\n    A list of the types found in :mod:`~ibis.expr.datatypes`. The\n    length of this list must match the number of arguments to the\n    function. Variadic arguments are not yet supported.\noutput_type : ibis.expr.datatypes.DataType\n    The return type of the function.", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::elementwise", "docstring": "Define a UDF that operates element-wise on a Pandas Series.\n\nParameters\n----------\ninput_type : List[ibis.expr.datatypes.DataType]\n    A list of the types found in :mod:`~ibis.expr.datatypes`. The\n    length of this list must match the number of arguments to the\n    function. Variadic arguments are not yet supported.\noutput_type : ibis.expr.datatypes.DataType\n    The return type of the function.", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::reduction", "docstring": "Define a UDF reduction function that produces 1 row of output for N rows of input.\n\nParameters\n----------\ninput_type : List[ibis.expr.datatypes.DataType]\n    A list of the types found in :mod:`~ibis.expr.datatypes`. The\n    length of this list must match the number of arguments to the\n    function. Variadic arguments are not yet supported.\noutput_type : ibis.expr.datatypes.DataType\n    The return type of the function.", "type": "function"}
{"source": "ibis/legacy/udf/vectorized.py::_get_coercion_function", "docstring": "Return the appropriate function to coerce the result of the UDF.", "type": "function"}
{"source": "ibis/legacy/udf/validate.py::_parameter_count", "docstring": "Get the number of positional parameters in a function signature.\n\nParameters\n----------\nfuncsig : inspect.Signature\n    A UDF signature\n\nReturns\n-------\nint\n    The number of parameters", "type": "function"}
{"source": "ibis/legacy/udf/validate.py::validate_input_type", "docstring": "Check that the declared number of inputs and signature of func are compatible.\n\nIf the signature of `func` uses *args, then no check is done (since no\ncheck can be done).", "type": "function"}
{"source": "ibis/legacy/udf/validate.py::validate_output_type", "docstring": "Check that the output type is a single datatype.", "type": "function"}
{"source": "ibis/tests/expr/test_table.py::test_projection_sort_keys_errors", "docstring": "Forbid using `asc`/`desc` in selections", "type": "function"}
{"source": "ibis/tests/expr/test_analysis.py::test_mutation_fusion_no_overwrite", "docstring": "Test fusion with chained mutation that doesn't overwrite existing\ncolumns.", "type": "function"}
{"source": "ibis/tests/expr/test_analysis.py::test_mutation_fusion_overwrite", "docstring": "Test fusion with chained mutation that overwrites existing columns.", "type": "function"}
{"source": "ibis/tests/expr/test_analysis.py::test_select_filter_mutate_fusion", "docstring": "Test fusion with filter followed by mutation on the same input.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::normalize_nulls", "docstring": "Fill any nan-likes with NULL.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::starts_with", "docstring": "Apply a.startswith(b) to each pair of values in a and b.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::strip", "docstring": "Remove leading and trailing characters from a string.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::fix_nicknames", "docstring": "Splits \"Nicholas (Nick)\" into \"Nicholas\" and \"Nick\".\n\nAlso deals with the form \"Nicholas 'Nick'\" etc.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::norm_whitespace", "docstring": "Convert all whitespace to a single space, strip leading/trailing spaces.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::to_ascii", "docstring": "Remove any non-ascii characters.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::num_tokens", "docstring": "Count the number of tokens, separated by spaces, in a string.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::drop_first_when_same_as_last", "docstring": "Where the f and l are each one token and the same, set the first to null.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::fix_duplicate_appearances", "docstring": "If a field appears as a token in another field, remove it from the other field.\n\nfor example:\n>>> names = pd.DataFrame(\n...     [\n...         {\"first_name\": \"J ang\", \"middle_name\": \"A Ang\", \"last_name\": \"ANG\"},\n...         {\"first_name\": \"smith john\", \"middle_name\": \"B\", \"last_name\": \"SMITH\"},\n...     ]\n... )\n>>> scrub_duplicate_appearances(names, \"last_name\")\npd.DataFrame(\n    [\n        {'first_name': 'J', 'middle_name': 'A', 'last_name': 'ANG'},\n        {'first_name': 'john', 'middle_name': 'B', 'last_name': 'SMITH'},\n    ]\n)", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::parse_middle", "docstring": "Extract the middle name from the first or last name field.\n\nFour kinds of parsings\nA jones     -> Parse\nAJ          -> Inconclusive, could be first name.\nA J         -> Inconclusive, could be first name.\nAlice J     -> Parse\nAlice Jones -> Inconclusive, could be first name.\n\nOnly can be confident in this if there are two tokens, and at least one of\nthem is only a single letter (optionally followed by period).\n\nTwo capital letters in the first name is not sufficient, for example TJ\nis probably the first name.\n\nAlso looks at if middle_name is already filled.\n\nMisses some cases that we could worry about, but this gets the vast majority.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::fix_nickname_is_middle", "docstring": "Fix 'george \"mike\" m smith\", Where mike is both the nickname and middle name.\n\nWatch out for when the nickname is probably not related to the middle name,\nSuch as with 'Carolyn \"Care\" c smith' (Care is short for Carolyn, not the middle)", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::fix_two_token_people", "docstring": "If no first name, and a two-token last name, extract first and last into respective columns.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::fix_last_comma_first", "docstring": "Parses when first name is NA, and last name follows the form \"Last, First\".", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::norm_name_fields", "docstring": "Normalize capitalization and whitespace, remove weird punctuation, etc.", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::norm_name_field", "docstring": "Fix capitalization and whitespace in a name field.\n\n\"DEBOER\" -> \"Deboer\"\n\"DeBoer\" -> \"DeBoer\"\n\"OBrien\" -> \"OBrien\"\n\"O'Brien\" -> \"O'Brien\"\n\"Jr. \" -> \"Jr\"\n\"Abc -Def\" -> \"Abc-Def\"", "type": "function"}
{"source": "ibis/tests/benchmarks/benchfuncs.py::clean_names", "docstring": "Perform all the cleaning steps on a Table of names.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::Options", "docstring": "Clickhouse options.\n\nAttributes\n----------\nbool_type : str\n    Type to use for boolean columns", "type": "class"}
{"source": "ibis/backends/clickhouse/__init__.py::_register_in_memory_table", "docstring": "No-op.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::do_connect", "docstring": "Create a ClickHouse client for use with Ibis.\n\nParameters\n----------\nhost\n    Host name of the clickhouse server\nport\n    ClickHouse HTTP server's port. If not passed, the value depends on\n    whether `secure` is `True` or `False`.\ndatabase\n    Default database when executing queries\nuser\n    User to authenticate with\npassword\n    Password to authenticate with\nclient_name\n    Name of client that will appear in clickhouse server logs\nsecure\n    Whether or not to use an authenticated endpoint\ncompression\n    The kind of compression to use for requests. See\n    https://clickhouse.com/docs/en/integrations/python#compression for\n    more information.\nsettings\n    ClickHouse session settings\nkwargs\n    Client specific keyword arguments\n\nExamples\n--------\n>>> import ibis\n>>> client = ibis.clickhouse.connect(user=\"ibis\")\n>>> client\n<ibis.backends.clickhouse.Backend object at 0x...>", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing ClickHouse Connect Client instance.\n\nParameters\n----------\ncon\n    An existing ClickHouse Connect Client instance.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::_normalize_external_tables", "docstring": "Merge registered external tables with any new external tables.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::to_pyarrow_batches", "docstring": "Execute expression and return an iterator of pyarrow record batches.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nexternal_tables\n    External data\nchunk_size\n    Maximum number of row to return in a single chunk\nkwargs\n    Extra arguments passed directly to clickhouse-connect\n\nReturns\n-------\nresults\n    RecordBatchReader\n\nNotes\n-----\nThere are a variety of ways to implement clickhouse -> record batches.\n\n1. FORMAT ArrowStream -> record batches via raw_query\n   This has the same type conversion problem(s) as `to_pyarrow`.\n   It's harder to address due to lack of `cast` on `RecordBatch`.\n   However, this is a ClickHouse problem: we should be able to get\n   string data out without a bunch of settings/permissions rigmarole.\n2. Native -> Python objects -> pyarrow batches\n   This is what is implemented, using `query_column_block_stream`.\n3. Native -> Python objects -> DataFrame chunks -> pyarrow batches\n   This is not implemented because it adds an unnecessary pandas step in\n   between Python object -> arrow. We can go directly to record batches\n   without pandas in the middle.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::execute", "docstring": "Execute an expression.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::raw_sql", "docstring": "Execute a SQL string `query` against the database.\n\nParameters\n----------\nquery\n    Raw SQL string\nexternal_tables\n    Mapping of table name to pandas DataFrames providing\n    external datasources for the query\nkwargs\n    Backend specific query arguments\n\nReturns\n-------\nCursor\n    Clickhouse cursor", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::disconnect", "docstring": "Close ClickHouse connection.", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::get_schema", "docstring": "Return a Schema object for the indicated table and database.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name, not supported by ClickHouse\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/clickhouse/__init__.py::create_table", "docstring": "Create a table in a ClickHouse database.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    Optional data to create the table with\nschema\n    Optional names and types of the table\ndatabase\n    Database to create the table in\ntemp\n    Create a temporary table. This is not yet supported, and exists for\n    API compatibility.\noverwrite\n    Whether to overwrite the table\nengine\n    The table engine to use. See [ClickHouse's `CREATE TABLE` documentation](https://clickhouse.com/docs/en/sql-reference/statements/create/table)\n    for specifics. Defaults to [`MergeTree`](https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree)\n    with `ORDER BY tuple()` because `MergeTree` is the most\n    feature-complete engine.\norder_by\n    String column names to order by. Required for some table engines like `MergeTree`.\npartition_by\n    String column names to partition by\nsample_by\n    String column names to sample by\nsettings\n    Key-value pairs of settings for table creation\n\nReturns\n-------\nTable\n    The new table", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::_register_in_memory_table", "docstring": "No-op.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::do_connect", "docstring": "Create a Flink `Backend` for use with Ibis.\n\nParameters\n----------\ntable_env\n    A table environment.\n\nExamples\n--------\n>>> import ibis\n>>> from pyflink.table import EnvironmentSettings, TableEnvironment\n>>> table_env = TableEnvironment.create(EnvironmentSettings.in_streaming_mode())\n>>> ibis.flink.connect(table_env)  # doctest: +ELLIPSIS\n<ibis.backends.flink.Backend object at 0x...>", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::from_connection", "docstring": "Create a Flink `Backend` from an existing table environment.\n\nParameters\n----------\ntable_env\n    A table environment.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::create_database", "docstring": "Create a new database.\n\nParameters\n----------\nname : str\n    Name of the new database.\ndb_properties : dict, optional\n    Properties of the database. Accepts dictionary of key-value pairs\n    (key1=val1, key2=val2, ...).\ncatalog : str, optional\n    Name of the catalog in which the new database will be created.\nforce : bool, optional\n    If `False`, an exception is raised if the database already exists.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::drop_database", "docstring": "Drop a database with name `name`.\n\nParameters\n----------\nname : str\n    Database to drop.\ncatalog : str, optional\n    Name of the catalog from which the database will be dropped.\nforce : bool, optional\n    If `False`, an exception is raised if the database does not exist.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::list_tables", "docstring": "Return the list of table/view names.\n\nReturn the list of table/view names in the `database` and `catalog`. If\n`database`/`catalog` are not specified, their default values will be\nused. Temporary tables can only be listed for the default database and\ncatalog, hence `database` and `catalog` are ignored if `temp` is True.\n\nParameters\n----------\nlike\n    A pattern in Python's regex format.\ntemp\n    Whether to list temporary tables or permanent tables.\ndatabase\n    The database to list tables of, if not the current one.\ncatalog\n    The catalog to list tables of, if not the current one.\n\nReturns\n-------\nlist[str]\n    The list of the table/view names that match the pattern `like`.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::list_views", "docstring": "Return the list of view names.\n\nReturn the list of view names.\n\nParameters\n----------\nlike : str, optional\n    A pattern in Python's regex format.\ntemp : bool, optional\n    Whether to list temporary views or permanent views.\n\nReturns\n-------\nlist[str]\n    The list of the view names that match the pattern `like`.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::table", "docstring": "Return a table expression from a table or view in the database.\n\nParameters\n----------\nname\n    Table name.\ndatabase\n    Database in which the table resides.\ncatalog\n    Catalog in which the table resides.\n\nReturns\n-------\nTable\n    Table named `name` from `database`", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::get_schema", "docstring": "Return a Schema object for the indicated table and database.\n\nParameters\n----------\ntable_name : str\n    Table name.\ncatalog : str, optional\n    Catalog name.\ndatabase : str, optional\n    Database name.\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::compile", "docstring": "Compile an Ibis expression to Flink.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::execute", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::create_table", "docstring": "Create a new table in Flink.\n\nIn Flink, tables can be either virtual (VIEWS) or regular (TABLES).\nVIEWS can be created from an existing Table object, usually the result\nof a Table API or SQL query. TABLES describe external data, such as a\nfile, database table, or message queue. In other words, TABLES refer\nexplicitly to tables constructed directly from source/sink connectors.\n\nWhen `obj` is in-memory (e.g., Dataframe), currently this function can\ncreate only a TEMPORARY VIEW. If `obj` is in-memory and `temp` is False,\nit will raise an error.\n\nParameters\n----------\nname\n    Name of the new table.\nobj\n    An Ibis table expression, pandas DataFrame, or PyArrow Table that will\n    be used to extract the schema and the data of the new table. An\n    optional `schema` can be used to override the schema.\nschema\n    The schema for the new table. Required if `obj` is not provided.\ndatabase\n    Name of the database where the table will be created, if not the\n    default.\ncatalog\n    Name of the catalog where the table will be created, if not the\n    default.\ntbl_properties\n    Table properties used to create a table source/sink. The properties\n    are usually used to find and create the underlying connector. Accepts\n    dictionary of key-value pairs (key1=val1, key2=val2, ...).\nwatermark\n    Watermark strategy for the table, only applicable on sources.\nprimary_key\n    A single column or a list of columns to be marked as primary. Raises\n    an error if the column(s) in `primary_key` is NOT a subset of the\n    columns in `schema`. Primary keys must be non-nullable in Flink and\n    the columns indicated as primary key will be designated as non-nullable.\ntemp\n    Whether a table is temporary or not.\noverwrite\n    Whether to clobber existing data.\n\nReturns\n-------\nTable\n    The table that was created.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::drop_table", "docstring": "Drop a table.\n\nParameters\n----------\nname\n    Name of the table to drop.\ndatabase\n    Name of the database where the table exists, if not the default.\ncatalog\n    Name of the catalog where the table exists, if not the default.\ntemp\n    Whether the table is temporary or not.\nforce\n    If `False`, an exception is raised if the table does not exist.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.\nforce\n    If `False`, an exception is raised if the table does not exist.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::create_view", "docstring": "Create a new view from a dataframe or table.\n\nWhen `obj` is in-memory (e.g., Dataframe), currently this function can\ncreate only a TEMPORARY VIEW. If `obj` is in-memory and `temp` is False,\nit will raise an error.\n\nParameters\n----------\nname\n    Name of the new view.\nobj\n    An Ibis table expression that will be used to create the view.\nschema\n    The schema for the new view.\ndatabase\n    Name of the database where the view will be created, if not\n    provided the database's default is used.\ncatalog\n    Name of the catalog where the table exists, if not the default.\nforce\n    If `False`, an exception is raised if the table is already present.\ntemp\n    Whether the table is temporary or not.\noverwrite\n    If `True`, remove the existing view, and create a new one.\n\nReturns\n-------\nTable\n    The view that was created.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::drop_view", "docstring": "Drop a view.\n\nParameters\n----------\nname\n    Name of the view to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\ncatalog\n    Name of the catalog where the view exists, if not the default.\ntemp\n    Whether the view is temporary or not.\nforce\n    If `False`, an exception is raised if the view does not exist.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::_read_file", "docstring": "Register a file as a table in the current database.\n\nParameters\n----------\nfile_type\n    File type, e.g., parquet, csv, json.\npath\n    The data source.\nschema\n    The schema for the new table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n\nReturns\n-------\nir.Table\n    The just-registered table\n\nRaises\n------\nValueError\n    If `schema` is None.", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npath\n    The data source.\nschema\n    The schema for the new table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::read_csv", "docstring": "Register a csv file as a table in the current database.\n\nParameters\n----------\npath\n    The data source.\nschema\n    The schema for the new table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::read_json", "docstring": "Register a json file as a table in the current database.\n\nParameters\n----------\npath\n    The data source.\nschema\n    The schema for the new table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/flink/__init__.py::insert", "docstring": "Insert data into a table.\n\nParameters\n----------\nname\n    The name of the table to insert data into.\nobj\n    The source data or expression to insert.\ndatabase\n    Name of the attached database that the table is located in.\ncatalog\n    Name of the attached catalog that the table is located in.\noverwrite\n    If `True` then replace existing contents of table.\n\nReturns\n-------\nTableResult\n    The table result.\n\nRaises\n------\nValueError\n    If the type of `obj` isn't supported", "type": "function"}
{"source": "ibis/backends/flink/datatypes.py::get_field_data_types", "docstring": "Returns all field data types in `pyflink_schema` as a list.\n\nThis is a re-implementation of `get_field_data_types()` available for PyFlink\nschemas. PyFlink's implementation currently supports only `precision = 3` for\n`TimestampType` (for some reason that we could not figure out -- might be just\na bug). The lack of precision support led to an error due to unmatched schemas\nfor batches and the file to write in `to_csv()` and `to_parquet()`.\n\n:return: A list of all field data types.", "type": "function"}
{"source": "ibis/backends/flink/datatypes.py::to_ibis", "docstring": "Convert a flink type to an ibis type.", "type": "function"}
{"source": "ibis/backends/flink/datatypes.py::from_ibis", "docstring": "Convert an ibis type to a flink type.", "type": "function"}
{"source": "ibis/backends/flink/utils.py::_calculate_precision", "docstring": "Calculate interval precision.\n\nFlinkSQL interval data types use leading precision and fractional-\nseconds precision. Because the leading precision defaults to 2, we need to\nspecify a different precision when the value exceeds 2 digits.\n\n(see\nhttps://learn.microsoft.com/en-us/sql/odbc/reference/appendixes/interval-literals)", "type": "function"}
{"source": "ibis/backends/flink/utils.py::_format_value_with_precision", "docstring": "Format value so that it fills a specified precision.", "type": "function"}
{"source": "ibis/backends/flink/utils.py::format_precision", "docstring": "Format precision values in Flink SQL.", "type": "function"}
{"source": "ibis/backends/flink/utils.py::FlinkIntervalType", "docstring": "Abstract Base Class for Flink interval type.\n\nFlink supports only two types of temporal intervals: day-time intervals with up to nanosecond\ngranularity or year-month intervals with up to month granularity.\n\nThis Abstract Base Class provides functionality so that a given IntervalType instance can be\ntranslated appropriately into Flink SQL.", "type": "class"}
{"source": "ibis/backends/flink/utils.py::_translate_interval", "docstring": "Convert interval to Flink SQL type.\n\nFlink supports only two types of temporal intervals: day-time intervals with up to nanosecond\ngranularity or year-month intervals with up to month granularity.\n\nAn interval of year-month consists of +years-months with values ranging from -9999-11 to +9999-11.\nAn interval of day-time consists of +days hours:minutes:seconds.fractional with values ranging from\n-999999 23:59:59.999999999 to +999999 23:59:59.999999999.\n\nThe value representation is the same for all types of resolutions.\n\nFor example, an interval of months of 50 is always represented in an interval-of-years-to-months\nformat (with default year precision): +04-02; an interval of seconds of 70 is always represented in\nan interval-of-days-to-seconds format (with default precisions): +00 00:01:10.000000.", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::raw_sql", "docstring": "Execute a raw SQL query.", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::_safe_raw_sql", "docstring": "Execute a raw SQL query, yielding the cursor.\n\nParameters\n----------\nquery\n    The query to execute.\n\nYields\n------\ntrino.dbapi.Cursor\n    The cursor of the executed query.", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::get_schema", "docstring": "Compute the schema of a `table`.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::do_connect", "docstring": "Connect to Trino.\n\nParameters\n----------\nuser\n    Username to connect with\nauth\n    Authentication method or password to use for the connection.\nhost\n    Hostname of the Trino server\nport\n    Port of the Trino server\ndatabase\n    Catalog to use on the Trino server\nschema\n    Schema to use on the Trino server\nsource\n    Application name passed to Trino\ntimezone\n    Timezone to use for the connection\nkwargs\n    Additional keyword arguments passed directly to the\n    `trino.dbapi.connect` API.\n\nExamples\n--------\n>>> catalog = \"hive\"\n>>> schema = \"default\"\n\nConnect using a URL, with the default user, password, host and port\n\n>>> con = ibis.connect(f\"trino:///{catalog}/{schema}\")\n\nConnect using a URL\n\n>>> con = ibis.connect(f\"trino://user@localhost:8080/{catalog}/{schema}\")\n\nConnect using keyword arguments\n\n>>> con = ibis.trino.connect(database=catalog, schema=schema)\n>>> con = ibis.trino.connect(database=catalog, schema=schema, source=\"my-app\")", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a Trino database.\n\nParameters\n----------\ncon\n    An existing connection to a Trino database.", "type": "function"}
{"source": "ibis/backends/trino/__init__.py::create_table", "docstring": "Create a table in Trino.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but one of `obj`\n    or `schema` must be specified\nschema\n    The schema of the table to create; optional, but one of `obj` or\n    `schema` must be specified\ndatabase\n    The database to insert the table into.\n    If not provided, the current database is used.\n    You can provide a single database name, like `\"mydb\"`. For\n    multi-level hierarchies, you can pass in a dotted string path like\n    `\"catalog.database\"` or a tuple of strings like `(\"catalog\",\n    \"database\")`.\ntemp\n    This parameter is not yet supported in the Trino backend, because\n    Trino doesn't implement temporary tables\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail if\n    the table exists\ncomment\n    Add a comment to the table\nproperties\n    Table properties to set on creation", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::Options", "docstring": "PySpark options.\n\nAttributes\n----------\ntreat_nan_as_null : bool\n    Treat NaNs in floating point expressions as NULL.", "type": "class"}
{"source": "ibis/backends/pyspark/__init__.py::_from_url", "docstring": "Construct a PySpark backend from a URL `url`.", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::do_connect", "docstring": "Create a PySpark `Backend` for use with Ibis.\n\nParameters\n----------\nsession\n    A `SparkSession` instance.\nmode\n    Can be either \"batch\" or \"streaming\". If \"batch\", every source, sink, and\n    query executed within this connection will be interpreted as a batch\n    workload. If \"streaming\", every source, sink, and query executed within\n    this connection will be interpreted as a streaming workload.\nkwargs\n    Additional keyword arguments used to configure the SparkSession.\n\nExamples\n--------\n>>> import ibis\n>>> from pyspark.sql import SparkSession\n>>> session = SparkSession.builder.getOrCreate()\n>>> ibis.pyspark.connect(session)\n<ibis.backends.pyspark.Backend at 0x...>", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::from_connection", "docstring": "Create a PySpark `Backend` from an existing `SparkSession` instance.\n\nParameters\n----------\nsession\n    A `SparkSession` instance.\nmode\n    Can be either \"batch\" or \"streaming\". If \"batch\", every source, sink, and\n    query executed within this connection will be interpreted as a batch\n    workload. If \"streaming\", every source, sink, and query executed within\n    this connection will be interpreted as a streaming workload.\nkwargs\n    Additional keyword arguments used to configure the SparkSession.", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::execute", "docstring": "Execute an expression.", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::create_database", "docstring": "Create a new Spark database.\n\nParameters\n----------\nname\n    Database name\ncatalog\n    Catalog to create database in (defaults to `current_catalog`)\npath\n    Path where to store the database data; otherwise uses Spark default\nforce\n    Whether to append `IF NOT EXISTS` to the database creation SQL", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::drop_database", "docstring": "Drop a Spark database.\n\nParameters\n----------\nname\n    Database name\ncatalog\n    Catalog containing database to drop (defaults to `current_catalog`)\nforce\n    If False, Spark throws exception if database is not empty or\n    database does not exist", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::get_schema", "docstring": "Return a Schema object for the indicated table and database.\n\nParameters\n----------\ntable_name\n    Table name. May be fully qualified\ncatalog\n    Catalog to use\ndatabase\n    Database to use to get the active database.\n\nReturns\n-------\nSchema\n    An ibis schema", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::create_table", "docstring": "Create a new table in Spark.\n\nParameters\n----------\nname\n    Name of the new table.\nobj\n    If passed, creates table from `SELECT` statement results\nschema\n    Mutually exclusive with `obj`, creates an empty table with a schema\ndatabase\n    Database name\n\n    To specify a table in a separate catalog, you can pass in the\n    catalog and database as a string `\"catalog.database\"`, or as a tuple of\n    strings `(\"catalog\", \"database\")`.\ntemp\n    Whether the new table is temporary (unsupported)\noverwrite\n    If `True`, overwrite existing data\nformat\n    Format of the table on disk\npartition_by\n    Name(s) of partitioning column(s)\n\nReturns\n-------\nTable\n    The newly created table.\n\nExamples\n--------\n>>> con.create_table(\"new_table_name\", table_expr)  # quartodoc: +SKIP # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::create_view", "docstring": "Create a temporary Spark view from a table expression.\n\nParameters\n----------\nname\n    View name\nobj\n    Expression to use for the view\ndatabase\n    Database name\noverwrite\n    Replace an existing view of the same name if it exists\n\nReturns\n-------\nTable\n    The created view", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::compute_stats", "docstring": "Issue a `COMPUTE STATISTICS` command for a given table.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    Database name\nnoscan\n    If `True`, collect only basic statistics for the table (number of\n    rows, size in bytes).", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_delta", "docstring": "Register a Delta Lake table as a table in the current database.\n\nParameters\n----------\npath\n    The path to the Delta Lake table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nkwargs\n    Additional keyword arguments passed to PySpark.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameReader.load.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npath\n    The data source. May be a path to a file or directory of parquet files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nkwargs\n    Additional keyword arguments passed to PySpark.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameReader.parquet.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_csv", "docstring": "Register a CSV file as a table in the current database.\n\nParameters\n----------\npaths\n    The data source(s). May be a path to a file or directory of CSV files, or an\n    iterable of CSV files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nkwargs\n    Additional keyword arguments passed to PySpark loading function.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameReader.csv.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_json", "docstring": "Register a JSON file as a table in the current database.\n\nParameters\n----------\npaths\n    The data source(s). May be a path to a file or directory of JSON files, or an\n    iterable of JSON files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nkwargs\n    Additional keyword arguments passed to PySpark loading function.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameReader.json.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::to_delta", "docstring": "Write the results of executing the given expression to a Delta Lake table.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to a Delta Lake table.\npath\n    The data source. A string or Path to the Delta Lake table.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\n**kwargs\n    Additional keyword arguments passed to\n    [pyspark.sql.DataFrameWriter](https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameWriter.html).", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::to_parquet", "docstring": "Write the results of executing the given expression to a Parquet file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to a Parquet file.\npath\n    The data source. A string or Path to the Parquet file.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\n**kwargs\n    Additional keyword arguments passed to\n    [pyspark.sql.DataFrameWriter](https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrameWriter.html).", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_kafka", "docstring": "Register a Kafka topic as a table.\n\nParameters\n----------\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\nwatermark\n    Watermark strategy for the table.\nauto_parse\n    Whether to parse Kafka messages automatically. If `False`, the source is read\n    as binary keys and values. If `True`, the key is discarded and the value is\n    parsed using the provided schema.\nschema\n    Schema of the value of the Kafka messages.\noptions\n    Additional arguments passed to PySpark as .option(\"key\", \"value\").\n    https://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::to_kafka", "docstring": "Write the results of executing the given expression to a Kafka topic.\n\nThis method does not return outputs. Streaming queries are run continuously in\nthe background.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to a Kafka topic.\nauto_format\n    Whether to format the Kafka messages before writing. If `False`, the output is\n    written as-is. If `True`, the output is converted into JSON and written as the\n    value of the Kafka messages.\noptions\n    PySpark Kafka write arguments.\n    https://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\n\nReturns\n-------\nStreamingQuery\n    A Pyspark StreamingQuery object", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_csv_dir", "docstring": "Register a CSV directory as a table in the current database.\n\nParameters\n----------\npath\n    The data source.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nwatermark\n    Watermark strategy for the table.\nkwargs\n    Additional keyword arguments passed to PySpark loading function.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.ss/api/pyspark.sql.streaming.DataStreamReader.csv.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_parquet_dir", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npath\n    The data source. A directory of parquet files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nwatermark\n    Watermark strategy for the table.\nschema\n    Schema of the parquet source.\nkwargs\n    Additional keyword arguments passed to PySpark.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.ss/api/pyspark.sql.streaming.DataStreamReader.parquet.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::read_json_dir", "docstring": "Register a JSON file as a table in the current database.\n\nParameters\n----------\npath\n    The data source. A directory of JSON files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a random generated name.\nwatermark\n    Watermark strategy for the table.\nkwargs\n    Additional keyword arguments passed to PySpark loading function.\n    https://spark.apache.org/docs/latest/api/python/reference/pyspark.ss/api/pyspark.sql.streaming.DataStreamReader.json.html\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::to_parquet_dir", "docstring": "Write the results of executing the given expression to a parquet directory.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\npath\n    The data source. A string or Path to the parquet directory.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\noptions\n    Additional keyword arguments passed to pyspark.sql.streaming.DataStreamWriter\n\nReturns\n-------\nStreamingQuery | None\n    Returns a Pyspark StreamingQuery object if in streaming mode, otherwise None", "type": "function"}
{"source": "ibis/backends/pyspark/__init__.py::to_csv_dir", "docstring": "Write the results of executing the given expression to a CSV directory.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to CSV.\npath\n    The data source. A string or Path to the CSV directory.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\noptions\n    Additional keyword arguments passed to pyspark.sql.streaming.DataStreamWriter\n\nReturns\n-------\nStreamingQuery | None\n    Returns a Pyspark StreamingQuery object if in streaming mode, otherwise None", "type": "function"}
{"source": "ibis/backends/pyspark/datatypes.py::to_ibis", "docstring": "Convert a pyspark type to an ibis type.", "type": "function"}
{"source": "ibis/backends/oracle/__init__.py::metadata_row_to_type", "docstring": "Convert a row from an Oracle metadata table to an Ibis type.", "type": "function"}
{"source": "ibis/backends/oracle/__init__.py::do_connect", "docstring": "Create an Ibis client using the passed connection parameters.\n\nParameters\n----------\nuser\n    Username\npassword\n    Password\nhost\n    Hostname\nport\n    Port\ndatabase\n    Used as an Oracle service name if provided.\nsid\n    Unique name of an Oracle Instance, used to construct a DSN if\n    provided.\nservice_name\n    Oracle service name, used to construct a DSN if provided.  Only one\n    of database and service_name should be provided.\ndsn\n    An Oracle Data Source Name.  If provided, overrides all other\n    connection arguments except username and password.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_ORACLE_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_ORACLE_USER\", \"ibis\")\n>>> password = os.environ.get(\"IBIS_TEST_ORACLE_PASSWORD\", \"ibis\")\n>>> database = os.environ.get(\"IBIS_TEST_ORACLE_DATABASE\", \"IBIS_TESTING\")\n>>> con = ibis.oracle.connect(database=database, host=host, user=user, password=password)\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int64\n  bool_col        int64\n  tinyint_col     int64\n  smallint_col    int64\n  int_col         int64\n  bigint_col      int64\n  float_col       float64\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   timestamp(3)\n  year            int64\n  month           int64", "type": "function"}
{"source": "ibis/backends/oracle/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to an Oracle database.\n\nParameters\n----------\ncon\n    An existing connection to an Oracle database.", "type": "function"}
{"source": "ibis/backends/oracle/__init__.py::create_table", "docstring": "Create a table in Oracle.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::_databricks_type_to_ibis", "docstring": "Convert a Databricks type to an Ibis type.", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::_databricks_schema_to_ibis", "docstring": "Convert a Databricks schema to an Ibis schema.", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::create_table", "docstring": "Create a table in Databricks.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\n\n    For multi-level table hierarchies, you can pass in a dotted string\n    path like `\"catalog.database\"` or a tuple of strings like\n    `(\"catalog\", \"database\")`.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists\nusing\n    Data source format\nlocation\n    Storage location for the table\ntblproperties\n    Table properties", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::get_schema", "docstring": "Compute the schema of a `table`.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::do_connect", "docstring": "Create an Ibis client connected to a Databricks cloud instance.", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a Databricks cloud instance.\n\nParameters\n----------\ncon\n    An existing connection to a Databricks database.\nmemtable_volume\n    The volume to use for Ibis memtables.", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::to_pyarrow_batches", "docstring": "Return a stream of record batches.\n\nThe returned `RecordBatchReader` contains a cursor with an unbounded lifetime.\n\nFor analytics use cases this is usually nothing to fret about. In some cases you\nmay need to explicit release the cursor.\n\nParameters\n----------\nexpr\n    Ibis expression\nparams\n    Bound parameters\nlimit\n    Limit the result to this number of rows\nchunk_size\n    The number of rows to fetch per batch", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "type": "function"}
{"source": "ibis/backends/databricks/__init__.py::finalizer", "docstring": "Finalizer for in-memory tables.\n\nThe view that references the storage is temporary and will be\nautomatically removed, so remove only the backing file.\n\nIt's not ideal that you can remove the data out from under the\nview but in our case we're assuming that if this is invoked, the\nview is no longer needed because the process is shutting down and\ntherefore if the file is removed, it won't be long before the view\nis also removed (automatically by databricks).", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::as_nullable", "docstring": "Recursively convert a possibly non-nullable datatype to a nullable one.", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::_create_and_drop_memtable", "docstring": "Workaround inability to overwrite tables in dataframe API.\n\nDataFusion has helper methods for loading in-memory data, but these methods\ndon't allow overwriting tables.\nThe SQL interface allows creating tables from existing tables, so we register\nthe data as a table using the dataframe API, then run a\n\nCREATE [OR REPLACE] TABLE table_name AS SELECT * FROM in_memory_thing\n\nand that allows us to toggle the overwrite flag.", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::do_connect", "docstring": "Create a DataFusion `Backend` for use with Ibis.\n\nParameters\n----------\nconfig\n    Mapping of table names to files (deprecated in 10.0) or a `SessionContext`\n    instance.\n\nExamples\n--------\n>>> from datafusion import SessionContext\n>>> ctx = SessionContext()\n>>> _ = ctx.from_pydict({\"a\": [1, 2, 3]}, \"mytable\")\n>>> import ibis\n>>> con = ibis.datafusion.connect(ctx)\n>>> con.list_tables()\n['mytable']", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::from_connection", "docstring": "Create a DataFusion `Backend` from an existing `SessionContext` instance.\n\nParameters\n----------\ncon\n    A `SessionContext` instance.", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::raw_sql", "docstring": "Execute a SQL string `query` against the database.\n\nParameters\n----------\nquery\n    Raw SQL string\nkwargs\n    Backend specific query arguments", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::read_csv", "docstring": "Register a CSV file as a table in the current database.\n\nParameters\n----------\npaths\n    The data source. A string or Path to the CSV file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to DataFusion loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npath\n    The data source.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to DataFusion loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::read_delta", "docstring": "Register a Delta Lake table as a table in the current database.\n\nParameters\n----------\npath\n    The data source. Must be a directory containing a Delta Lake table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to deltalake.DeltaTable.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::create_table", "docstring": "Create a table in DataFusion.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists", "type": "function"}
{"source": "ibis/backends/datafusion/__init__.py::truncate_table", "docstring": "Delete all rows from a table.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/tests/test_dot_sql.py::test_bare_minimum", "docstring": "Test that a backend that supports dot sql can do the most basic thing.", "type": "function"}
{"source": "ibis/backends/tests/test_string.py::test_string_methods_accents_and_emoji", "docstring": "    \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n    \u2503 string_col \u2503\n    \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n    \u2502 string     \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 AbC             \u2502\n    \u2502 \n123\n    \u2502\n    \u2502 abc, 123   \u2502\n    \u2502 123        \u2502\n    \u2502 aBc        \u2502\n    \u2502 \ud83d\udc0d         \u2502\n    \u2502 \u00c9\u00e9\u00c8\u00e8\u00ea\u00e7     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ", "type": "function"}
{"source": "ibis/backends/tests/test_string.py::test_string_methods_no_accents_and_no_emoji", "docstring": "    \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n    \u2503 string_col \u2503\n    \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n    \u2502 string     \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 AbC             \u2502\n    \u2502 \n123\n    \u2502\n    \u2502 abc, 123   \u2502\n    \u2502 123        \u2502\n    \u2502 aBc        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ", "type": "function"}
{"source": "ibis/backends/tests/test_aggregation.py::gen_test_collect_marks", "docstring": "The marks for this test fail for different combinations of parameters.\nRather than set `strict=False` (which can let bugs sneak through), we split\nthe mark generation into a function", "type": "function"}
{"source": "ibis/backends/tests/test_aggregation.py::test_aggregate_list_like", "docstring": "Tests .aggregate() where the result of an aggregation is a list-like.\n\nWe expect the list / np.array to be treated as a scalar (in other\nwords, the resulting table expression should have one element, which\nis the list / np.array).", "type": "function"}
{"source": "ibis/backends/tests/test_aggregation.py::test_aggregate_mixed_udf", "docstring": "Tests .aggregate() with multiple aggregations with mixed result types.\n\n(In particular, one aggregation that results in an array, and other\naggregation(s) that result in a non-array)", "type": "function"}
{"source": "ibis/backends/tests/test_io.py::read_table", "docstring": "For each csv `names` in `data_dir` return a `pyarrow.Table`.", "type": "function"}
{"source": "ibis/backends/tests/test_conditionals.py::test_value_cases_null", "docstring": "CASE x WHEN NULL never gets hit", "type": "function"}
{"source": "ibis/backends/tests/test_generic.py::test_select_filter_mutate", "docstring": "Test that select, filter and mutate are executed in right order.\n\nBefore PR #2635, try_fusion in analysis.py would fuse these\noperations together in a way that the order of the operations were\nwrong. (mutate was executed before filter).", "type": "function"}
{"source": "ibis/backends/tests/test_generic.py::test_select_distinct_filter_order_by_commute", "docstring": "For simple versions of these ops, the order in which they're called\ndoesn't matter, they're all handled in a commutative way.", "type": "function"}
{"source": "ibis/backends/tests/test_vectorized_udf.py::_format_udf_return_type", "docstring": "Call the given udf and return its result according to the given format\n(e.g. in the form of a list, pd.Series, np.array, etc.)", "type": "function"}
{"source": "ibis/backends/tests/test_vectorized_udf.py::_format_struct_udf_return_type", "docstring": "Call the given struct udf and return its result according to the given\nformat (e.g. in the form of a list, pd.Series, np.array, etc.)", "type": "function"}
{"source": "ibis/backends/tests/test_vectorized_udf.py::test_reduction_udf_array_return_type", "docstring": "Tests reduction UDF returning an array.", "type": "function"}
{"source": "ibis/backends/tests/test_vectorized_udf.py::test_reduction_udf_on_empty_data", "docstring": "Test that summarization can handle empty data.", "type": "function"}
{"source": "ibis/backends/tests/test_vectorized_udf.py::test_elementwise_udf_named_destruct", "docstring": "Test error when assigning name to a destruct column.", "type": "function"}
{"source": "ibis/backends/tests/test_window.py::pandas_ntile", "docstring": "Divide values into a number of buckets.\n\nIt divides an ordered and grouped data set into a number of buckets\nand assigns the appropriate bucket number to each row.\n\nReturn an integer ranging from 0 to `bucket - 1`, dividing the\npartition as equally as possible.", "type": "function"}
{"source": "ibis/backends/tests/test_client.py::test_has_operation_no_geo", "docstring": "Previously some backends mistakenly reported Geo operations as\nsupported.\n\nSince most backends don't support Geo operations, we test that\nthey're excluded here, skipping the few backends that explicitly do\nsupport them.", "type": "function"}
{"source": "ibis/backends/tests/base.py::BackendTest", "docstring": "The base class for managing configuration and data loading for a backend\nthat does not require Docker for testing (this includes both in-process\nbackends and cloud backends like Snowflake and BigQuery).", "type": "class"}
{"source": "ibis/backends/tests/base.py::ServiceBackendTest", "docstring": "Parent class to use for backend test configuration if backend requires a\nDocker container(s) in order to run locally.", "type": "class"}
{"source": "ibis/backends/tests/base.py::deps", "docstring": "A list of dependencies that must be present to run tests.", "type": "function"}
{"source": "ibis/backends/tests/base.py::__init__", "docstring": "Initializes the test class -- note that none of the arguments are\nrequired and will be provided by `pytest` or by fixtures defined in\n`ibis/backends/conftest.py`.\n\ndata_dir\n    Directory where test data resides (will be provided by the\n    `data_dir` fixture in `ibis/backends/conftest.py`)\ntmpdir\n    Pytest fixture providing a temporary directory location\nworker_id\n    A unique identifier for each worker used for running test\n    concurrently via e.g. `pytest -n auto`", "type": "function"}
{"source": "ibis/backends/tests/base.py::connect", "docstring": "Return a connection with data loaded from `data_dir`.", "type": "function"}
{"source": "ibis/backends/tests/base.py::_load_data", "docstring": "Load test data into a backend.", "type": "function"}
{"source": "ibis/backends/tests/base.py::load_tpch", "docstring": "Load TPC-H data.", "type": "function"}
{"source": "ibis/backends/tests/base.py::load_tpcds", "docstring": "Load TPC-DS data.", "type": "function"}
{"source": "ibis/backends/tests/base.py::load_data", "docstring": "Load testdata from `data_dir`.", "type": "function"}
{"source": "ibis/backends/tests/base.py::skip_if_missing_deps", "docstring": "Add an `importorskip` for any missing dependencies.", "type": "function"}
{"source": "ibis/backends/tests/base.py::preload", "docstring": "Code to execute before loading data.", "type": "function"}
{"source": "ibis/backends/tests/base.py::postload", "docstring": "Code to execute after loading data.", "type": "function"}
{"source": "ibis/backends/tests/base.py::assert_series_equal", "docstring": "Compare two Pandas Series, optionally ignoring order, dtype, and column name.\n\n`force_sort`, `check_dtype`, and `check_names` are set as class-level variables.", "type": "function"}
{"source": "ibis/backends/tests/base.py::assert_frame_equal", "docstring": "Compare two Pandas DataFrames optionally ignoring order, and dtype.\n\n`force_sort`, and `check_dtype` are set as class-level variables.", "type": "function"}
{"source": "ibis/backends/tests/base.py::test_files", "docstring": "Returns an iterable of test files to load into a Docker container before testing.", "type": "function"}
{"source": "ibis/backends/tests/base.py::preload", "docstring": "Use `docker compose cp` to copy all files from `test_files` into a container.\n\n`service_name` and `data_volume` are set as class-level variables.", "type": "function"}
{"source": "ibis/backends/tests/test_interactive.py::test_interactive_non_compilable_repr_does_not_fail", "docstring": "https://github.com/ibis-project/ibis/issues/170", "type": "function"}
{"source": "ibis/backends/tests/test_export.py::test_to_pyarrow_batches_borked_types", "docstring": "This is a temporary test to expose an(other) issue with sqlite typing\nshenanigans.", "type": "function"}
{"source": "ibis/backends/tests/test_export.py::test_memtable_to_file", "docstring": "Tests against a regression spotted in #6091 where a `memtable` that is\ncreated and then immediately exported to `parquet` (or csv) will error\nbecause we weren't registering the in-memory table before trying to export\nit.", "type": "function"}
{"source": "ibis/backends/impala/ddl.py::CTAS", "docstring": "Create Table As Select.", "type": "class"}
{"source": "ibis/backends/impala/ddl.py::CreateView", "docstring": "Create a view.", "type": "class"}
{"source": "ibis/backends/impala/metadata.py::MetadataParser", "docstring": "A simple state machine to parse the results of `DESCRIBE FORMATTED`.", "type": "class"}
{"source": "ibis/backends/impala/metadata.py::TableMetadata", "docstring": "Container for the parsed and wrangled results of `DESCRIBE FORMATTED`.", "type": "class"}
{"source": "ibis/backends/impala/__init__.py::do_connect", "docstring": "Create an Impala `Backend` for use with Ibis.\n\nParameters\n----------\nhost\n    Host name of the impalad or HiveServer2 in Hive\nport\n    Impala's HiveServer2 port\ndatabase\n    Default database when obtaining new cursors\ntimeout\n    Connection timeout in seconds when communicating with HiveServer2\nuse_ssl\n    Use SSL when connecting to HiveServer2\nca_cert\n    Local path to 3rd party CA certificate or copy of server\n    certificate for self-signed certificates. If SSL is enabled, but\n    this argument is `None`, then certificate validation is skipped.\nuser\n    LDAP user to authenticate\npassword\n    LDAP password to authenticate\nauth_mechanism\n    |   Value    | Meaning                        |\n    | :--------: | :----------------------------- |\n    | `'NOSASL'` | insecure Impala connections    |\n    | `'PLAIN'`  | insecure Hive clusters         |\n    |  `'LDAP'`  | LDAP authenticated connections |\n    | `'GSSAPI'` | Kerberos-secured clusters      |\nkerberos_service_name\n    Specify a particular `impalad` service principal.\nparams\n    Any additional parameters necessary to open a connection to Impala.\n    Please refer to impyla documentation for the full list of\n    possible arguments.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> impala_host = os.environ.get(\"IBIS_TEST_IMPALA_HOST\", \"localhost\")\n>>> impala_port = int(os.environ.get(\"IBIS_TEST_IMPALA_PORT\", 21050))\n>>> client = ibis.impala.connect(host=impala_host, port=impala_port)\n>>> client  # doctest: +ELLIPSIS\n<ibis.backends.impala.Backend object at 0x...>", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::from_connection", "docstring": "Create an Impala `Backend` from an existing HS2 connection.\n\nParameters\n----------\ncon\n    An existing connection to HiveServer2 (HS2).", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::get_schema", "docstring": "Return a Schema object for the indicated table and database.\n\nParameters\n----------\ntable_name\n    Table name\ncatalog\n    Catalog name. Unused in the impala backend.\ndatabase\n    Database name\n\nReturns\n-------\nSchema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::_get_schema_using_query", "docstring": "Return a Schema object for the indicated table and database.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::get_options", "docstring": "Return current query options for the Impala session.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::create_table", "docstring": "Create a new table using an Ibis table expression or in-memory data.\n\nParameters\n----------\nname\n    Table name\nobj\n    If passed, creates table from select statement results\nschema\n    Mutually exclusive with obj, creates an empty table with a\n    particular schema\ndatabase\n    Database name\ntemp\n    Whether a table is temporary\noverwrite\n    Do not create table if table with indicated name already exists\nexternal\n    Create an external table; Impala will not delete the underlying\n    data when the table is dropped\nformat\n    File format\nlocation\n    Specify the directory location where Impala reads and writes files\n    for the table\npartition\n    Must pass a schema to use this. Cannot partition from an\n    expression.\ntbl_properties\n    Table properties to set on table creation.\nlike_parquet\n    Can specify instead of a schema", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::avro_file", "docstring": "Create a table to read a collection of Avro data.\n\nParameters\n----------\ndirectory\n    Server path to directory containing avro files\navro_schema\n    The Avro schema for the data as a Python dict\nname\n    Table name\ndatabase\n    Database name\nexternal\n    Whether the table is external\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::delimited_file", "docstring": "Interpret delimited text files as an Ibis table expression.\n\nSee the `parquet_file` method for more details on what happens under\nthe hood.\n\nParameters\n----------\ndirectory\n    Server directory containing delimited text files\nschema\n    Ibis schema\nname\n    Name for the table; otherwise random names are generated\ndatabase\n    Database to create the table in\ndelimiter\n    Character used to delimit columns\nna_rep\n    Character used to represent NULL values\nescapechar\n    Character used to escape special characters\nlineterminator\n    Character used to delimit lines\nexternal\n    Create table as EXTERNAL (data will not be deleted on drop).\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::parquet_file", "docstring": "Create an Ibis table from the passed directory of Parquet files.\n\nThe table can be optionally named, otherwise a unique name will be\ngenerated.\n\nParameters\n----------\ndirectory\n    Path\nschema\n    If no schema provided, and neither of the like_* argument is\n    passed, one will be inferred from one of the parquet files in the\n    directory.\nlike_file\n    Absolute path to Parquet file on the server to use for schema\n    definitions. An alternative to having to supply an explicit schema\nlike_table\n    Fully scoped and escaped string to an Impala table whose schema we\n    will use for the newly created table.\nname\n    Random unique name generated otherwise\ndatabase\n    Database to create the (possibly temporary) table in\nexternal\n    If a table is external, the referenced data will not be deleted\n    when the table is dropped in Impala. Otherwise Impala takes\n    ownership of the Parquet file.\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::insert", "docstring": "Insert into an Impala table.\n\nParameters\n----------\nname\n    The table name\nobj\n    Table expression or DataFrame\ndatabase\n    The table database\noverwrite\n    If True, will replace existing contents of table\npartition\n    For partitioned tables, indicate the partition that's being\n    inserted into, either with an ordered list of partition keys or a\n    dict of partition field name to value. For example for the\n    partition (year=2007, month=7), this can be either (2007, 7) or\n    {'year': 2007, 'month': 7}.\nvalidate\n    If True, do more rigorous validation that schema of table being\n    inserted is compatible with the existing table\n\nExamples\n--------\nAppend to an existing table\n\n>>> con.insert(table_name, table_expr)  # quartodoc: +SKIP # doctest: +SKIP\n\nCompletely overwrite contents\n\n>>> con.insert(table_name, table_expr, overwrite=True)  # quartodoc: +SKIP # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::drop_table", "docstring": "Drop an Impala table.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    Database name\nforce\n    Database may throw exception if table does not exist\n\nExamples\n--------\n>>> table = \"my_table\"\n>>> db = \"operations\"\n>>> con.drop_table(table, database=db, force=True)  # quartodoc: +SKIP # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::truncate_table", "docstring": "Delete all rows from an existing table.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::drop_table_or_view", "docstring": "Drop view or table.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::cache_table", "docstring": "Caches a table in cluster memory in the given pool.\n\nParameters\n----------\ntable_name\n    Table name\ndatabase\n    Database name\npool\n    The name of the pool in which to cache the table\n\nExamples\n--------\n>>> table = \"my_table\"\n>>> db = \"operations\"\n>>> pool = \"op_4GB_pool\"\n>>> con.cache_table(\"my_table\", database=db, pool=pool)  # quartodoc: +SKIP # doctest: +SKIP", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::create_function", "docstring": "Create a function within Impala.\n\nParameters\n----------\nfunc\n    UDF or UDAF\nname\n    Function name\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::drop_udf", "docstring": "Drop a UDF.\n\nIf only name is given, this will search for the relevant UDF and drop\nit. To delete an overloaded UDF, give only a name and force=True\n\nParameters\n----------\nname\n    Function name\ninput_types\n    Input types\nforce\n    Must be set to `True` to drop overloaded UDFs\ndatabase\n    Database name\naggregate\n    Whether the function is an aggregate", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::drop_uda", "docstring": "Drop an aggregate function.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::list_udfs", "docstring": "Lists all UDFs associated with given database.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::list_udas", "docstring": "Lists all UDAFs associated with a given database.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::exists_udf", "docstring": "Checks if a given UDF exists within a specified database.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::exists_uda", "docstring": "Checks if a given UDAF exists within a specified database.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::compute_stats", "docstring": "Issue a `COMPUTE STATS` command for a given table.\n\nParameters\n----------\nname\n    Can be fully qualified (with database name)\ndatabase\n    Database name\nincremental\n    If True, issue COMPUTE INCREMENTAL STATS", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::invalidate_metadata", "docstring": "Issue an `INVALIDATE METADATA` command.\n\nOptionally this applies to a specific table. See Impala documentation.\n\nParameters\n----------\nname\n    Table name. Can be fully qualified (with database)\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::refresh", "docstring": "Reload metadata for a table.\n\nThis can be useful after ingesting data as part of an ETL pipeline, for\nexample.\n\nRelated to `INVALIDATE METADATA`. See Impala documentation for more.\n\nParameters\n----------\nname\n    Table name. Can be fully qualified (with database)\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::describe_formatted", "docstring": "Retrieve the results of a `DESCRIBE FORMATTED` command.\n\nSee Impala documentation for more.\n\nParameters\n----------\nname\n    Table name. Can be fully qualified (with database)\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::show_files", "docstring": "Retrieve results of a `SHOW FILES` command for a table.\n\nSee Impala documentation for more.\n\nParameters\n----------\nname\n    Table name. Can be fully qualified (with database)\ndatabase\n    Database name", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::get_partition_schema", "docstring": "Return the schema for the partition columns.\n\nParameters\n----------\ntable_name\n    Table name\ndatabase\n    Database name\n\nReturns\n-------\nSchema\n    Ibis schema for the partition columns", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::add_partition", "docstring": "Add a new table partition.\n\nPartition parameters can be set in a single DDL statement or you can\nuse `alter_partition` to set them after the fact.\n\nParameters\n----------\ntable_name\n    The table name.\nspec\n    The partition keys for the partition being added.\ndatabase\n    The database name. If not provided, the current database is used.\nlocation\n    Location of the partition", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::drop_partition", "docstring": "Drop an existing table partition.\n\nParameters\n----------\ntable_name\n    The table name.\nspec\n    The partition keys for the partition being dropped.\ndatabase\n    The database name. If not provided, the current database is used.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::alter_partition", "docstring": "Change settings and parameters of an existing partition.\n\nParameters\n----------\ntable_name\n    The table name\nspec\n    The partition keys for the partition being modified\ndatabase\n    The database name. If not provided, the current database is used.\nlocation\n    Location of the partition\nformat\n    Table format\ntbl_properties\n    Table properties\nserde_properties\n    Serialization/deserialization properties", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::table_stats", "docstring": "Return results of `SHOW TABLE STATS` for the table `name`.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::column_stats", "docstring": "Return results of `SHOW COLUMN STATS` for the table `name`.", "type": "function"}
{"source": "ibis/backends/impala/__init__.py::explain", "docstring": "Explain an expression.\n\nReturn the query plan associated with the indicated expression or SQL\nquery.\n\nReturns\n-------\nstr\n    Query plan", "type": "function"}
{"source": "ibis/backends/impala/udf.py::ImpalaUDF", "docstring": "Feel free to customize my __doc__ or wrap in a nicer user API.", "type": "class"}
{"source": "ibis/backends/impala/udf.py::wrap_uda", "docstring": "Creates a callable aggregation function object.\n\nMust be created in Impala to be used.\n\nParameters\n----------\nhdfs_file\n    .so file that contains relevant UDA\ninputs\n    list of strings denoting ibis datatypes\noutput\n    string denoting ibis datatype\nupdate_fn\n    Library symbol name for update function\ninit_fn\n    Library symbol name for initialization function\nmerge_fn\n    Library symbol name for merge function\nfinalize_fn\n    Library symbol name for finalize function\nserialize_fn\n    Library symbol name for serialize UDA API function. Not required for all\n    UDAs.\nname\n    Used internally to track function\ndatabase\n    Name of database", "type": "function"}
{"source": "ibis/backends/impala/udf.py::wrap_udf", "docstring": "Creates a callable scalar function object.\n\nMust be created in Impala to be used.\n\nParameters\n----------\nhdfs_file\n    .so file that contains relevant UDF\ninputs\n    Input types to UDF\noutput\n    Ibis data type\nso_symbol\n    C++ function name for relevant UDF\nname\n    Used internally to track function\ndatabase\n    Name of database", "type": "function"}
{"source": "ibis/backends/impala/udf.py::scalar_function", "docstring": "Create an operator class.\n\nParameters\n----------\ninputs\n    Ibis data type names\noutput\n    Ibis data type\nname\n    Used internally to track function\ndatabase\n    Name of database", "type": "function"}
{"source": "ibis/backends/impala/udf.py::aggregate_function", "docstring": "Create an operator class.\n\nParameters\n----------\ninputs\n    Ibis data type names\noutput\n    Ibis data type\nname\n    Used internally to track function\ndatabase\n    Name of database", "type": "function"}
{"source": "ibis/backends/bigquery/client.py::rename_partitioned_column", "docstring": "Rename native partition column to user-defined name.", "type": "function"}
{"source": "ibis/backends/bigquery/client.py::parse_project_and_dataset", "docstring": "Compute the billing project, data project, and dataset if available.\n\nThis function figure out the project id under which queries will run versus\nthe project of where the data live as well as what dataset to use.\n\nParameters\n----------\nproject : str\n    A project name\ndataset : Optional[str]\n    A `<project>.<dataset>` string or just a dataset name\n\nExamples\n--------\n>>> data_project, billing_project, dataset = parse_project_and_dataset(\n...     \"ibis-gbq\", \"foo-bar.my_dataset\"\n... )\n>>> data_project\n'foo-bar'\n>>> billing_project\n'ibis-gbq'\n>>> dataset\n'my_dataset'\n>>> data_project, billing_project, dataset = parse_project_and_dataset(\n...     \"ibis-gbq\", \"my_dataset\"\n... )\n>>> data_project\n'ibis-gbq'\n>>> billing_project\n'ibis-gbq'\n>>> dataset\n'my_dataset'\n>>> data_project, billing_project, _dataset = parse_project_and_dataset(\"ibis-gbq\")\n>>> data_project\n'ibis-gbq'", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_qualify_memtable", "docstring": "Add a BigQuery dataset and project to memtable references.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_remove_null_ordering_from_unsupported_window", "docstring": "Remove null ordering in window frame clauses not supported by BigQuery.\n\nBigQuery has only partial support for NULL FIRST/LAST in RANGE windows so\nwe remove it from any window frame clause that doesn't support it.\n\nHere's the support matrix:\n\n\u2705 sum(x) over (order by y desc nulls last)\n\ud83d\udeab sum(x) over (order by y asc nulls last)\n\u2705 sum(x) over (order by y asc nulls first)\n\ud83d\udeab sum(x) over (order by y desc nulls first)", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_force_quote_table", "docstring": "Force quote all the parts of a bigquery path.\n\nThe BigQuery identifier quoting semantics are bonkers\nhttps://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#identifiers\n\nmy-table is OK, but not mydataset.my-table\n\nmytable-287 is OK, but not mytable-287a\n\nJust quote everything.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_postprocess_arrow", "docstring": "Drop `_TABLE_SUFFIX` if present in the results, then rename columns.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_merge_params_into_config", "docstring": "Merge parameters into a QueryJobConfig.\n\nReturns a copy of `query_job_config` with the `params` merged into the `query_parameters`\nfield. `params` will override values with a key naming conflict in `query_job_config`.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::compile", "docstring": "Compile an expression for BigQuery.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_client_query", "docstring": "Run a query using the BigQuery client, possibly injecting a job_id_prefix.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_client_load_table_from_dataframe", "docstring": "Load a DataFrame into a BigQuery table, possibly with a job_id_prefix.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_client_load_table_from_file", "docstring": "Load data from a file into a BigQuery table, possibly with a job_id_prefix.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_client_load_table_from_uri", "docstring": "Load data from a URI into a BigQuery table, possibly with a job_id_prefix.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_read_file", "docstring": "Read a file into a BigQuery table.\n\nIf the table already exists, it will be dropped before loading.\n\nParameters\n----------\npath\n    Path to a file on GCS or the local filesystem. Globs are supported.\ntable_name\n    Optional table name\njob_config\n    A `LoadJobConfig` object that specifies how to load the data.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::read_parquet", "docstring": "Read Parquet data into a BigQuery table.\n\nIf the table already exists, it will be dropped before loading.\n\nParameters\n----------\npath\n    Path to a Parquet file on GCS or the local filesystem. Globs are supported.\ntable_name\n    Optional table name\nkwargs\n    Additional keyword arguments passed to `google.cloud.bigquery.LoadJobConfig`.\n\nReturns\n-------\nTable\n    An Ibis table expression", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::read_csv", "docstring": "Read CSV data into a BigQuery table.\n\nIf the table already exists, it will be dropped before loading.\n\nParameters\n----------\npath\n    Path to a CSV file on GCS or the local filesystem. Globs are supported.\ntable_name\n    Optional table name\nkwargs\n    Additional keyword arguments passed to\n    `google.cloud.bigquery.LoadJobConfig`.\n\nReturns\n-------\nTable\n    An Ibis table expression", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::read_json", "docstring": "Read newline-delimited JSON data into a BigQuery table.\n\nIf the table already exists, it will be dropped before loading.\n\nParameters\n----------\npath\n    Path to a newline-delimited JSON file on GCS or the local\n    filesystem. Globs are supported.\ntable_name\n    Optional table name\nkwargs\n    Additional keyword arguments passed to\n    `google.cloud.bigquery.LoadJobConfig`.\n\nReturns\n-------\nTable\n    An Ibis table expression", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::do_connect", "docstring": "Create a `Backend` for use with Ibis.\n\nParameters\n----------\nproject_id\n    A BigQuery project id.\ndataset_id\n    A dataset id that lives inside of the project indicated by\n    `project_id`.\ncredentials\n    Optional credentials.\napplication_name\n    A string identifying your application to Google API endpoints.\nauth_local_webserver\n    Use a local webserver for the user authentication.  Binds a\n    webserver to an open port on localhost between 8080 and 8089,\n    inclusive, to receive authentication token. If not set, defaults to\n    False, which requests a token via the console.\nauth_external_data\n    Authenticate using additional scopes required to `query external\n    data sources\n    <https://cloud.google.com/bigquery/external-data-sources>`_,\n    such as Google Sheets, files in Google Cloud Storage, or files in\n    Google Drive. If not set, defaults to False, which requests the\n    default BigQuery scopes.\nauth_cache\n    Selects the behavior of the credentials cache.\n\n    `'default'``\n        Reads credentials from disk if available, otherwise\n        authenticates and caches credentials to disk.\n\n    `'reauth'``\n        Authenticates and caches credentials to disk.\n\n    `'none'``\n        Authenticates and does **not** cache credentials.\n\n    Defaults to `'default'`.\npartition_column\n    Identifier to use instead of default `_PARTITIONTIME` partition\n    column. Defaults to `'PARTITIONTIME'`.\nclient\n    A `Client` from the `google.cloud.bigquery` package. If not\n    set, one is created using the `project_id` and `credentials`.\nstorage_client\n    A `BigQueryReadClient` from the\n    `google.cloud.bigquery_storage_v1` package. If not set, one is\n    created using the `project_id` and `credentials`.\nlocation\n    Default location for BigQuery objects.\ngenerate_job_id_prefix\n    Optional callable that generates a bigquery job ID prefix. If specified, for\n    any query job, jobs will always be created rather than optionally created by\n    BigQuery's `Client.query_and_wait`.\n\n\nReturns\n-------\nBackend\n    An instance of the BigQuery backend.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::from_connection", "docstring": "Create a BigQuery `Backend` from an existing `Client`.\n\nParameters\n----------\nclient\n    A `Client` from the `google.cloud.bigquery` package.\npartition_column\n    Identifier to use instead of default `_PARTITIONTIME` partition\n    column. Defaults to `'PARTITIONTIME'`.\nstorage_client\n    A `BigQueryReadClient` from the `google.cloud.bigquery_storage_v1`\n    package.\ndataset_id\n    A dataset id that lives inside of the project attached to `client`.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::drop_database", "docstring": "Drop a BigQuery dataset.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::compile", "docstring": "Compile an expression.\n\nParameters\n----------\nexpr\n    An ibis expression to compile.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\npretty\n    If `True`, the resulting SQL will be formatted for human readability\nkwargs\n    Additional keyword arguments", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::insert", "docstring": "Insert data into a table.\n\nParameters\n----------\nname\n    The name of the table to which data needs will be inserted.\nobj\n    The source data or expression to insert.\ndatabase\n    Name of the attached database that the table is located in.\noverwrite\n    If `True` then replace existing contents of table.", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::execute", "docstring": "Compile and execute the given Ibis expression.\n\nCompile and execute Ibis expression using this backend client\ninterface, returning results in-memory in the appropriate object type\n\nParameters\n----------\nexpr\n    Ibis expression to execute\nlimit\n    Retrieve at most this number of values/rows. Overrides any limit\n    already set on the expression.\nparams\n    Query parameters\nquery_job_config\n    QueryJobConfig, the values in the `params` argument take precedence over the ones in this object\nkwargs\n    Extra arguments specific to the backend\n\nReturns\n-------\npd.DataFrame | pd.Series | scalar\n    Output from execution", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::create_table", "docstring": "Create a table in BigQuery.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but one of `obj`\n    or `schema` must be specified\nschema\n    The schema of the table to create; optional, but one of `obj` or\n    `schema` must be specified\ndatabase\n    The BigQuery *dataset* in which to create the table; optional\ntemp\n    Whether the table is temporary\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail if\n    the table exists\ndefault_collate\n    Default collation for string columns. See BigQuery's documentation\n    for more details: https://cloud.google.com/bigquery/docs/reference/standard-sql/collation-concepts\npartition_by\n    Partition the table by the given expression. See BigQuery's documentation\n    for more details: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#partition_expression\ncluster_by\n    List of columns to cluster the table by. See BigQuery's documentation\n    for more details: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#clustering_column_list\noptions\n    BigQuery-specific table options; see the BigQuery documentation for\n    details: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#table_option_list\n\nReturns\n-------\nTable\n    The table that was just created", "type": "function"}
{"source": "ibis/backends/bigquery/__init__.py::_register_udfs", "docstring": "No op because UDFs made with CREATE TEMPORARY FUNCTION must be followed by a query.", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::do_connect", "docstring": "Connect to Snowflake.\n\nParameters\n----------\nuser\n    Username\naccount\n    A Snowflake organization ID and a Snowflake user ID, separated by a hyphen.\n    Note that a Snowflake user ID is a separate identifier from a username.\n    See https://ibis-project.org/backends/Snowflake/ for details\ndatabase\n    A Snowflake database and a Snowflake schema, separated by a `/`.\n    See https://ibis-project.org/backends/Snowflake/ for details\npassword\n    Password. If empty or `None` then `authenticator` must be passed.\nauthenticator\n    String indicating authentication method. See\n    https://docs.snowflake.com/en/developer-guide/python-connector/python-connector-example#connecting-with-oauth\n    for details.\n\n    Note that the authentication flow **will not take place** until a\n    database connection is made. This means that\n    `ibis.snowflake.connect(...)` can succeed, while subsequent API\n    calls fail if the authentication fails for any reason.\ncreate_object_udfs\n    Enable object UDF extensions defined by Ibis on the first\n    connection to the database.\nkwargs\n    Additional arguments passed to the DBAPI connection call.", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::from_snowpark", "docstring": "Create an Ibis Snowflake backend from a Snowpark session.\n\nParameters\n----------\nsession\n    A Snowpark session instance.\ncreate_object_udfs\n    Enable object UDF extensions defined by Ibis on the first\n    connection to the database.\n\nReturns\n-------\nBackend\n    An Ibis Snowflake backend instance.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import snowflake.snowpark as sp  # doctest: +SKIP\n>>> session = sp.Session.builder.configs(...).create()  # doctest: +SKIP\n>>> con = ibis.snowflake.from_snowpark(session)  # doctest: +SKIP\n>>> batting = con.tables.BATTING  # doctest: +SKIP\n>>> batting[[\"playerID\", \"RBI\"]].head()  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 playerID  \u2503 RBI   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abercda01 \u2502     0 \u2502\n\u2502 addybo01  \u2502    13 \u2502\n\u2502 allisar01 \u2502    19 \u2502\n\u2502 allisdo01 \u2502    27 \u2502\n\u2502 ansonca01 \u2502    16 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::from_connection", "docstring": "Create an Ibis Snowflake backend from an existing connection.\n\nParameters\n----------\ncon\n    A Snowflake Connector for Python connection or a Snowpark\n    session instance.\ncreate_object_udfs\n    Enable object UDF extensions defined by Ibis on the first\n    connection to the database.\n\nReturns\n-------\nBackend\n    An Ibis Snowflake backend instance.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> import snowflake.snowpark as sp  # doctest: +SKIP\n>>> session = sp.Session.builder.configs(...).create()  # doctest: +SKIP\n>>> con = ibis.snowflake.from_connection(session)  # doctest: +SKIP\n>>> batting = con.tables.BATTING  # doctest: +SKIP\n>>> batting[[\"playerID\", \"RBI\"]].head()  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 playerID  \u2503 RBI   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 abercda01 \u2502     0 \u2502\n\u2502 addybo01  \u2502    13 \u2502\n\u2502 allisar01 \u2502    19 \u2502\n\u2502 allisdo01 \u2502    27 \u2502\n\u2502 ansonca01 \u2502    16 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::create_table", "docstring": "Create a table in Snowflake.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists\ncomment\n    Add a comment to the table", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::read_csv", "docstring": "Register a CSV file as a table in the Snowflake backend.\n\nParameters\n----------\npath\n    A string or Path to a CSV file; globs are supported\ntable_name\n    Optional name for the table; if not passed, a random name will be generated\nkwargs\n    Snowflake-specific file format configuration arguments. See the documentation for\n    the full list of options: https://docs.snowflake.com/en/sql-reference/sql/create-file-format#type-csv\n\nReturns\n-------\nTable\n    The table that was read from the CSV file", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::read_json", "docstring": "Read newline-delimited JSON into an ibis table, using Snowflake.\n\nParameters\n----------\npath\n    A string or Path to a JSON file; globs are supported\ntable_name\n    Optional table name\nkwargs\n    Additional keyword arguments. See\n    https://docs.snowflake.com/en/sql-reference/sql/create-file-format#type-json\n    for the full list of options.\n\nReturns\n-------\nTable\n    An ibis table expression", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::read_parquet", "docstring": "Read a Parquet file into an ibis table, using Snowflake.\n\nParameters\n----------\npath\n    A string or Path to a Parquet file; globs are supported\ntable_name\n    Optional table name\nkwargs\n    Additional keyword arguments. See\n    https://docs.snowflake.com/en/sql-reference/sql/create-file-format#type-parquet\n    for the full list of options.\n\nReturns\n-------\nTable\n    An ibis table expression", "type": "function"}
{"source": "ibis/backends/snowflake/__init__.py::insert", "docstring": "Insert data into a table.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\nA collection of tables is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of whether the backend itself\nuses the same terminology.\n:::\n\nParameters\n----------\nname\n    The name of the table to which data needs will be inserted\nobj\n    The source data or expression to insert\ndatabase\n    Name of the attached database that the table is located in.\n\n    For multi-level table hierarchies, you can pass in a dotted string\n    path like `\"catalog.database\"` or a tuple of strings like\n    `(\"catalog\", \"database\")`.\noverwrite\n    If `True` then replace existing contents of table", "type": "function"}
{"source": "ibis/backends/sqlite/converter.py::convert_Timestamp", "docstring": "A more flexible timestamp parser.\n\nThis handles the valid formats supported by SQLite.\nSee https://sqlite.org/lang_datefunc.html#time_values for more info.", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::do_connect", "docstring": "Create an Ibis client connected to a SQLite database.\n\nMultiple database files can be accessed using the `attach()` method.\n\nParameters\n----------\ndatabase\n    File path to the SQLite database file. If `None`, creates an\n    in-memory transient database and you can use attach() to add more\n    files\ntype_map\n    An optional mapping from a string name of a SQLite \"type\" to the\n    corresponding Ibis DataType that it represents. This can be used\n    to override schema inference for a given SQLite database.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.sqlite.connect()\n>>> t = con.create_table(\"my_table\", schema=ibis.schema(dict(x=\"int64\")))\n>>> con.insert(\"my_table\", obj=[(1,), (2,), (3,)])\n>>> t\nDatabaseTable: my_table\n  x int64\n>>> t.head(1).execute()\n   x\n0  1", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a SQLite database.\n\nParameters\n----------\ncon\n    An existing connection to a SQLite database.\ntype_map\n    An optional mapping from a string name of a SQLite \"type\" to the\n    corresponding Ibis DataType that it represents. This can be used\n    to override schema inference for a given SQLite database.", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::get_schema", "docstring": "Compute the schema of a `table`.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name. Unused for sqlite.\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::attach", "docstring": "Connect another SQLite database file to the current connection.\n\nParameters\n----------\nname\n    Database name within SQLite\npath\n    Path to sqlite3 database files\n\nExamples\n--------\n>>> con1 = ibis.sqlite.connect(\"/tmp/original.db\")\n>>> con2 = ibis.sqlite.connect(\"/tmp/new.db\")\n>>> con1.attach(\"new\", \"/tmp/new.db\")\n>>> con1.list_tables(database=\"new\")\n[]", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::create_table", "docstring": "Create a table in SQLite.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists", "type": "function"}
{"source": "ibis/backends/sqlite/__init__.py::insert", "docstring": "Insert data into a table.\n\nParameters\n----------\nname\n    The name of the table to which data needs will be inserted\nobj\n    The source data or expression to insert\ndatabase\n    Name of the attached database that the table is located in.\noverwrite\n    If `True` then replace existing contents of table\n\nRaises\n------\nNotImplementedError\n    If inserting data from a different database\nValueError\n    If the type of `obj` isn't supported", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::_UDF", "docstring": "An internal record holding info about a registered UDF.", "type": "class"}
{"source": "ibis/backends/sqlite/udf.py::udf", "docstring": "Create a SQLite scalar UDF from `func`.\n\nParameters\n----------\nfunc\n    A callable object\nskip_if_exists\n    If true, the UDF will only be registered if an existing function\n    with that name doesn't already exist.\ndeterministic\n    Whether the UDF is deterministic, defaults to True.\n\nReturns\n-------\ncallable\n    A callable object that returns `None` if any of its inputs are\n    `None`.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::udaf", "docstring": "Register a UDAF class with any SQLite connection.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::log", "docstring": "Return the logarithm of `arg` in the given `base`.\n\nThe argument order matches the builtin sqlite function.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::_ibis_regex_search", "docstring": "Return whether `regex` exists in `string`.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::_ibis_regex_replace", "docstring": "Replace occurrences of `pattern` in `string` with `replacement`.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::_ibis_regex_extract", "docstring": "Extract match of regular expression `pattern` from `string` at `index`.", "type": "function"}
{"source": "ibis/backends/sqlite/udf.py::register_all", "docstring": "Register all udf and udaf with the connection.\n\nAll udf and udaf are defined in this file with the `udf` and `udaf`\ndecorators.", "type": "function"}
{"source": "ibis/backends/exasol/__init__.py::do_connect", "docstring": "Create an Ibis client connected to an Exasol database.\n\nParameters\n----------\nuser\n    Username used for authentication.\npassword\n    Password used for authentication.\nhost\n    Hostname to connect to.\nport\n    Port number to connect to.\ntimezone\n    The session timezone.\nkwargs\n    Additional keyword arguments passed to `pyexasol.connect`.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_EXASOL_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_EXASOL_USER\", \"sys\")\n>>> password = os.environ.get(\"IBIS_TEST_EXASOL_PASSWORD\", \"exasol\")\n>>> schema = os.environ.get(\"IBIS_TEST_EXASOL_DATABASE\", \"EXASOL\")\n>>> con = ibis.exasol.connect(schema=schema, host=host, user=user, password=password)\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int32\n  bool_col        boolean\n  tinyint_col     int16\n  smallint_col    int16\n  int_col         int32\n  bigint_col      int64\n  float_col       float64\n  double_col      float64\n  date_string_col string(256)\n  string_col      string(256)\n  timestamp_col   timestamp(3)\n  year            int32\n  month           int32", "type": "function"}
{"source": "ibis/backends/exasol/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to an Exasol database.\n\nParameters\n----------\ncon\n    An existing connection to an Exasol database.\ntimezone\n    The session timezone.", "type": "function"}
{"source": "ibis/backends/exasol/__init__.py::create_table", "docstring": "Create a table in Exasol.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The database in which to create the table; optional\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists\ntemp\n    Create a temporary table (not supported)", "type": "function"}
{"source": "ibis/backends/exasol/__init__.py::process_item", "docstring": "Handle inserting timestamps with timezones.", "type": "function"}
{"source": "ibis/backends/postgres/__init__.py::execute", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nDataFrame | Series | scalar\n    The result of the expression execution.", "type": "function"}
{"source": "ibis/backends/postgres/__init__.py::do_connect", "docstring": "Create an Ibis client connected to PostgreSQL database.\n\nParameters\n----------\nhost\n    Hostname\nuser\n    Username\npassword\n    Password\nport\n    Port number\ndatabase\n    Database to connect to\nschema\n    PostgreSQL schema to use. If `None`, use the default `search_path`.\nautocommit\n    Whether or not to autocommit\nkwargs\n    Additional keyword arguments to pass to the backend client connection.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_POSTGRES_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_POSTGRES_USER\", \"postgres\")\n>>> password = os.environ.get(\"IBIS_TEST_POSTGRES_PASSWORD\", \"postgres\")\n>>> database = os.environ.get(\"IBIS_TEST_POSTGRES_DATABASE\", \"ibis_testing\")\n>>> con = ibis.postgres.connect(database=database, host=host, user=user, password=password)\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int32\n  bool_col        boolean\n  tinyint_col     int16\n  smallint_col    int16\n  int_col         int32\n  bigint_col      int64\n  float_col       float32\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   timestamp(6)\n  year            int32\n  month           int32", "type": "function"}
{"source": "ibis/backends/postgres/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a PostgreSQL database.\n\nParameters\n----------\ncon\n    An existing connection to a PostgreSQL database.", "type": "function"}
{"source": "ibis/backends/postgres/__init__.py::create_table", "docstring": "Create a table in Postgres.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a PostgreSQL database.\n\nParameters\n----------\ncon\n    An existing connection to a PostgreSQL database.", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::do_connect", "docstring": "Create an Ibis client connected to RisingWave database.\n\nParameters\n----------\nhost\n    Hostname\nuser\n    Username\npassword\n    Password\nport\n    Port number\ndatabase\n    Database to connect to\nschema\n    RisingWave schema to use. If `None`, use the default `search_path`.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_RISINGWAVE_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_RISINGWAVE_USER\", \"root\")\n>>> password = os.environ.get(\"IBIS_TEST_RISINGWAVE_PASSWORD\", \"\")\n>>> database = os.environ.get(\"IBIS_TEST_RISINGWAVE_DATABASE\", \"dev\")\n>>> con = ibis.risingwave.connect(\n...     database=database,\n...     host=host,\n...     user=user,\n...     password=password,\n...     port=4566,\n... )\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int32\n  bool_col        boolean\n  tinyint_col     int16\n  smallint_col    int16\n  int_col         int32\n  bigint_col      int64\n  float_col       float32\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   timestamp(6)\n  year            int32\n  month           int32", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::create_table", "docstring": "Create a table in RisingWave.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists\nconnector_properties\n    The properties of the sink connector, providing the connector settings to push to the downstream data sink.\n    Refer https://docs.risingwave.com/docs/current/data-delivery/ for the required properties of different data sink.\ndata_format\n    The data format for the new source, e.g., \"PLAIN\". data_format and encode_format must be specified at the same time.\nencode_format\n    The encode format for the new source, e.g., \"JSON\". data_format and encode_format must be specified at the same time.\nencode_properties\n    The properties of encode format, providing information like schema registry url. Refer https://docs.risingwave.com/docs/current/sql-create-source/ for more details.\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::create_materialized_view", "docstring": "Create a materialized view. Materialized views can be accessed like a normal table.\n\nParameters\n----------\nname\n    Materialized view name to Create.\nobj\n    The select statement to materialize.\ndatabase\n    Name of the database where the view exists, if not the default\noverwrite\n    Whether to overwrite the existing materialized view with the same name\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::drop_materialized_view", "docstring": "Drop a materialized view.\n\nParameters\n----------\nname\n    Materialized view name to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\nforce\n    If `False`, an exception is raised if the view does not exist.", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::create_source", "docstring": "Creating a source.\n\nParameters\n----------\nname\n    Source name to Create.\nschema\n    The schema for the new Source.\ndatabase\n    Name of the database where the source exists, if not the default.\nconnector_properties\n    The properties of the source connector, providing the connector settings to access the upstream data source.\n    Refer https://docs.risingwave.com/docs/current/data-ingestion/ for the required properties of different data source.\ndata_format\n    The data format for the new source, e.g., \"PLAIN\". data_format and encode_format must be specified at the same time.\nencode_format\n    The encode format for the new source, e.g., \"JSON\". data_format and encode_format must be specified at the same time.\nencode_properties\n    The properties of encode format, providing information like schema registry url. Refer https://docs.risingwave.com/docs/current/sql-create-source/ for more details.\nincludes\n    A dict of `INCLUDE` clauses of the form `{field: alias, ...}`.\n    Set value(s) to `None` if no alias is needed. Refer to https://docs.risingwave.com/docs/current/sql-create-source/ for more details.\n\nReturns\n-------\nTable\n    Table expression", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::drop_source", "docstring": "Drop a Source.\n\nParameters\n----------\nname\n    Source name to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\nforce\n    If `False`, an exception is raised if the source does not exist.", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::create_sink", "docstring": "Creating a sink.\n\nParameters\n----------\nname\n    Sink name to Create.\nsink_from\n    The table or materialized view name to sink from. Only one of `sink_from` or `obj` can be\n    provided.\nconnector_properties\n    The properties of the sink connector, providing the connector settings to push to the downstream data sink.\n    Refer https://docs.risingwave.com/docs/current/data-delivery/ for the required properties of different data sink.\nobj\n    An Ibis table expression that will be used to extract the schema and the data of the new table. Only one of `sink_from` or `obj` can be provided.\ndatabase\n    Name of the database where the source exists, if not the default.\ndata_format\n    The data format for the new source, e.g., \"PLAIN\". data_format and encode_format must be specified at the same time.\nencode_format\n    The encode format for the new source, e.g., \"JSON\". data_format and encode_format must be specified at the same time.\nencode_properties\n    The properties of encode format, providing information like schema registry url. Refer https://docs.risingwave.com/docs/current/sql-create-source/ for more details.", "type": "function"}
{"source": "ibis/backends/risingwave/__init__.py::drop_sink", "docstring": "Drop a Sink.\n\nParameters\n----------\nname\n    Sink name to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\nforce\n    If `False`, an exception is raised if the source does not exist.", "type": "function"}
{"source": "ibis/backends/mysql/__init__.py::do_connect", "docstring": "Create an Ibis client using the passed connection parameters.\n\nParameters\n----------\nhost\n    Hostname\nuser\n    Username\npassword\n    Password\nport\n    Port\nautocommit\n    Autocommit mode\nkwargs\n    Additional keyword arguments passed to `MySQLdb.connect`\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_MYSQL_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_MYSQL_USER\", \"ibis\")\n>>> password = os.environ.get(\"IBIS_TEST_MYSQL_PASSWORD\", \"ibis\")\n>>> database = os.environ.get(\"IBIS_TEST_MYSQL_DATABASE\", \"ibis-testing\")\n>>> con = ibis.mysql.connect(database=database, host=host, user=user, password=password)\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int32\n  bool_col        int8\n  tinyint_col     int8\n  smallint_col    int16\n  int_col         int32\n  bigint_col      int64\n  float_col       float32\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   timestamp\n  year            int32\n  month           int32", "type": "function"}
{"source": "ibis/backends/mysql/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a MySQL database.\n\nParameters\n----------\ncon\n    An existing connection to a MySQL database.", "type": "function"}
{"source": "ibis/backends/mysql/__init__.py::execute", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "type": "function"}
{"source": "ibis/backends/mysql/datatypes.py::_type_from_cursor_info", "docstring": "Construct an ibis type from MySQL field descr and field result metadata.\n\nThis method is complex because the MySQL protocol is complex.\n\nTypes are not encoded in a self contained way, meaning you need\nmultiple pieces of information coming from the result set metadata to\ndetermine the most precise type for a field. Even then, the decoding is\nnot high fidelity in some cases: UUIDs for example are decoded as\nstrings, because the protocol does not appear to preserve the logical\ntype, only the physical type.", "type": "function"}
{"source": "ibis/backends/mysql/datatypes.py::_FieldFlags", "docstring": "Flags used to disambiguate field types.\n\nGaps in the flag numbers are because we do not map in flags that are\nof no use in determining the field's type, such as whether the field\nis a primary key or not.", "type": "class"}
{"source": "ibis/backends/druid/__init__.py::do_connect", "docstring": "Create an Ibis client using the passed connection parameters.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.connect(\"druid://localhost:8082/druid/v2/sql?header=true\")\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  __time          timestamp\n  id              int64\n  bool_col        int64\n  tinyint_col     int64\n  smallint_col    int64\n  int_col         int64\n  bigint_col      int64\n  float_col       float64\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   int64\n  year            int64\n  month           int64", "type": "function"}
{"source": "ibis/backends/druid/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a Druid database.\n\nParameters\n----------\ncon\n    An existing connection to a Druid database.", "type": "function"}
{"source": "ibis/backends/druid/__init__.py::_register_in_memory_table", "docstring": "No-op. Table are inlined, for better or worse.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::create_table", "docstring": "Create a table in DuckDB.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but at least\n    one of `obj` or `schema` must be specified\nschema\n    The schema of the table to create; optional, but at least one of\n    `obj` or `schema` must be specified\ndatabase\n    The name of the database in which to create the table; if not\n    passed, the current database is used.\n\n    For multi-level table hierarchies, you can pass in a dotted string\n    path like `\"catalog.database\"` or a tuple of strings like\n    `(\"catalog\", \"database\")`.\ntemp\n    Create a temporary table\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail\n    if the table exists", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::get_schema", "docstring": "Compute the schema of a `table`.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::do_connect", "docstring": "Create an Ibis client connected to a DuckDB database.\n\n::: {.callout-note title=\"Changed in version 10.0.0\"}\nBefore, we had special handling if the user passed the `temp_directory`\nparameter, setting a custom default, and creating intermediate\ndirectories if necessary. Now, we do nothing, and just pass the value\ndirectly to DuckDB. You may need to add\n`Path(your_temp_dir).mkdir(exists_ok=True, parents=True)`\nto your code to maintain the old behavior.\n:::\n\nParameters\n----------\ndatabase\n    Path to a duckdb database.\nread_only\n    Whether the database is read-only.\nextensions\n    A list of duckdb extensions to install/load upon connection.\nconfig\n    DuckDB configuration parameters. See the [DuckDB configuration\n    documentation](https://duckdb.org/docs/sql/configuration) for\n    possible configuration values.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.duckdb.connect(threads=4, memory_limit=\"1GB\")  # doctest: +ELLIPSIS\n<ibis.backends.duckdb.Backend object at 0x...>", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a DuckDB database.\n\nParameters\n----------\ncon\n    An existing connection to a DuckDB database.\nextensions\n    A list of duckdb extensions to install/load upon connection.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::load_extension", "docstring": "Install and load a duckdb extension by name or path.\n\nParameters\n----------\nextension\n    The extension name or path.\nforce_install\n    Force reinstallation of the extension.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_json", "docstring": "Read newline-delimited JSON into an ibis table.\n\n::: {.callout-note}\n## This feature requires duckdb>=0.7.0\n:::\n\nParameters\n----------\npaths\n    File or list of files\ntable_name\n    Optional table name\ncolumns\n    Optional mapping from string column name to duckdb type string.\n**kwargs\n    Additional keyword arguments passed to DuckDB's `read_json_auto` function.\n\n    See https://duckdb.org/docs/data/json/overview.html#json-loading\n    for parameters and more information about reading JSON.\n\nReturns\n-------\nTable\n    An ibis table expression", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_csv", "docstring": "Register a CSV file as a table in the current database.\n\nParameters\n----------\npaths\n    The data source(s). May be a path to a file or directory of CSV\n    files, or an iterable of CSV files.\ntable_name\n    An optional name to use for the created table. This defaults to a\n    sequentially generated name.\ncolumns\n    An optional mapping of **all** column names to their types.\ntypes\n    An optional mapping of a **subset** of column names to their types.\n**kwargs\n    Additional keyword arguments passed to DuckDB loading function. See\n    https://duckdb.org/docs/data/csv for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table\n\nExamples\n--------\nGenerate some data\n\n>>> import tempfile\n>>> data = b'''\n... lat,lon,geom\n... 1.0,2.0,POINT (1 2)\n... 2.0,3.0,POINT (2 3)\n... '''\n>>> with tempfile.NamedTemporaryFile(delete=False) as f:\n...     nbytes = f.write(data)\n\nImport Ibis\n\n>>> import ibis\n>>> from ibis import _\n>>> ibis.options.interactive = True\n>>> con = ibis.duckdb.connect()\n\nRead the raw CSV file\n\n>>> t = con.read_csv(f.name)\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 lat     \u2503 lon     \u2503 geom        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 float64 \u2502 string      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1.0 \u2502     2.0 \u2502 POINT (1 2) \u2502\n\u2502     2.0 \u2502     3.0 \u2502 POINT (2 3) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nLoad the `spatial` extension and read the CSV file again, using\nspecific column types\n\n>>> con.load_extension(\"spatial\")\n>>> t = con.read_csv(f.name, types={\"geom\": \"geometry\"})\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 lat     \u2503 lon     \u2503 geom                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 float64 \u2502 float64 \u2502 geospatial:geometry  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1.0 \u2502     2.0 \u2502 <POINT (1 2)>        \u2502\n\u2502     2.0 \u2502     3.0 \u2502 <POINT (2 3)>        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_geo", "docstring": "Register a geospatial data file as a table in the current database.\n\nParameters\n----------\npath\n    The data source(s). Path to a file of geospatial files supported by duckdb.\n    See https://duckdb.org/docs/extensions/spatial.html#st_read---read-spatial-data-from-files\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\nkwargs\n    Additional keyword arguments passed to DuckDB loading function.\n    See https://duckdb.org/docs/extensions/spatial.html#st_read---read-spatial-data-from-files\n    for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npaths\n    The data source(s). May be a path to a file, an iterable of files,\n    or directory of parquet files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to DuckDB loading function.\n    See https://duckdb.org/docs/data/parquet for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_delta", "docstring": "Register a Delta Lake table as a table in the current database.\n\nParameters\n----------\npath\n    The data source. Must be a directory containing a Delta Lake table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\nkwargs\n    Additional keyword arguments passed to deltalake.DeltaTable.\n\nReturns\n-------\nir.Table\n    The just-registered table.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_postgres", "docstring": "Register a table from a postgres instance into a DuckDB table.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of whether the backend itself\nuses the same terminology.\n:::\n\nParameters\n----------\nuri\n    A postgres URI of the form `postgres://user:password@host:port`\ntable_name\n    The table to read\ndatabase\n    PostgreSQL database (schema) where `table_name` resides\n\nReturns\n-------\nir.Table\n    The just-registered table.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_mysql", "docstring": "Register a table from a MySQL instance into a DuckDB table.\n\nParameters\n----------\nuri\n    A mysql URI of the form `mysql://user:password@host:port/database`\ncatalog\n    User-defined alias given to the MySQL database that is being attached\n    to DuckDB\ntable_name\n    The table to read\n\nReturns\n-------\nir.Table\n    The just-registered table.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_sqlite", "docstring": "Register a table from a SQLite database into a DuckDB table.\n\nParameters\n----------\npath\n    The path to the SQLite database\ntable_name\n    The table to read\n\nReturns\n-------\nir.Table\n    The just-registered table.\n\nExamples\n--------\n>>> import ibis\n>>> import sqlite3\n>>> ibis.options.interactive = True\n>>> con = sqlite3.connect(\"/tmp/sqlite.db\")\n>>> with con:\n...     con.execute(\"DROP TABLE IF EXISTS t\")  # doctest: +ELLIPSIS\n...     con.execute(\"CREATE TABLE t (a INT, b TEXT)\")  # doctest: +ELLIPSIS\n...     con.execute(\n...         \"INSERT INTO t VALUES (1, 'a'), (2, 'b'), (3, 'c')\"\n...     )  # doctest: +ELLIPSIS\n<...>\n>>> con.close()\n>>> con = ibis.connect(\"duckdb://\")\n>>> t = con.read_sqlite(\"/tmp/sqlite.db\", table_name=\"t\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 a      \u2502\n\u2502     2 \u2502 b      \u2502\n\u2502     3 \u2502 c      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::read_xlsx", "docstring": "Read an Excel file into a DuckDB table. This requires duckdb>=1.2.0.\n\nParameters\n----------\npath\n    The path to the Excel file.\nsheet\n    The name of the sheet to read, eg 'Sheet3'.\nrange\n    The range of cells to read, eg 'A5:Z'.\nkwargs\n    Additional args passed to the backend's read function.\n\nReturns\n-------\nir.Table\n    The just-registered table.\n\nSee Also\n--------\n[DuckDB's `excel` extension docs for reading](https://duckdb.org/docs/stable/extensions/excel.html#reading-xlsx-files)\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> t = ibis.memtable({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]})\n>>> con = ibis.duckdb.connect()\n>>> con.to_xlsx(t, \"/tmp/test.xlsx\", header=True)\n>>> assert os.path.exists(\"/tmp/test.xlsx\")\n>>> t = con.read_xlsx(\"/tmp/test.xlsx\")\n>>> t.columns\n('a', 'b')", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_xlsx", "docstring": "Write a table to an Excel file.\n\nParameters\n----------\nexpr\n    Ibis table expression to write to an excel file.\npath\n    Excel output path.\nsheet\n    The name of the sheet to write to, eg 'Sheet3'.\nheader\n    Whether to include the column names as the first row.\nparams\n    Additional Ibis expression parameters to pass to the backend's\n    write function.\nkwargs\n    Additional arguments passed to the backend's write function.\n\nNotes\n-----\nRequires DuckDB >= 1.2.0.\n\nSee Also\n--------\n[DuckDB's `excel` extension docs for writing](https://duckdb.org/docs/stable/extensions/excel.html#writing-xlsx-files)\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> t = ibis.memtable({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]})\n>>> con = ibis.duckdb.connect()\n>>> con.to_xlsx(t, \"/tmp/test.xlsx\")\n>>> os.path.exists(\"/tmp/test.xlsx\")\nTrue", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::attach", "docstring": "Attach another DuckDB database to the current DuckDB session.\n\nParameters\n----------\npath\n    Path to the database to attach.\nname\n    Name to attach the database as. Defaults to the basename of `path`.\nread_only\n    Whether to attach the database as read-only.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::detach", "docstring": "Detach a database from the current DuckDB session.\n\nParameters\n----------\nname\n    The name of the database to detach.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::attach_sqlite", "docstring": "Attach a SQLite database to the current DuckDB session.\n\nParameters\n----------\npath\n    The path to the SQLite database.\noverwrite\n    Allow overwriting any tables or views that already exist in your current\n    session with the contents of the SQLite database.\nall_varchar\n    Set all SQLite columns to type `VARCHAR` to avoid type errors on ingestion.\n\nExamples\n--------\n>>> import ibis\n>>> import sqlite3\n>>> con = sqlite3.connect(\"/tmp/attach_sqlite.db\")\n>>> with con:\n...     con.execute(\"DROP TABLE IF EXISTS t\")  # doctest: +ELLIPSIS\n...     con.execute(\"CREATE TABLE t (a INT, b TEXT)\")  # doctest: +ELLIPSIS\n...     con.execute(\n...         \"INSERT INTO t VALUES (1, 'a'), (2, 'b'), (3, 'c')\"\n...     )  # doctest: +ELLIPSIS\n<...>\n>>> con.close()\n>>> con = ibis.connect(\"duckdb://\")\n>>> con.list_tables()\n[]\n>>> con.attach_sqlite(\"/tmp/attach_sqlite.db\")\n>>> con.list_tables()\n['t']", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::register_filesystem", "docstring": "Register an `fsspec` filesystem object with DuckDB.\n\nThis allow a user to read from any `fsspec` compatible filesystem using\n`read_csv`, `read_parquet`, `read_json`, etc.\n\n\n::: {.callout-note}\nCreating an `fsspec` filesystem requires that the corresponding\nbackend-specific `fsspec` helper library is installed.\n\ne.g. to connect to Google Cloud Storage, `gcsfs` must be installed.\n:::\n\nParameters\n----------\nfilesystem\n    The fsspec filesystem object to register with DuckDB.\n    See https://duckdb.org/docs/guides/python/filesystems for details.\n\nExamples\n--------\n>>> import ibis\n>>> import fsspec\n>>> ibis.options.interactive = True\n>>> gcs = fsspec.filesystem(\"gcs\")\n>>> con = ibis.duckdb.connect()\n>>> con.register_filesystem(gcs)\n>>> t = con.read_csv(\n...     \"gcs://ibis-examples/data/band_members.csv.gz\",\n...     table_name=\"band_members\",\n... )\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name   \u2503 band    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mick   \u2502 Stones  \u2502\n\u2502 John   \u2502 Beatles \u2502\n\u2502 Paul   \u2502 Beatles \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::_to_duckdb_relation", "docstring": "Preprocess the expr, and return a `duckdb.DuckDBPyRelation` object.\n\nWhen retrieving in-memory results, it's faster to use `duckdb_con.sql`\nthan `duckdb_con.execute`, as the query planner can take advantage of\nknowing the output type. Since the relation objects aren't compatible\nwith the dbapi, we choose to only use them in select internal methods\nwhere performance might matter, and use the standard\n`duckdb_con.execute` everywhere else.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_pyarrow_batches", "docstring": "Return a stream of record batches.\n\nThe returned `RecordBatchReader` contains a cursor with an unbounded lifetime.\n\nFor analytics use cases this is usually nothing to fret about. In some cases you\nmay need to explicit release the cursor.\n\nParameters\n----------\nexpr\n    Ibis expression\nparams\n    Bound parameters\nlimit\n    Limit the result to this number of rows\nchunk_size\n    The number of rows to fetch per batch", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::execute", "docstring": "Execute an expression.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_torch", "docstring": "Execute an expression and return results as a dictionary of torch tensors.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Parameters to substitute into the expression.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nkwargs\n    Keyword arguments passed into the backend's `to_torch` implementation.\n\nReturns\n-------\ndict[str, torch.Tensor]\n    A dictionary of torch tensors, keyed by column name.", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_parquet", "docstring": "Write the results of executing the given expression to a parquet file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\npath\n    The data source. A string or Path to the parquet file.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    DuckDB Parquet writer arguments. See\n    https://duckdb.org/docs/data/parquet/overview.html#writing-to-parquet-files\n    for details.\n\nExamples\n--------\nWrite out an expression to a single parquet file.\n\n>>> import ibis\n>>> penguins = ibis.examples.penguins.fetch()\n>>> con = ibis.get_backend(penguins)\n>>> con.to_parquet(penguins, \"/tmp/penguins.parquet\")\n\nWrite out an expression to a hive-partitioned parquet file.\n\n>>> import tempfile\n>>> penguins = ibis.examples.penguins.fetch()\n>>> con = ibis.get_backend(penguins)\n\nPartition on a single column.\n\n>>> con.to_parquet(penguins, tempfile.mkdtemp(), partition_by=\"year\")\n\nPartition on multiple columns.\n\n>>> con.to_parquet(penguins, tempfile.mkdtemp(), partition_by=(\"year\", \"island\"))", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_csv", "docstring": "Write the results of executing the given expression to a CSV file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to CSV.\npath\n    The data source. A string or Path to the CSV file.\nparams\n    Mapping of scalar parameter expressions to value.\nheader\n    Whether to write the column names as the first line of the CSV file.\nkwargs\n    DuckDB CSV writer arguments. https://duckdb.org/docs/data/csv/overview.html#parameters", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_geo", "docstring": "Write the results of executing `expr` to a geospatial output.\n\nParameters\n----------\nexpr\n    Ibis expression to execute and persist to geospatial output.\npath\n    A string or Path to the desired output file location.\nformat\n    The format of the geospatial output. One of GDAL's supported vector formats.\n    The list of vector formats is located here: https://gdal.org/en/latest/drivers/vector/index.html\nlayer_creation_options\n    A mapping of layer creation options.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nkwargs\n    Additional keyword arguments passed to the DuckDB `COPY` command.\n\nExamples\n--------\n>>> import os\n>>> import tempfile\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from ibis import _\n\nLoad some geospatial data\n\n>>> con = ibis.duckdb.connect()\n>>> zones = ibis.examples.zones.fetch(backend=con)\n>>> zones[[\"zone\", \"geom\"]].head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 zone                                  \u2503 geom                                 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                                \u2502 geospatial:geometry                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                       \u2502 <POLYGON ((933100.918 192536.086,    \u2502\n\u2502 Newark Airport                        \u2502 933091.011 192572.175, 933088.585    \u2502\n\u2502                                       \u2502 192604.9...>                         \u2502\n\u2502                                       \u2502 <MULTIPOLYGON (((1033269.244         \u2502\n\u2502 Jamaica Bay                           \u2502 172126.008, 1033439.643 170883.946,  \u2502\n\u2502                                       \u2502 1033473.265...>                      \u2502\n\u2502                                       \u2502 <POLYGON ((1026308.77 256767.698,    \u2502\n\u2502 Allerton/Pelham Gardens               \u2502 1026495.593 256638.616, 1026567.23   \u2502\n\u2502                                       \u2502 256589....>                          \u2502\n\u2502                                       \u2502 <POLYGON ((992073.467 203714.076,    \u2502\n\u2502 Alphabet City                         \u2502 992068.667 203711.502, 992061.716    \u2502\n\u2502                                       \u2502 203711.7...>                         \u2502\n\u2502                                       \u2502 <POLYGON ((935843.31 144283.336,     \u2502\n\u2502 Arden Heights                         \u2502 936046.565 144173.418, 936387.922    \u2502\n\u2502                                       \u2502 143967.75...>                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWrite to a GeoJSON file\n\n>>> with tempfile.TemporaryDirectory() as tmpdir:\n...     con.to_geo(\n...         zones,\n...         path=os.path.join(tmpdir, \"zones.geojson\"),\n...         format=\"geojson\",\n...     )\n\nWrite to a Shapefile\n\n>>> with tempfile.TemporaryDirectory() as tmpdir:\n...     con.to_geo(\n...         zones,\n...         path=os.path.join(tmpdir, \"zones.shp\"),\n...         format=\"ESRI Shapefile\",\n...     )", "type": "function"}
{"source": "ibis/backends/duckdb/__init__.py::to_json", "docstring": "Write the results of `expr` to a json file of [{column -> value}, ...] objects.\n\nThis method is eager and will execute the associated expression\nimmediately.\nSee https://duckdb.org/docs/sql/statements/copy.html#json-options\nfor more info.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to Delta Lake table.\npath\n    URLs such as S3 buckets are supported.\ncompression\n    Compression codec to use. One of \"auto\", \"none\", \"gzip\", \"zstd\".\ndateformat\n    Date format string.\ntimestampformat\n    Timestamp format string.", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::do_connect", "docstring": "Construct a client from a dictionary of polars `LazyFrame`s and/or `DataFrame`s.\n\nParameters\n----------\ntables\n    An optional mapping of string table names to polars LazyFrames.\n\nExamples\n--------\n>>> import ibis\n>>> import polars as pl\n>>> ibis.options.interactive = True\n>>> lazy_frame = pl.LazyFrame(\n...     {\"name\": [\"Jimmy\", \"Keith\"], \"band\": [\"Led Zeppelin\", \"Stones\"]}\n... )\n>>> con = ibis.polars.connect(tables={\"band_members\": lazy_frame})\n>>> t = con.table(\"band_members\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 name   \u2503 band         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 string       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Jimmy  \u2502 Led Zeppelin \u2502\n\u2502 Keith  \u2502 Stones       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::read_csv", "docstring": "Register a CSV file as a table.\n\nParameters\n----------\npath\n    The data source. A string or Path to the CSV file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to Polars loading function.\n    See https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.scan_csv.html\n    for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::read_json", "docstring": "Register a JSON file as a table.\n\nParameters\n----------\npath\n    A string or Path to a JSON file; globs are supported\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to Polars loading function.\n    See https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.scan_ndjson.html\n    for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::read_delta", "docstring": "Register a Delta Lake as a table in the current database.\n\nParameters\n----------\npath\n    The data source(s). Path to a Delta Lake table directory.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to Polars loading function.\n    See https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.scan_delta.html\n    for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::read_pandas", "docstring": "Register a Pandas DataFrame or pyarrow Table a table in the current database.\n\nParameters\n----------\nsource\n    The data source.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to Polars loading function.\n    See https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.from_pandas.html\n    for more information.\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/polars/__init__.py::read_parquet", "docstring": "Register a parquet file as a table in the current database.\n\nParameters\n----------\npath\n    The data source(s). May be a path to a file, an iterable of files,\n    or directory of parquet files.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to Polars loading function.\n    See https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.scan_parquet.html\n    for more information (if loading a single file or glob; when loading\n    multiple files polars' `scan_pyarrow_dataset` method is used instead).\n\nReturns\n-------\nir.Table\n    The just-registered table", "type": "function"}
{"source": "ibis/backends/mssql/__init__.py::datetimeoffset_to_datetime", "docstring": "Convert a datetimeoffset value to a datetime.\n\nAdapted from https://github.com/mkleehammer/pyodbc/issues/1141", "type": "function"}
{"source": "ibis/backends/mssql/__init__.py::do_connect", "docstring": "Connect to MSSQL database.\n\nParameters\n----------\nhost\n    Address of MSSQL server to connect to.\nuser\n    Username.  Leave blank to use Integrated Authentication.\npassword\n    Password.  Leave blank to use Integrated Authentication.\nport\n    Port of MSSQL server to connect to.\ndatabase\n    The MSSQL database to connect to.\ndriver\n    ODBC Driver to use.\n\n    On Mac and Linux this is usually 'FreeTDS'.\n\n    On Windows, it is usually one of:\n\n    - ODBC Driver 11 for SQL Server\n    - ODBC Driver 13 for SQL Server (for both 13 and 13.1)\n    - ODBC Driver 17 for SQL Server\n    - ODBC Driver 18 for SQL Server\n\n    See https://learn.microsoft.com/en-us/sql/connect/odbc/windows/system-requirements-installation-and-driver-files\nkwargs\n    Additional keyword arguments to pass to PyODBC.\n\nExamples\n--------\n>>> import os\n>>> import ibis\n>>> host = os.environ.get(\"IBIS_TEST_MSSQL_HOST\", \"localhost\")\n>>> user = os.environ.get(\"IBIS_TEST_MSSQL_USER\", \"sa\")\n>>> password = os.environ.get(\"IBIS_TEST_MSSQL_PASSWORD\", \"1bis_Testing!\")\n>>> database = os.environ.get(\"IBIS_TEST_MSSQL_DATABASE\", \"ibis-testing\")\n>>> driver = os.environ.get(\"IBIS_TEST_MSSQL_PYODBC_DRIVER\", \"FreeTDS\")\n>>> con = ibis.mssql.connect(\n...     database=database,\n...     host=host,\n...     user=user,\n...     password=password,\n...     driver=driver,\n... )\n>>> con.list_tables()  # doctest: +ELLIPSIS\n[...]\n>>> t = con.table(\"functional_alltypes\")\n>>> t\nDatabaseTable: functional_alltypes\n  id              int32\n  bool_col        boolean\n  tinyint_col     int16\n  smallint_col    int16\n  int_col         int32\n  bigint_col      int64\n  float_col       float32\n  double_col      float64\n  date_string_col string\n  string_col      string\n  timestamp_col   timestamp(7)\n  year            int32\n  month           int32", "type": "function"}
{"source": "ibis/backends/mssql/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to a MSSQL database.\n\nParameters\n----------\ncon\n    An existing connection to a MSSQL database.", "type": "function"}
{"source": "ibis/backends/mssql/__init__.py::create_table", "docstring": "Create a new table.\n\nParameters\n----------\nname\n    Name of the new table.\nobj\n    An Ibis table expression or pandas table that will be used to\n    extract the schema and the data of the new table. If not provided,\n    `schema` must be given.\nschema\n    The schema for the new table. Only one of `schema` or `obj` can be\n    provided.\ndatabase\n    Name of the database where the table will be created, if not the\n    default.\n\n    To specify a location in a separate catalog, you can pass in the\n    catalog and database as a string `\"catalog.database\"`, or as a tuple of\n    strings `(\"catalog\", \"database\")`.\ntemp\n    Whether a table is temporary or not.\n    All created temp tables are \"Global Temporary Tables\". They will be\n    created in \"tempdb.dbo\" and will be prefixed with \"##\".\noverwrite\n    Whether to clobber existing data.\n    `overwrite` and `temp` cannot be used together with MSSQL.\n\nReturns\n-------\nTable\n    The table that was created.", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::create_table", "docstring": "Create a table in Amazon Athena.\n\nParameters\n----------\nname\n    Name of the table to create\nobj\n    The data with which to populate the table; optional, but one of `obj`\n    or `schema` must be specified\nschema\n    The schema of the table to create; optional, but one of `obj` or\n    `schema` must be specified\ndatabase\n    The database to insert the table into.\n    If not provided, the current database is used.\n    You can provide a single database name, like `\"mydb\"`. For\n    multi-level hierarchies, you can pass in a dotted string path like\n    `\"catalog.database\"` or a tuple of strings like `(\"catalog\",\n    \"database\")`.\ntemp\n    This parameter is not yet supported in the Amazon Athena backend, because\n    Amazon Athena doesn't implement temporary tables\noverwrite\n    If `True`, replace the table if it already exists, otherwise fail if\n    the table exists\ncomment\n    Add a comment to the table\nproperties\n    Table properties to set on creation\nlocation\n    s3 location to store table data. Defaults to the `s3_staging_dir`\n    bucket with the table name as the bucket key.\nstored_as\n    The file format in which to store table data. Defaults to parquet.\npartitioned_by\n    Iterable of column name and type pairs/mapping/schema by which to\n    partition the table.", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::get_schema", "docstring": "Compute the schema of a `table`.\n\nParameters\n----------\ntable_name\n    May **not** be fully qualified. Use `database` if you want to\n    qualify the identifier.\ncatalog\n    Catalog name\ndatabase\n    Database name\n\nReturns\n-------\nsch.Schema\n    Ibis schema", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::do_connect", "docstring": "Create an Ibis client connected to an Amazon Athena instance.", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection to an Amazon Athena instance.\n\nParameters\n----------\ncon\n    An existing connection to an Amazon Athena instance.\nmemtable_volume\n    The volume to use for Ibis memtables.", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::to_pyarrow_batches", "docstring": "Return a stream of record batches.\n\nThe returned `RecordBatchReader` contains a cursor with an unbounded lifetime.\n\nFor analytics use cases this is usually nothing to fret about. In some cases you\nmay need to explicit release the cursor.\n\nParameters\n----------\nexpr\n    Ibis expression\nparams\n    Bound parameters\nlimit\n    Limit the result to this number of rows", "type": "function"}
{"source": "ibis/backends/athena/__init__.py::rename_table", "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::CTE", "docstring": "Common table expression.", "type": "class"}
{"source": "ibis/backends/sql/rewrites.py::Select", "docstring": "Relation modelled after SQL's SELECT statement.", "type": "class"}
{"source": "ibis/backends/sql/rewrites.py::FirstValue", "docstring": "Retrieve the first element.", "type": "class"}
{"source": "ibis/backends/sql/rewrites.py::LastValue", "docstring": "Retrieve the last element.", "type": "class"}
{"source": "ibis/backends/sql/rewrites.py::project_to_select", "docstring": "Convert a Project node to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::filter_to_select", "docstring": "Convert a Filter node to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::sort_to_select", "docstring": "Convert a Sort node to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::distinct_to_select", "docstring": "Convert a Distinct node to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::drop_columns_to_select", "docstring": "Convert a DropColumns node to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::fill_null_to_select", "docstring": "Rewrite FillNull to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::drop_null_to_select", "docstring": "Rewrite DropNull to a Select node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::first_to_firstvalue", "docstring": "Convert a First or Last node to a FirstValue or LastValue node.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::remove_aliases", "docstring": "Remove all remaining aliases, they're not needed for remaining compilation.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::complexity", "docstring": "Assign a complexity score to a node.\n\nSubsequent projections can be merged into a single projection by replacing\nthe fields referenced in the outer projection with the computed expressions\nfrom the inner projection. This inlining can result in very complex value\nexpressions depending on the projections. In order to prevent excessive\ninlining, we assign a complexity score to each node.\n\nThe complexity score assigns 1 to each value expression and adds up in the\ntree hierarchy unless there is a Field node where we don't add up the\ncomplexity of the referenced relation. This way we treat fields kind of like\nreusable variables considering them less complex than they were inlined.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::merge_select_select", "docstring": "Merge subsequent Select relations into one.\n\nThis rewrites eliminates `_.parent` by merging the outer and the inner\n`predicates`, `sort_keys` and keeping the outer `selections`. All selections\nfrom the inner Select are inlined into the outer Select.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::sqlize", "docstring": "Lower the ibis expression graph to a SQL-like relational algebra.\n\nParameters\n----------\nnode\n    The root node of the expression graph.\nparams\n    A mapping of scalar parameters to their values.\nrewrites\n    Supplementary rewrites to apply before SQL-specific transforms.\npost_rewrites\n    Supplementary rewrites to apply after SQL-specific transforms.\nfuse_selects\n    Whether to merge subsequent Select nodes into one where possible.\n\nReturns\n-------\nTuple of the rewritten expression graph and a list of CTEs.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::split_select_distinct_with_order_by", "docstring": "Split a `SELECT DISTINCT ... ORDER BY` query when needed.\n\nSome databases (postgres, pyspark, ...) have issues with two types of\nordered select distinct statements:\n\n```\n--- ORDER BY with an expression instead of a name in the select list\nSELECT DISTINCT a, b FROM t ORDER BY a + 1\n\n--- ORDER BY using a qualified column name, rather than the alias in the select list\nSELECT DISTINCT a, b as x FROM t ORDER BY b  --- or t.b\n```\n\nWe solve both these cases by splitting everything except the `ORDER BY`\ninto a subquery.\n\n```\nSELECT DISTINCT a, b FROM t WHERE a > 10 ORDER BY a + 1\n--- is rewritten as ->\nSELECT * FROM (SELECT DISTINCT a, b FROM t WHERE a > 10) ORDER BY a + 1\n```", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::add_order_by_to_empty_ranking_window_functions", "docstring": "Add an ORDER BY clause to rank window functions that don't have one.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::one_to_zero_index", "docstring": "Subtract one from one-index functions.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::lower_log2", "docstring": "Rewrite `log2` as `log`.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::lower_log10", "docstring": "Rewrite `log10` as `log`.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::lower_bucket", "docstring": "Rewrite `Bucket` as `SearchedCase`.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::lower_capitalize", "docstring": "Rewrite Capitalize in terms of substring, concat, upper, and lower.", "type": "function"}
{"source": "ibis/backends/sql/rewrites.py::lower_sample", "docstring": "Create a rewrite rule for lowering Sample.\n\nIf the `Sample` operation matches the specified criteria, it will compile\nto the backend's `TABLESAMPLE` operation, otherwise it will fallback to\n`t.filter(ibis.random() <= fraction)`.\n\nParameters\n----------\nsupported_methods\n    The sampling methods supported by the backend's native TABLESAMPLE operation.\nsupports_seed\n    Whether the backend's native TABLESAMPLE supports setting a `seed`.\nphysical_tables_only\n    If true, only sampling on physical tables will compile to a `TABLESAMPLE`.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::dialect", "docstring": "Return the SQL dialect used by the backend.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::has_operation", "docstring": "Return whether the backend supports the given operation.\n\nParameters\n----------\noperation\n    Operation type, a Python class object.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::compile", "docstring": "Compile an expression to a SQL string.\n\nParameters\n----------\nexpr\n    An ibis expression to compile.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nparams\n    Mapping of scalar parameter expressions to value.\npretty\n    Pretty print the SQL query during compilation.\n\nReturns\n-------\nstr\n    Compiled expression", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::_log", "docstring": "Log `sql`.\n\nThis method can be implemented by subclasses. Logging occurs when\n`ibis.options.verbose` is `True`.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::sql", "docstring": "Create an Ibis table expression from a SQL query.\n\nParameters\n----------\nquery\n    A SQL query string\nschema\n    The schema of the query. If not provided, Ibis will try to infer\n    the schema of the query.\ndialect\n    The SQL dialect of the query. If not provided, the backend's dialect\n    is assumed. This argument can be useful when the query is written\n    in a different dialect from the backend.\n\nReturns\n-------\nir.Table\n    The table expression representing the query", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::_get_schema_using_query", "docstring": "Return an ibis Schema from a backend-specific SQL string.\n\nParameters\n----------\nquery\n    Backend-specific SQL string\n\nReturns\n-------\nSchema\n    The schema inferred from `query`", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::create_view", "docstring": "Create a view from an Ibis expression.\n\nParameters\n----------\nname\n    The name of the view to create.\nobj\n    The Ibis expression to create the view from.\ndatabase\n    The database that the view should be created in.\noverwrite\n    If `True`, replace an existing view with the same name.\n\nReturns\n-------\nir.Table\n    A table expression representing the view.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::drop_view", "docstring": "Drop a view from the backend.\n\nParameters\n----------\nname\n    The name of the view to drop.\ndatabase\n    The database that the view is located in.\nforce\n    If `True`, do not raise an error if the view does not exist.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::execute", "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nDataFrame | Series | scalar\n    The result of the expression execution.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::drop_table", "docstring": "Drop a table from the backend.\n\nParameters\n----------\nname\n    The name of the table to drop\ndatabase\n    The database that the table is located in.\nforce\n    If `True`, do not raise an error if the table does not exist.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::to_pyarrow_batches", "docstring": "Execute expression and return an iterator of PyArrow record batches.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    \"no limit\". The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nchunk_size\n    Maximum number of rows in each returned record batch.\n\nReturns\n-------\nRecordBatchReader\n    Collection of pyarrow `RecordBatch`s.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::insert", "docstring": "Insert data into a table.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of whether the backend itself\nuses the same terminology.\n:::\n\nParameters\n----------\nname\n    The name of the table to which data needs will be inserted\nobj\n    The source data or expression to insert\ndatabase\n    Name of the attached database that the table is located in.\n\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.\noverwrite\n    If `True` then replace existing contents of table", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::_build_insert_template", "docstring": "Builds an INSERT INTO table VALUES query string with placeholders.\n\nParameters\n----------\nname\n    Name of the table to insert into\nschema\n    Ibis schema of the table to insert into\ncatalog\n    Catalog name of the table to insert into\ncolumns\n    Whether to render the columns to insert into\nplaceholder\n    Placeholder string.\n\nReturns\n-------\nstr\n    The query string", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::truncate_table", "docstring": "Delete all rows from a table.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of tables is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of whether the backend itself\nuses the same terminology.\n:::\n\nParameters\n----------\nname\n    Table name\ndatabase\n    Name of the attached database that the table is located in.\n\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::from_connection", "docstring": "Create an Ibis client from an existing connection.\n\nParameters\n----------\ncon\n    An existing connection.\n**kwargs\n    Extra arguments to be applied to the newly-created backend.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::disconnect", "docstring": "Disconnect from the backend.", "type": "function"}
{"source": "ibis/backends/sql/__init__.py::_register_builtin_udf", "docstring": "No-op.", "type": "function"}
{"source": "ibis/backends/sql/datatypes.py::to_ibis", "docstring": "Convert a sqlglot type to an ibis type.", "type": "function"}
{"source": "ibis/backends/sql/datatypes.py::from_ibis", "docstring": "Convert an Ibis dtype to an sqlglot dtype.", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::_interval", "docstring": "Work around the inability to handle string literals in INTERVAL syntax.", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::_calculate_precision", "docstring": "Calculate interval precision.\n\nFlinkSQL interval data types use leading precision and fractional-\nseconds precision. Because the leading precision defaults to 2, we need to\nspecify a different precision when the value exceeds 2 digits.\n\n(see\nhttps://learn.microsoft.com/en-us/sql/odbc/reference/appendixes/interval-literals)", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::_interval_with_precision", "docstring": "Format interval with precision.", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::_explode_to_unnest", "docstring": "Convert explode into unnest.\n\nNOTE: Flink doesn't support UNNEST WITH ORDINALITY or UNNEST WITH OFFSET.", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::tablesample_percent_to_int", "docstring": "Impala's TABLESAMPLE only supports integer percentages.", "type": "function"}
{"source": "ibis/backends/sql/dialects.py::Polars", "docstring": "Subclass of Postgres dialect for Polars.\n\nThis is here to allow referring to the Postgres dialect as \"polars\"", "type": "class"}
{"source": "ibis/backends/sql/dialects.py::PySpark", "docstring": "Subclass of Spark dialect for PySpark.\n\nThis is here to allow referring to the Spark dialect as \"pyspark\"", "type": "class"}
{"source": "ibis/backends/sql/compilers/clickhouse.py::visit_Sign", "docstring": "Workaround for missing sign function in older versions of clickhouse.", "type": "function"}
{"source": "ibis/backends/sql/compilers/clickhouse.py::_cleanup_names", "docstring": "Compose `_gen_valid_name` and `_dedup_name` to clean up names in projections.\n\nClickHouse has a bug where this fails to find the final `\"o\".\"a\"` column:\n\n```sql\nSELECT\n  \"o\".\"a\"\nFROM (\n  SELECT\n    \"w\".\"a\"\n  FROM \"t\" AS \"s\"\n  INNER JOIN \"t\" AS \"w\"\n  USING (\"a\")\n) AS \"o\"\n```\n\nAdding a redundant aliasing operation (`\"w\".\"a\" AS \"a\"`) helps\nClickHouse.", "type": "function"}
{"source": "ibis/backends/sql/compilers/mssql.py::to_sqlglot", "docstring": "Compile an Ibis expression to a sqlglot object.", "type": "function"}
{"source": "ibis/backends/sql/compilers/mssql.py::visit_StringLength", "docstring": "The MSSQL LEN function doesn't count trailing spaces.\n\nAlso, DATALENGTH (the suggested alternative) counts bytes and thus its\nresult depends on the string's encoding.\n\nhttps://learn.microsoft.com/en-us/sql/t-sql/functions/len-transact-sql?view=sql-server-ver16#remarks\n\nThe solution is to add a character to the beginning and end of the\nstring that are guaranteed to have one character in length and are not\nspaces, and then subtract 2 from the result of `LEN` of that input.\n\nThanks to @arkanovicz for this glorious hack.", "type": "function"}
{"source": "ibis/backends/sql/compilers/sqlite.py::visit_ExtractWeekOfYear", "docstring": "ISO week of year.\n\nThis solution is based on https://stackoverflow.com/a/15511864 and handle\nthe edge cases when computing ISO week from non-ISO week.\n\nThe implementation gives the same results as `datetime.isocalendar()`.\n\nThe year's week that \"wins\" the day is the year with more allotted days.\n\nFor example:\n\n```\n$ cal '2011-01-01'\n    January 2011\nSu Mo Tu We Th Fr Sa\n                |1|\n2  3  4  5  6  7  8\n9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30 31\n```\n\nHere the ISO week number is `52` since the day occurs in a week with more\ndays in the week occurring in the _previous_ week's year.\n\n```\n$ cal '2012-12-31'\n    December 2012\nSu Mo Tu We Th Fr Sa\n                1\n2  3  4  5  6  7  8\n9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30 |31|\n```\n\nHere the ISO week of year is `1` since the day occurs in a week with more\ndays in the week occurring in the _next_ week's year.", "type": "function"}
{"source": "ibis/backends/sql/compilers/datafusion.py::visit_Aggregate", "docstring": "Support `GROUP BY` expressions in `SELECT` since DataFusion does not.", "type": "function"}
{"source": "ibis/backends/sql/compilers/exasol.py::_gen_valid_name", "docstring": "Exasol does not allow dots in quoted column names.", "type": "function"}
{"source": "ibis/backends/sql/compilers/duckdb.py::visit_TimestampNow", "docstring": "DuckDB current timestamp defaults to timestamp + tz.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::AggGen", "docstring": "A descriptor for compiling aggregate functions.\n\nCommon cases can be handled by setting configuration flags,\nspecial cases should override the `aggregate` method directly.\n\nParameters\n----------\nsupports_filter\n    Whether the backend supports a FILTER clause in the aggregate.\n    Defaults to False.\nsupports_order_by\n    Whether the backend supports an ORDER BY clause in (relevant)\n    aggregates. Defaults to False.", "type": "class"}
{"source": "ibis/backends/sql/compilers/base.py::_Accessor", "docstring": "An internal type to handle getattr/getitem access.", "type": "class"}
{"source": "ibis/backends/sql/compilers/base.py::aggregate", "docstring": "Compile the specified aggregate.\n\nParameters\n----------\ncompiler\n    The backend's compiler.\nname\n    The aggregate name (e.g. `\"sum\"`).\nargs\n    Any arguments to pass to the aggregate.\nwhere\n    An optional column filter to apply before performing the aggregate.\norder_by\n    Optional ordering keys to use to order the rows before performing\n    the aggregate.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::dialect", "docstring": "Backend dialect.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::type_mapper", "docstring": "The type mapper for the backend.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::_compile_builtin_udf", "docstring": "No-op.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::translate", "docstring": "Translate an ibis operation to a sqlglot expression.\n\nParameters\n----------\nop\n    An ibis operation\nparams\n    A mapping of expressions to concrete values\ncompiler\n    An instance of SQLGlotCompiler\ntranslate_rel\n    Relation node translator\ntranslate_val\n    Value node translator\n\nReturns\n-------\nsqlglot.expressions.Expression\n    A sqlglot expression", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::visit_Literal", "docstring": "Compile a literal value.\n\nThis is the default implementation for compiling literal values.\n\nMost backends should not need to override this method unless they want\nto handle NULL literals as well as every other type of non-null literal\nincluding integers, floating point numbers, decimals, strings, etc.\n\nThe logic here is:\n\n1. If the value is None and the type is nullable, return NULL\n1. If the value is None and the type is not nullable, raise an error\n1. Call `visit_NonNullLiteral` method.\n1. If the previous returns `None`, call `visit_DefaultLiteral` method\n   else return the result of the previous step.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::visit_NonNullLiteral", "docstring": "Compile a non-null literal differently than the default implementation.\n\nMost backends should implement this, but only when they need to handle\nsome non-null literal differently than the default implementation\n(`visit_DefaultLiteral`).\n\nReturn `None` from an override of this method to fall back to\n`visit_DefaultLiteral`.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::visit_DefaultLiteral", "docstring": "Compile a literal with a non-null value.\n\nThis is the default implementation for compiling non-null literals.\n\nMost backends should not need to override this method unless they want\nto handle compiling every kind of non-null literal value.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::_gen_valid_name", "docstring": "Generate a valid name for a value expression.\n\nOverride this method if the dialect has restrictions on valid\nidentifiers even when quoted.\n\nSee the BigQuery backend's implementation for an example.", "type": "function"}
{"source": "ibis/backends/sql/compilers/base.py::_cleanup_names", "docstring": "Compose `_gen_valid_name` and `_dedup_name` to clean up names in projections.", "type": "function"}
{"source": "ibis/backends/sql/compilers/mysql.py::rewrite_limit", "docstring": "Rewrite limit for MySQL to include a large upper bound.\n\nFrom the MySQL docs @ https://dev.mysql.com/doc/refman/8.0/en/select.html\n\n> To retrieve all rows from a certain offset up to the end of the result\n> set, you can use some large number for the second parameter. This statement\n> retrieves all rows from the 96th row to the last:\n>\n> SELECT * FROM tbl LIMIT 95,18446744073709551615;", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/__init__.py::_qualify_memtable", "docstring": "Add a BigQuery dataset and project to memtable references.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/__init__.py::_remove_null_ordering_from_unsupported_window", "docstring": "Remove null ordering in window frame clauses not supported by BigQuery.\n\nBigQuery has only partial support for NULL FIRST/LAST in RANGE windows so\nwe remove it from any window frame clause that doesn't support it.\n\nHere's the support matrix:\n\n\u2705 sum(x) over (order by y desc nulls last)\n\ud83d\udeab sum(x) over (order by y asc nulls last)\n\u2705 sum(x) over (order by y asc nulls first)\n\ud83d\udeab sum(x) over (order by y desc nulls first)", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/__init__.py::_force_quote_table", "docstring": "Force quote all the parts of a bigquery path.\n\nThe BigQuery identifier quoting semantics are bonkers\nhttps://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#identifiers\n\nmy-table is OK, but not mydataset.my-table\n\nmytable-287 is OK, but not mytable-287a\n\nJust quote everything.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/__init__.py::to_sqlglot", "docstring": "Compile an Ibis expression.\n\nParameters\n----------\nexpr\n    Ibis expression\nlimit\n    For expressions yielding result sets; retrieve at most this number\n    of values/rows. Overrides any limit already set on the expression.\nparams\n    Named unbound parameters\nsession_dataset_id\n    Optional dataset ID to qualify memtable references.\nsession_project\n    Optional project ID to qualify memtable references.\n\nReturns\n-------\nAny\n    The output of compilation. The type of this value depends on the\n    backend.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/core.py::SymbolTable", "docstring": "ChainMap subclass implementing scope for the translator.\n\nNotes\n-----\nJavaScript requires declarations in strict mode, so to implement this we\nshove a \"let\" at the beginning of every variable name if it doesn't already\nexist in the current scope.", "type": "class"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/core.py::indent", "docstring": "Indent `lines` by `spaces` spaces.\n\nParameters\n----------\nlines : Union[str, List[str]]\n    A string or list of strings to indent\nspaces : int\n    The number of spaces to indent `lines`\n\nReturns\n-------\nindented_lines : str", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/core.py::semicolon", "docstring": "Add a semicolon to the result of a `visit_*` call.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/core.py::local_scope", "docstring": "Assign symbols to local variables.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/core.py::visit_ListComp", "docstring": "Generate a curried lambda function.\n\n[x + y for x, y in [[1, 4], [2, 5], [3, 6]]]\n\nbecomes\n\n[[1, 4], [2, 5], [3, 6]]].map(([x, y]) => x + y)", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/find.py::NameFinder", "docstring": "Helper class to find the unique names in an AST.", "type": "class"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/find.py::find_names", "docstring": "Return the unique `ast.Name` instances in an AST.\n\nExamples\n--------\n>>> import ast\n>>> node = ast.parse(\"a + b\")\n>>> names = find_names(node)\n>>> names\n[<....Name object at 0x...>, <....Name object at 0x...>]\n>>> names[0].id\n'a'\n>>> names[1].id\n'b'", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/rewrite.py::matches", "docstring": "Check whether `value` matches `pattern`.", "type": "function"}
{"source": "ibis/backends/sql/compilers/bigquery/udf/rewrite.py::Rewriter", "docstring": "AST pattern matcher to enable rewrite rules.", "type": "class"}
{"source": "ibis/backends/mssql/tests/test_client.py::test_glorious_length_function_hack", "docstring": "Test that the length function works as expected.\n\nWhy wouldn't it, you ask?\n\nhttps://learn.microsoft.com/en-us/sql/t-sql/functions/len-transact-sql?view=sql-server-ver16#remarks", "type": "function"}
{"source": "ibis/backends/mssql/tests/test_client.py::difference", "docstring": "Soundex difference between two strings.", "type": "function"}
{"source": "ibis/backends/mssql/tests/test_client.py::count_big", "docstring": "The biggest of counts.", "type": "function"}
{"source": "ibis/backends/mssql/tests/test_client.py::count_big", "docstring": "The biggest of counts.", "type": "function"}
{"source": "ibis/backends/duckdb/tests/test_geospatial.py::test_geo_unop_geo_literals", "docstring": "GeoSpatialUnOp operation on a geospatial literal", "type": "function"}
{"source": "ibis/backends/duckdb/tests/test_geospatial.py::test_geo_binop_geo_literals", "docstring": "GeoSpatialBinOp operation on a geospatial literal", "type": "function"}
{"source": "ibis/backends/duckdb/tests/test_geospatial.py::no_roundtrip", "docstring": "Mark a test as expected to fail due to a reader/writer issue.", "type": "function"}
{"source": "ibis/backends/druid/tests/conftest.py::wait_for_ingest", "docstring": "Wait for datasources to be queryable.", "type": "function"}
{"source": "ibis/backends/druid/tests/conftest.py::run_query", "docstring": "Run a data loading query.", "type": "function"}
{"source": "ibis/backends/druid/tests/conftest.py::_load_data", "docstring": "Load test data into a druid backend instance.\n\nParameters\n----------\ndata_dir\n    Location of testdata\nscript_dir\n    Location of scripts defining schemas", "type": "function"}
{"source": "ibis/backends/mysql/tests/conftest.py::_load_data", "docstring": "Load test data into a MySql backend instance.\n\nParameters\n----------\ndata_dir\n    Location of testdata\nscript_dir\n    Location of scripts defining schemas", "type": "function"}
{"source": "ibis/backends/mysql/tests/test_client.py::soundex", "docstring": "Soundex of a string.", "type": "function"}
{"source": "ibis/backends/mysql/tests/test_client.py::json_arrayagg", "docstring": "Glom together some JSON.", "type": "function"}
{"source": "ibis/backends/risingwave/tests/conftest.py::_load_data", "docstring": "Load test data into a PostgreSQL backend instance.\n\nParameters\n----------\ndata_dir\n    Location of test data\nscript_dir\n    Location of scripts defining schemas", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_geo_spatial_unops", "docstring": "Testing for geo spatial unary operations.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_geo_spatial_binops", "docstring": "Testing for geo spatial binary operations.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_get_point", "docstring": "Testing for geo spatial get point operations.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_area", "docstring": "Testing for geo spatial area operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_srid", "docstring": "Testing for geo spatial srid operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_set_srid", "docstring": "Testing for geo spatial set_srid operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_transform", "docstring": "Testing for geo spatial transform operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_cast_geography", "docstring": "Testing for geo spatial transform operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_cast_geometry", "docstring": "Testing for geo spatial transform operation.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_geo_dataframe", "docstring": "Testing for geo dataframe output.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_geo_literals_smoke", "docstring": "Smoke tests for geo spatial literals.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_geospatial.py::test_geo_ops_smoke", "docstring": "Smoke tests for geo spatial operations.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_udf.py::test_existing_sql_udf", "docstring": "Test creating ibis UDF object based on existing UDF in the database.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_udf.py::test_udf", "docstring": "Test creating a UDF in database based on Python function and then\ncreating an ibis UDF object based on that.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_udf.py::test_array_type", "docstring": "Test that usage of Array types work Other scalar types can be\nrepresented either by the class or an instance, but Array types work\ndifferently.\n\nArray types must be an instance, because the Array class must be\ninstantiated specifying the datatype of the elements of the array.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_udf.py::test_client_udf_api", "docstring": "Test creating a UDF in database based on Python function using an ibis\nclient method.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_udf.py::test_client_udf_decorator_fails", "docstring": "Test that UDF creation fails when creating a UDF based on a Python\nfunction that has been defined with decorators.\n\nDecorators are not currently supported, because the decorators end\nup in the body of the UDF but are not defined in the body, therefore\ncausing a NameError.", "type": "function"}
{"source": "ibis/backends/postgres/tests/test_client.py::test_pgvector_type_load", "docstring": "CREATE TABLE items (id bigserial PRIMARY KEY, embedding vector(3));\nINSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');", "type": "function"}
{"source": "ibis/backends/exasol/tests/conftest.py::_load_data", "docstring": "Load test data into a backend.", "type": "function"}
{"source": "ibis/backends/sqlite/tests/conftest.py::_load_data", "docstring": "Load test data into a SQLite backend instance.", "type": "function"}
{"source": "ibis/backends/sqlite/tests/test_client.py::zeroblob", "docstring": "Return a length `n` blob of zero bytes.", "type": "function"}
{"source": "ibis/backends/sqlite/tests/test_client.py::total", "docstring": "Totally total.", "type": "function"}
{"source": "ibis/backends/snowflake/tests/conftest.py::_load_tpc", "docstring": "Create views of data in the TPC-H catalog that ships with Trino.\n\nThis method create relations that have column names prefixed with the\nfirst one (or two in the case of partsupp -> ps) character table name\nto match the DuckDB TPC-H query conventions.", "type": "function"}
{"source": "ibis/backends/snowflake/tests/conftest.py::_load_data", "docstring": "Load test data into a Snowflake backend instance.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/conftest.py::TestConf", "docstring": "Backend-specific class with information for testing.", "type": "class"}
{"source": "ibis/backends/bigquery/tests/conftest.py::_load_data", "docstring": "Load test data into a BigQuery instance.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/conftest.py::connect", "docstring": "Connect to the test project and dataset.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/unit/test_compiler.py::test_large_compile", "docstring": "Tests that compiling a large expression tree finishes within a\nreasonable amount of time.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/system/test_client.py::test_read_csv_with_custom_load_job_prefix", "docstring": "Since methods that upload data to BigQuery (like `read_csv`) don't return any data,\nthey also don't return a job where we can inspect the job ID, so it's a little\nawkward to test that the job ID prefix is set correctly. This does it indirectly\nby spying on the `query` method of the client, which is called with the job ID\nprefix when the data is uploaded, and we trust that the BQ library uses it correctly.\nElse, this test tries to be flexible to allow internal changes in the implementation\nof the `read_csv` method.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/system/test_client.py::test_insert_with_custom_load_job_prefix", "docstring": "Since methods that upload data to BigQuery (like `insert`) don't return any data,\nthey also don't return a job where we can inspect the job ID, so it's a little\nawkward to test that the job ID prefix is set correctly. This does it indirectly\nby spying on the `query` method of the client, which is called with the job ID\nprefix when the data is uploaded, and we trust that the BQ library uses it correctly.\nElse, this test tries to be flexible to allow internal changes in the implementation\nof the `insert` method.", "type": "function"}
{"source": "ibis/backends/bigquery/tests/unit/udf/test_builtin.py::from_hex", "docstring": "Community function to convert from hex string to integer.\n\nSee:\nhttps://github.com/GoogleCloudPlatform/bigquery-utils/tree/master/udfs/community#from_hexvalue-string", "type": "function"}
{"source": "ibis/backends/impala/tests/conftest.py::_load_data", "docstring": "Load test data into a backend.", "type": "function"}
{"source": "ibis/backends/tests/signature/typecheck.py::compatible", "docstring": "Check whether ``impl_sig`` is compatible with ``iface_sig``.\n\nParameters\n----------\nimpl_sig\n    The signature of the implementation function.\niface_sig\n    The signature of the interface function.\ncheck_annotations\n    Whether to also compare signature annotations (default) vs only parameter names.\n\nIn general, an implementation is compatible with an interface if any valid\nway of passing parameters to the interface method is also valid for the\nimplementation.\n\nConsequently, the following differences are allowed between the signature\nof an implementation method and the signature of its interface definition:\n\n1. An implementation may add new arguments to an interface iff:\n   a. All new arguments have default values.\n   b. All new arguments accepted positionally (i.e. all non-keyword-only\n      arguments) occur after any arguments declared by the interface.\n   c. Keyword-only arguments may be reordered by the implementation.\n\n2. For type-annotated interfaces, type annotations my differ as follows:\n   a. Arguments to implementations of an interface may be annotated with\n      a **superclass** of the type specified by the interface.\n   b. The return type of an implementation may be annotated with a\n      **subclass** of the type specified by the interface.", "type": "function"}
{"source": "ibis/backends/tests/signature/typecheck.py::has_default", "docstring": "Does ``arg`` provide a default?.", "type": "function"}
{"source": "ibis/backends/tests/signature/typecheck.py::annotations_compatible", "docstring": "Check whether the type annotations of an implementation are compatible with\nthe annotations of the interface it implements.", "type": "function"}
{"source": "ibis/backends/tests/tpc/conftest.py::pytest_pyfunc_call", "docstring": "Inject `backend` and fixtures to all TPC-DS test functions.\n\nDefining this hook here limits its scope to the TPC-DS tests.", "type": "function"}
{"source": "ibis/backends/tests/tpc/conftest.py::tpc_test", "docstring": "Decorator for TPC tests.\n\nParameters\n----------\nsuite_name\n    The name of the TPC suite. Only `'h'` and ~'ds'~ are supported right now.\nresult_is_empty\n    If the expected result is an empty table.\n\nAutomates the process of loading the SQL query from the file system and\nasserting that the result of the ibis expression is equal to the expected\nresult of executing the raw SQL.", "type": "function"}
{"source": "ibis/backends/tests/sql/test_sql.py::test_full_outer_join", "docstring": "Testing full outer join separately due to previous issue with outer join\nresulting in left outer join (issue #1773)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_01", "docstring": "Pricing Summary Report Query (Q1).\n\nThe Pricing Summary Report Query provides a summary pricing report for all\nlineitems shipped as of a given date.  The  date is  within  60  - 120 days\nof  the  greatest  ship  date  contained  in  the database.  The query\nlists totals  for extended  price,  discounted  extended price, discounted\nextended price  plus  tax,  average  quantity, average extended price,  and\naverage discount.  These  aggregates  are grouped  by RETURNFLAG  and\nLINESTATUS, and  listed  in ascending  order of RETURNFLAG and  LINESTATUS.\nA  count  of the  number  of  lineitems in each  group  is included.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_02", "docstring": "Minimum Cost Supplier Query (Q2)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_03", "docstring": "Shipping Priority Query (Q3)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_04", "docstring": "Order Priority Checking Query (Q4)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_05", "docstring": "Local Supplier Volume Query (Q5)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_06", "docstring": "Forecasting Revenue Change Query (Q6)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_07", "docstring": "Volume Shipping Query (Q7)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_08", "docstring": "National Market Share Query (Q8)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_09", "docstring": "Product Type Profit Measure Query (Q9)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_10", "docstring": "Returned Item Reporting Query (Q10)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_12", "docstring": "'Shipping Modes and Order Priority Query (Q12)\n\nThis query determines whether selecting less expensive modes of shipping is\nnegatively affecting the critical-prior- ity orders by causing more parts\nto be received by customers after the committed date.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_13", "docstring": "Customer Distribution Query (Q13)\n\nThis query seeks relationships between customers and the size of their\norders.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_14", "docstring": "Promotion Effect Query (Q14)\n\nThis query monitors the market response to a promotion such as TV\nadvertisements or a special campaign.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_15", "docstring": "Top Supplier Query (Q15)", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_16", "docstring": "Parts/Supplier Relationship Query (Q16)\n\nThis query finds out how many suppliers can supply parts with given\nattributes. It might be used, for example, to determine whether there is\na sufficient number of suppliers for heavily ordered parts.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_17", "docstring": "Small-Quantity-Order Revenue Query (Q17)\n\nThis query determines how much average yearly revenue would be lost if\norders were no longer filled for small quantities of certain parts. This\nmay reduce overhead expenses by concentrating sales on larger shipments.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_18", "docstring": "Large Volume Customer Query (Q18)\n\nThe Large Volume Customer Query ranks customers based on their having\nplaced a large quantity order. Large quantity orders are defined as those\norders whose total quantity is above a certain level.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_19", "docstring": "Discounted Revenue Query (Q19)\n\nThe Discounted Revenue Query reports the gross discounted revenue\nattributed to the sale of selected parts handled in a particular manner.\nThis query is an example of code such as might be produced programmatically\nby a data mining tool.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_20", "docstring": "Potential Part Promotion Query (Q20)\n\nThe Potential Part Promotion Query identifies suppliers in a particular\nnation having selected parts that may be candidates for a promotional\noffer.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_21", "docstring": "Suppliers Who Kept Orders Waiting Query (Q21)\n\nThis query identifies certain suppliers who were not able to ship required\nparts in a timely manner.", "type": "function"}
{"source": "ibis/backends/tests/tpc/h/test_queries.py::test_22", "docstring": "Global Sales Opportunity Query (Q22)\n\nThe Global Sales Opportunity Query identifies geographies where there are\ncustomers who may be likely to make a purchase.", "type": "function"}
{"source": "ibis/backends/datafusion/tests/test_udf.py::to_hex", "docstring": "Convert an integer to a hex string.", "type": "function"}
{"source": "ibis/backends/datafusion/tests/test_udf.py::median", "docstring": "Median of a column.", "type": "function"}
{"source": "ibis/backends/datafusion/tests/test_udf.py::median", "docstring": "Median of a column.", "type": "function"}
{"source": "ibis/backends/databricks/tests/test_json.py::tmp_table", "docstring": "Create a temporary table in the Databricks backend.", "type": "function"}
{"source": "ibis/backends/oracle/tests/conftest.py::_load_data", "docstring": "Load test data into a Oracle backend instance.\n\nParameters\n----------\ndata_dir\n    Location of testdata\nscript_dir\n    Location of scripts defining schemas", "type": "function"}
{"source": "ibis/backends/oracle/tests/test_client.py::to_date", "docstring": "Convert a string to a date.", "type": "function"}
{"source": "ibis/backends/oracle/tests/test_client.py::months_between", "docstring": "Months between two dates.", "type": "function"}
{"source": "ibis/backends/oracle/tests/test_client.py::stats_one_way_anova", "docstring": "Convert a string to a date.", "type": "function"}
{"source": "ibis/backends/pyspark/tests/conftest.py::parquet_dir", "docstring": "Directory containing Parquet files.", "type": "function"}
{"source": "ibis/backends/pyspark/tests/conftest.py::load_data", "docstring": "Load testdata from `data_dir`.", "type": "function"}
{"source": "ibis/backends/trino/tests/conftest.py::_load_tpc", "docstring": "Create views of data in the TPC-H catalog that ships with Trino.\n\nThis method create relations that have column names prefixed with the\nfirst one (or two in the case of partsupp -> ps) character table name\nto match the DuckDB TPC-H query conventions.", "type": "function"}
{"source": "ibis/backends/trino/tests/test_client.py::bar", "docstring": "Render a single bar of length `width`, with `x` percent filled.", "type": "function"}
{"source": "ibis/backends/trino/tests/test_client.py::geometric_mean", "docstring": "Geometric mean of a series of numbers.", "type": "function"}
{"source": "ibis/backends/flink/tests/conftest.py::connect", "docstring": "Flink backend is created in batch mode by default. This is to\ncomply with the assumption that the tests under ibis/ibis/backends/tests/\nare for batch (storage or processing) backends.", "type": "function"}
{"source": "ibis/backends/flink/tests/conftest.py::connect", "docstring": "Flink backend is created in streaming mode here. To be used\nin the tests under ibis/ibis/backends/flink/tests/.\nWe only use mini cluster here for simplicity.", "type": "function"}
{"source": "ibis/backends/flink/tests/test_ddl.py::test_create_table_in_memory", "docstring": "Same as in ibis/backends/tests/test_client.py, with temp=True.", "type": "function"}
{"source": "ibis/backends/flink/tests/test_udf.py::json_arrayagg", "docstring": "Glom together some JSON.", "type": "function"}
{"source": "ibis/backends/clickhouse/tests/conftest.py::_load_data", "docstring": "Load test data into a ClickHouse backend instance.\n\nParameters\n----------\ndata_dir\n    Location of test data\nscript_dir\n    Location of scripts defining schemas", "type": "function"}
{"source": "docs/backends/_utils.py::find_member_with_docstring", "docstring": "Find the first inherited member with a docstring.", "type": "function"}
