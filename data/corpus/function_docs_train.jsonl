{"function": "convert_column", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "C"}, {"name": "dtype", "type": "DataType"}], "returns": "C", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a format-specific column to the given ibis datatype.\n\nParameters\n----------\nobj\n    The format-specific column value to convert.\ndtype\n    The Ibis datatype to convert to.\n\nReturns\n-------\nFormat specific column corresponding to the given Ibis datatype.", "source": "ibis/formats/__init__.py"}
{"function": "experimental", "signature": {"args": [{"name": "func"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Decorate a callable to add warning about API instability in docstring.", "source": "ibis/util.py"}
{"function": "FrozenDictOf", "signature": {"args": [{"name": "key_pattern"}, {"name": "value_pattern"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Match a frozendict with keys and values matching the given patterns.", "source": "ibis/common/patterns.py"}
{"function": "rank", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Compute position of first element within each equal-value group in sorted order.\n\nEquivalent to SQL's `RANK()` window function.\n\nReturns\n-------\nInt64Column\n    The min rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=ibis.rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      2 \u2502     2 \u2502\n\u2502      3 \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "get_backend", "signature": {"args": [], "returns": "BaseBackend", "has_kwargs": false, "has_varargs": false}, "docstring": "Get the current Ibis backend to use for a given expression.\n\nParameters\n----------\nexpr\n    An expression to get the backend from. If not passed, the default\n    backend is returned.\n\nReturns\n-------\nBaseBackend\n    The Ibis backend.\n\nExamples\n--------\n>>> import ibis\n\nGet the default backend.\n\n>>> ibis.get_backend()  # doctest: +ELLIPSIS\n<ibis.backends.duckdb.Backend object at 0x...>\n\nGet the backend for a specific expression.\n\n>>> polars_con = ibis.polars.connect()\n>>> t = polars_con.create_table(\"t\", ibis.memtable({\"a\": [1, 2, 3]}))\n>>> ibis.get_backend(t)  # doctest: +ELLIPSIS\n<ibis.backends.polars.Backend object at 0x...>\n\nSee Also\n--------\n[`get_backend()`](./expression-tables.qmd#ibis.expr.types.relations.Table.get_backend)", "source": "ibis/expr/api.py"}
{"function": "current_database", "signature": {"args": [{"name": "self"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "The name of the current database in the backend.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n\nReturns\n-------\nstr\n    The name of the current database.", "source": "ibis/backends/__init__.py"}
{"function": "end", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Finish the `CASE` expression.", "source": "ibis/expr/builders.py"}
{"function": "castable", "signature": {"args": [{"name": "source"}, {"name": "target"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return whether source ir type is implicitly castable to target.\n\nBased on the underlying datatypes and the value in case of Literals", "source": "ibis/expr/rules.py"}
{"function": "has_operation", "signature": {"args": [], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Return whether the backend implements support for `operation`.\n\nParameters\n----------\noperation\n    A class corresponding to an operation.\n\nReturns\n-------\nbool\n    Whether the backend implements the operation.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.expr.operations as ops\n>>> ibis.sqlite.has_operation(ops.ArrayIndex)\nFalse\n>>> ibis.postgres.has_operation(ops.ArrayIndex)\nTrue", "source": "ibis/backends/__init__.py"}
{"function": "infer_scalar", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "S"}], "returns": "DataType", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the Ibis datatype of a format-specific scalar.\n\nParameters\n----------\nobj\n    The format-specific scalar to infer the Ibis datatype of.\n\nReturns\n-------\nIbis datatype corresponding to the given format-specific scalar.", "source": "ibis/formats/__init__.py"}
{"function": "is_one_of", "signature": {"args": [{"name": "values", "type": "Sequence[T]"}, {"name": "t", "type": "type[U]"}], "returns": "Iterator[bool]", "has_kwargs": false, "has_varargs": false}, "docstring": "Check if the type of each value is the same of the given type.\n\nParameters\n----------\nvalues\n    Input values\nt\n    Type to check against\n\nReturns\n-------\ntuple", "source": "ibis/util.py"}
{"function": "drop_database", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Drop the database with `name` in `catalog`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the schema to drop.\ncatalog\n    Name of the catalog to drop the database from.\n    If `None`, the current catalog is used.\nforce\n    If `False`, an exception is raised if the database does not exist.", "source": "ibis/backends/__init__.py"}
{"function": "connect", "signature": {"args": [{"name": "self"}], "returns": "BaseBackend", "has_kwargs": true, "has_varargs": true}, "docstring": "Connect to the database.\n\nParameters\n----------\n*args\n    Mandatory connection parameters, see the docstring of `do_connect`\n    for details.\n**kwargs\n    Extra connection parameters, see the docstring of `do_connect` for\n    details.\n\nNotes\n-----\nThis creates a new backend instance with saved `args` and `kwargs`,\nthen calls `reconnect` and finally returns the newly created and\nconnected backend instance.\n\nReturns\n-------\nBaseBackend\n    An instance of the backend", "source": "ibis/backends/__init__.py"}
{"function": "desc", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a descending sort key from `expr` or column name.\n\nParameters\n----------\nexpr\n    The expression or column name to use for sorting\nnulls_first\n    Bool to indicate whether to put NULL values first or not.\n\nSee Also\n--------\n[`Value.desc()`](./expression-generic.qmd#ibis.expr.types.generic.Value.desc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(ibis.desc(\"year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2502 Adelie  \u2502  2009 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nir.ValueExpr\n    An expression", "source": "ibis/expr/api.py"}
{"function": "random", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return a random floating point number in the range [0.0, 1.0).\n\nSimilar to [](`random.random`) in the Python standard library.\n\n::: {.callout-note}\n## Repeated use of `random`\n\n`ibis.random()` will generate a column of distinct random numbers even if\nthe same instance of `ibis.random()` is reused.\n\nWhen Ibis compiles an expression to SQL, each place where `random` is used\nwill render as a separate call to the given backend's random number\ngenerator.\n\n```python\n>>> from ibis.interactive import *\n>>> t = ibis.memtable({\"a\": range(5)})\n>>> r_a = ibis.random()\n>>> t.mutate(random_1=r_a, random_2=r_a)  # doctest: +SKIP\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 random_1 \u2503 random_2 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 float64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502 0.191130 \u2502 0.098715 \u2502\n\u2502     1 \u2502 0.255262 \u2502 0.828454 \u2502\n\u2502     2 \u2502 0.011804 \u2502 0.392275 \u2502\n\u2502     3 \u2502 0.309941 \u2502 0.347300 \u2502\n\u2502     4 \u2502 0.482783 \u2502 0.095562 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n:::\n\nReturns\n-------\nFloatingScalar\n    Random float value expression", "source": "ibis/expr/api.py"}
{"function": "promote_tuple", "signature": {"args": [{"name": "val", "type": "Any"}], "returns": "tuple[V]", "has_kwargs": false, "has_varargs": false}, "docstring": "Ensure that the value is a tuple.\n\nParameters\n----------\nval\n    Value to promote\n\nReturns\n-------\ntuple", "source": "ibis/util.py"}
{"function": "highest_precedence_dtype", "signature": {"args": [{"name": "nodes"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return the highest precedence type from the passed expressions.\n\nAlso verifies that there are valid implicit casts between any of the types\nand the selected highest precedence type.\nThis is a thin wrapper around datatypes highest precedence check.\n\nParameters\n----------\nnodes : Iterable[ops.Value]\n  A sequence of Expressions\n\nReturns\n-------\ndtype: DataType\n  The highest precedence datatype", "source": "ibis/expr/rules.py"}
{"function": "startswith", "signature": {"args": [{"name": "prefixes", "type": "Any"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Select columns whose name starts with one of `prefixes`.\n\nParameters\n----------\nprefixes\n    Prefixes to compare column names against\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(apples=\"int\", oranges=\"float\", bananas=\"bool\"), name=\"t\")\n>>> expr = t.select(s.startswith((\"a\", \"b\")))\n>>> expr.columns\n('apples', 'bananas')\n\nSee Also\n--------\n[`endswith`](#ibis.selectors.endswith)", "source": "ibis/selectors.py"}
{"function": "from_pandas", "signature": {"args": [{"name": "cls"}, {"name": "pandas_schema"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent ibis schema.", "source": "ibis/expr/schema.py"}
{"function": "indent", "signature": {"args": [{"name": "text", "type": "str"}, {"name": "spaces", "type": "int"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply an indentation using the given spaces into the given text.\n\nParameters\n----------\ntext\n    Text to indent\nspaces\n    Number of leading spaces per line\n\nReturns\n-------\nstr\n    Indented text", "source": "ibis/util.py"}
{"function": "time", "signature": {"args": [], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return a time literal if `value` is coercible to a time.\n\nParameters\n----------\nvalue_or_hour\n    Either a string value or `datetime.time` to coerce to a time, or\n    an integral value representing the time hour component.\nminute\n    The time minute component; required if `value_or_hour` is an hour.\nsecond\n    The time second component; required if `value_or_hour` is an hour.\n\nReturns\n-------\nTimeValue\n    A time expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a time scalar from a string\n\n>>> ibis.time(\"01:02:03\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 01:02:03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a time scalar from hour, minute, and second\n\n>>> ibis.time(1, 2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 01:02:03 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a time column from hour, minute, and second\n\n>>> t = ibis.memtable({\"h\": [1, 4], \"m\": [2, 5], \"s\": [3, 6]})\n>>> ibis.time(t.h, t.m, t.s).name(\"time\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 time     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 time     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 01:02:03 \u2502\n\u2502 04:05:06 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "cumulative_window", "signature": {"args": [{"name": "group_by"}, {"name": "order_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a cumulative window for use with window functions.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "assert_pickle_roundtrip", "signature": {"args": [{"name": "obj"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Assert that an ibis object remains the same after pickling and\nunpickling.", "source": "ibis/tests/util.py"}
{"function": "rename_table", "signature": {"args": [{"name": "self"}, {"name": "old_name", "type": "str"}, {"name": "new_name", "type": "str"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Rename an existing table.\n\nParameters\n----------\nold_name\n    The old name of the table.\nnew_name\n    The new name of the table.", "source": "ibis/backends/__init__.py"}
{"function": "dispatch", "signature": {"args": [{"name": "self"}, {"name": "typ"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return the implementation for the given `cls`.", "source": "ibis/common/dispatch.py"}
{"function": "_flatten_collections", "signature": {"args": [{"name": "node", "type": "Any"}], "returns": "Iterator[N]", "has_kwargs": false, "has_varargs": false}, "docstring": "Flatten collections of nodes into a single iterator.\n\nWe treat common collection types inherently traversable (e.g. list, tuple, dict)\nbut as undesired in a graph representation, so we traverse them implicitly.\n\nParameters\n----------\nnode\n    Flattaneble object.\n\nReturns\n-------\nA flat generator of the filtered nodes.\n\nExamples\n--------\n>>> from ibis.common.grounds import Concrete\n>>> from ibis.common.graph import Node\n>>>\n>>> class MyNode(Concrete, Node):\n...     number: int\n...     string: str\n...     children: tuple[Node, ...]\n>>> a = MyNode(4, \"a\", ())\n>>>\n>>> b = MyNode(3, \"b\", ())\n>>> c = MyNode(2, \"c\", (a, b))\n>>> d = MyNode(1, \"d\", (c,))\n>>>\n>>> assert list(_flatten_collections((c,))) == [c]\n>>> assert list(_flatten_collections([a, b, (c, a)])) == [a, b, c, a]\n>>> assert list(_flatten_collections([{\"b\": b, \"a\": a}])) == [b, a]", "source": "ibis/common/graph.py"}
{"function": "reconnect", "signature": {"args": [{"name": "self"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Reconnect to the database already configured with connect.", "source": "ibis/backends/__init__.py"}
{"function": "union", "signature": {"args": [{"name": "self"}, {"name": "node1", "type": "Node"}, {"name": "node2", "type": "Node"}], "returns": "ENode", "has_kwargs": false, "has_varargs": false}, "docstring": "Union two nodes in the egraph.\n\nThe nodes are converted to enodes which must be present in the egraph.\nThe eclasses of the nodes are merged and the canonical enode is returned.\n\nParameters\n----------\nnode1 :\n    The first node to union.\nnode2 :\n    The second node to union.\n\nReturns\n-------\nenode :\n    The canonical enode.", "source": "ibis/common/egraph.py"}
{"function": "substitute", "signature": {"args": [{"name": "self"}, {"name": "egraph"}, {"name": "enode"}, {"name": "subst"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Substitute the variable with the corresponding value in the substitution.\n\nParameters\n----------\negraph : EGraph\n    The egraph instance.\nenode : ENode\n    The matched enode.\nsubst : dict\n    The substitution dictionary.\n\nReturns\n-------\nvalue : Any\n    The substituted value.", "source": "ibis/common/egraph.py"}
{"function": "last", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the last column of a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.last())\n>>> expr.columns\n('user_id',)", "source": "ibis/selectors.py"}
{"function": "to_polars", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent polars schema.", "source": "ibis/expr/schema.py"}
{"function": "expand_names", "signature": {"args": [{"name": "self"}, {"name": "table", "type": "Any"}], "returns": "frozenset[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "Compute the set of column names that match the selector.", "source": "ibis/common/selectors.py"}
{"function": "where", "signature": {"args": [{"name": "predicate", "type": "Callable[Any, bool]"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Select columns that satisfy `predicate`.\n\nUse this selector when one of the other selectors does not meet your needs.\n\nParameters\n----------\npredicate\n    A callable that accepts an ibis value expression and returns a `bool`\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(a=\"float32\"), name=\"t\")\n>>> expr = t.select(s.where(lambda col: col.get_name() == \"a\"))\n>>> expr.columns\n('a',)", "source": "ibis/selectors.py"}
{"function": "else_", "signature": {"args": [{"name": "self"}, {"name": "result_expr", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a default value for the `CASE` expression.\n\nParameters\n----------\nresult_expr\n    Value to use when all case predicates evaluate to false.", "source": "ibis/expr/builders.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "typ", "type": "Any"}, {"name": "nullable"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a pyarrow type to an ibis type.", "source": "ibis/formats/pyarrow.py"}
{"function": "read_csv", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Register a CSV file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source. A string or Path to the CSV file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "source": "ibis/backends/__init__.py"}
{"function": "uuid", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return or generate a UUID value.\n\nParameters\n----------\nvalue\n    A `uuid.UUID` object or a UUID str such as\n    'b41c7dfd-1513-4358-917e-9ea322b0d3c5'.\n    If `None`, a random UUIDv4 is generated, similar to\n    [`uuid.uuid4()`](https://docs.python.org/3/library/uuid.html#uuid.uuid4)\n    from the Python standard library.\n\nExamples\n--------\n>>> from ibis.interactive import *\n>>> ibis.uuid()  # doctest: +SKIP\nUUID('e57e927b-aed2-483b-9140-dc32a26cad95')\n>>> ibis.uuid(\"b41c7dfd-1513-4358-917e-9ea322b0d3c5\")  # doctest: +SKIP\nUUID('b41c7dfd-1513-4358-917e-9ea322b0d3c5')\n\nReturns\n-------\nUUIDScalar\n    Random UUID value expression", "source": "ibis/expr/api.py"}
{"function": "read_parquet", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Register a parquet file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "source": "ibis/backends/__init__.py"}
{"function": "cases", "signature": {"args": [{"name": "branch", "type": "tuple[Any, Any]"}], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Create a multi-branch if-else expression.\n\nEquivalent to a SQL `CASE` statement.\n\n::: {.callout-note title=\"Added in version 10.0.0\"}\n:::\n\nParameters\n----------\nbranch\n    First (`condition`, `result`) pair. Required.\nbranches\n    Additional (`condition`, `result`) pairs. We look through the test\n    values in order and return the result corresponding to the first\n    test value that matches `self`. If none match, we return `else_`.\nelse_\n    Value to return if none of the case conditions evaluate to `True`.\n    Defaults to `NULL`.\n\nReturns\n-------\nValue\n    A value expression\n\nSee Also\n--------\n[`Value.cases()`](./expression-generic.qmd#ibis.expr.types.generic.Value.cases)\n[`Value.substitute()`](./expression-generic.qmd#ibis.expr.types.generic.Value.substitute)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> v = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2, 4]}).values\n>>> ibis.cases((v == 1, \"a\"), (v > 2, \"b\"), else_=\"unk\").name(\"cases\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cases  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502\n\u2502 unk    \u2502\n\u2502 a      \u2502\n\u2502 unk    \u2502\n\u2502 b      \u2502\n\u2502 unk    \u2502\n\u2502 b      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.cases(\n...     (v % 2 == 0, \"divisible by 2\"),\n...     (v % 3 == 0, \"divisible by 3\"),\n...     (v % 4 == 0, \"shadowed by the 2 case\"),\n... ).name(\"cases\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cases          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 NULL           \u2502\n\u2502 divisible by 2 \u2502\n\u2502 NULL           \u2502\n\u2502 divisible by 2 \u2502\n\u2502 divisible by 3 \u2502\n\u2502 divisible by 2 \u2502\n\u2502 divisible by 2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "none", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return no columns.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"id\": [1, 2, 3, 4, 5, 6],\n...         \"color\": [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Blue\"],\n...     }\n... )\n\n`s.none()` results in an empty expansion.\n\n>>> s.none().expand(t)\n[]\n\nThis can be useful when you want to pivot a table without identifying unique\nobservations.\n\n>>> t.pivot_wider(\n...     id_cols=s.none(),\n...     names_from=\"color\",\n...     values_from=\"color\",\n...     values_agg=\"count\",\n...     names_sort=True,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Blue  \u2503 Green \u2503 Red   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     3 \u2502     1 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/selectors.py"}
{"function": "drop_catalog", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Drop a catalog with name `name`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Catalog to drop.\nforce\n    If `False`, an exception is raised if the catalog does not exist.", "source": "ibis/backends/__init__.py"}
{"function": "deprecated", "signature": {"args": [], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Decorate to warn of deprecated usage and what to do instead.", "source": "ibis/util.py"}
{"function": "connected", "signature": {"args": [{"name": "self"}, {"name": "id1"}, {"name": "id2"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Check if the given ids are in the same class.\n\nTrue if both ids have the same canonicalized id, False otherwise.\n\nParameters\n----------\nid1 :\n    The first id to check.\nid2 :\n    The second id to check.\n\nReturns\n-------\nconnected:\n    True if the ids are connected, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "__recreate__", "signature": {"args": [{"name": "cls"}, {"name": "kwargs", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Reconstruct the node from the given arguments.", "source": "ibis/common/graph.py"}
{"function": "ddl_con", "signature": {"args": [{"name": "ddl_backend"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Instance of Client, already connected to the db (if applies).", "source": "ibis/backends/conftest.py"}
{"function": "to_csv", "signature": {"args": [{"name": "path", "type": "Any"}], "returns": "None", "has_kwargs": true, "has_varargs": false}, "docstring": "Write the results of executing the given expression to a CSV file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to CSV.\npath\n    The data source. A string or Path to the CSV file.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments passed to pyarrow.csv.CSVWriter\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.csv.CSVWriter.html", "source": "ibis/backends/__init__.py"}
{"function": "infer_column", "signature": {"args": [{"name": "cls"}, {"name": "column", "type": "Sequence"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the ibis type of a sequence.", "source": "ibis/formats/pyarrow.py"}
{"function": "drop_table", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Drop a table.\n\nParameters\n----------\nname\n    Name of the table to drop.\ndatabase\n    Name of the database where the table exists, if not the default.\nforce\n    If `False`, an exception is raised if the table does not exist.", "source": "ibis/backends/__init__.py"}
{"function": "substitute", "signature": {"args": [{"name": "self"}, {"name": "egraph"}, {"name": "enode"}, {"name": "subst"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Substitute the variables in the pattern with the corresponding values.\n\nParameters\n----------\negraph : EGraph\n    The egraph instance.\nenode : ENode\n    The matched enode.\nsubst : dict\n    The substitution dictionary.\n\nReturns\n-------\nenode : ENode\n    The substituted pattern which is a ground term aka. an ENode.", "source": "ibis/common/egraph.py"}
{"function": "register", "signature": {"args": [{"name": "self"}, {"name": "typ"}, {"name": "func"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Register a new implementation for arguments of type `cls`.", "source": "ibis/common/dispatch.py"}
{"function": "map_clear", "signature": {"args": [{"name": "self"}, {"name": "fn", "type": "Callable"}, {"name": "filter", "type": "Optional[Finder]"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply a function to all nodes in the graph more memory efficiently.\n\nAlternative implementation of `map` to reduce memory usage. While `map` keeps\nall the results in memory until the end of the traversal, this method removes\nintermediate results as soon as they are not needed anymore.\n\nPrefer this method over `map` if the results consume significant amount of\nmemory and if the intermediate results are not needed.\n\nParameters\n----------\nfn\n    Function to apply to each node. It receives the node as the first argument,\n    the results as the second and the results of the children as keyword\n    arguments.\nfilter\n    Pattern-like object to filter out nodes from the traversal. The traversal\n    will only visit nodes that match the given pattern and stop otherwise.\n\nReturns\n-------\nIn contrast to `map`, this method returns the result of the root node only since\nthe rest of the results are already discarded.", "source": "ibis/common/graph.py"}
{"function": "translate", "signature": {"args": [{"name": "op"}], "returns": null, "has_kwargs": true, "has_varargs": true}, "docstring": "Translate an ibis operation into a Python expression.", "source": "ibis/expr/decompile.py"}
{"function": "from_targets", "signature": {"args": [{"name": "cls"}, {"name": "rels"}, {"name": "extra", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a dereference map from a list of target relations.\n\nUsually a single relation is passed except for joins where multiple\nrelations are involved.\n\nParameters\n----------\nrels\n    The target relations to dereference to.\nextra\n    Extra substitutions to be added to the dereference map.\n\nReturns\n-------\nDerefMap", "source": "ibis/expr/rewrites.py"}
{"function": "NoneOf", "signature": {"args": [], "returns": "Pattern", "has_kwargs": false, "has_varargs": true}, "docstring": "Match none of the passed patterns.", "source": "ibis/common/patterns.py"}
{"function": "run", "signature": {"args": [{"name": "self"}, {"name": "rewrites", "type": "list[Rewrite]"}, {"name": "n", "type": "int"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Run the match-apply cycles for the given number of iterations.\n\nParameters\n----------\nrewrites :\n    A list of rewrites to apply.\nn :\n    The number of iterations to run.\n\nReturns\n-------\nsaturated :\n    True if the egraph is saturated, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "and_", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Combine multiple predicates using `&`.\n\nParameters\n----------\npredicates\n    Boolean value expressions\n\nReturns\n-------\nBooleanValue\n    A new predicate that evaluates to True if all composing predicates are\n    True. If no predicates were provided, returns True.", "source": "ibis/expr/api.py"}
{"function": "_finish_searched_case", "signature": {"args": [{"name": "cases"}, {"name": "results"}, {"name": "default"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Finish constructing a SearchedCase expression.\n\nThis is split out into a separate function to allow for deferred arguments\nto resolve.", "source": "ibis/expr/builders.py"}
{"function": "from_polars", "signature": {"args": [{"name": "cls"}, {"name": "polars_schema"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent ibis schema.", "source": "ibis/expr/schema.py"}
{"function": "to_pandas_batches", "signature": {"args": [], "returns": "Iterator[Any]", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute an Ibis expression and return an iterator of pandas `DataFrame`s.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nchunk_size\n    Maximum number of rows in each returned `DataFrame` batch. This may have\n    no effect depending on the backend.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nIterator[pd.DataFrame]\n    An iterator of pandas `DataFrame`s.", "source": "ibis/backends/__init__.py"}
{"function": "load_backend", "signature": {"args": [{"name": "name", "type": "str"}], "returns": "BaseBackend", "has_kwargs": false, "has_varargs": false}, "docstring": "Load backends in a lazy way with `ibis.<backend-name>`.\n\nThis also registers the backend options.\n\nExamples\n--------\n>>> import ibis\n>>> con = ibis.sqlite.connect(...)\n\nWhen accessing the `sqlite` attribute of the `ibis` module, this function\nis called, and a backend with the `sqlite` name is tried to load from\nthe `ibis.backends` entrypoints. If successful, the `ibis.sqlite`\nattribute is \"cached\", so this function is only called the first time.", "source": "ibis/__init__.py"}
{"function": "_match_args", "signature": {"args": [{"name": "self"}, {"name": "args"}, {"name": "patargs"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Match the arguments of an enode against a pattern's arguments.\n\nAn enode matches a pattern if each of the arguments are:\n- both leaf values and equal\n- both enodes and in the same eclass\n- an enode and a variable, in which case the variable gets bound to the enode\n\nParameters\n----------\nargs : tuple\n    The arguments of the enode. Since an enode is a ground term, the arguments\n    are either enodes or leaf values.\npatargs : tuple\n    The arguments of the pattern. Since a pattern is a flat term (flattened\n    using auxiliary variables), the arguments are either variables or leaf\n    values.\n\nReturns\n-------\ndict[str, Any] :\n    The mapping of variable names to enodes or leaf values.", "source": "ibis/common/egraph.py"}
{"function": "read_json", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Register a JSON file as a table in the current backend.\n\nParameters\n----------\npath\n    The data source. A string or Path to the JSON file.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the backend loading function.\n\nReturns\n-------\nir.Table\n    The just-registered table", "source": "ibis/backends/__init__.py"}
{"function": "append_admonition", "signature": {"args": [{"name": "func", "type": "Callable"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Append a `kind` admonition with `msg` to `func`'s docstring.", "source": "ibis/util.py"}
{"function": "normalize_timedelta", "signature": {"args": [{"name": "value", "type": "Any"}, {"name": "unit", "type": "IntervalUnit"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Normalize a timedelta value to the given unit.\n\nParameters\n----------\nvalue\n    The value to normalize, either a timedelta or a number.\nunit\n    The unit to normalize to.\n\nReturns\n-------\nThe normalized timedelta value.\n\nExamples\n--------\n>>> from datetime import timedelta\n>>> normalize_timedelta(1, IntervalUnit.SECOND)\n1\n>>> normalize_timedelta(1, IntervalUnit.DAY)\n1\n>>> normalize_timedelta(timedelta(days=14), IntervalUnit.WEEK)\n2\n>>> normalize_timedelta(timedelta(seconds=3), IntervalUnit.MILLISECOND)\n3000\n>>> normalize_timedelta(timedelta(seconds=3), IntervalUnit.MICROSECOND)\n3000000", "source": "ibis/common/temporal.py"}
{"function": "to_polars", "signature": {"args": [{"name": "self"}, {"name": "schema", "type": "Schema"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert this input to a Polars DataFrame.", "source": "ibis/formats/__init__.py"}
{"function": "find", "signature": {"args": [{"name": "self"}, {"name": "finder", "type": "FinderLike"}, {"name": "filter", "type": "Optional[FinderLike]"}, {"name": "context", "type": "Optional[dict]"}, {"name": "ordered", "type": "bool"}], "returns": "list[Node]", "has_kwargs": false, "has_varargs": false}, "docstring": "Find all nodes matching a given pattern or type in the graph.\n\nAllow to match nodes based on the flexible pattern matching system implemented\nin the pattern module, but also provide a fast path for matching based on the\ntype of the node.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use if `finder` or `filter` is a pattern.\nordered\n    Emit nodes in topological order if `True`.\n\nReturns\n-------\nThe list of nodes matching the given pattern. The order of the nodes is\ndetermined by a breadth-first search.", "source": "ibis/common/graph.py"}
{"function": "add", "signature": {"args": [{"name": "self"}, {"name": "node", "type": "Node"}], "returns": "ENode", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a node to the egraph.\n\nThe node is converted to an enode and added to the egraph. If the enode is\nalready present in the egraph, then the canonical enode is returned.\n\nParameters\n----------\nnode :\n    The node to add to the egraph.\n\nReturns\n-------\nenode :\n    The canonical enode.", "source": "ibis/common/egraph.py"}
{"function": "invert", "signature": {"args": [{"name": "self"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Invert the data structure.\n\nThe graph originally maps nodes to their children, this method inverts the\nmapping to map nodes to their parents.\n\nReturns\n-------\nThe inverted graph.", "source": "ibis/common/graph.py"}
{"function": "pretty", "signature": {"args": [{"name": "node", "type": "Node"}, {"name": "scope", "type": "Optional[dict[str, Node]]"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Pretty print an expression.\n\nParameters\n----------\nnode\n    The graph node to pretty print.\nscope\n    A dictionary of expression to name mappings used to intermediate\n    assignments. If not provided aliases will be generated for each\n    relation.\n\nReturns\n-------\nstr\n    A pretty printed representation of the expression.", "source": "ibis/expr/format.py"}
{"function": "is_iterable", "signature": {"args": [{"name": "o", "type": "Any"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Return whether `o` is iterable and not a :class:`str` or :class:`bytes`.\n\nParameters\n----------\no : object\n    Any python object\n\nReturns\n-------\nbool\n\nExamples\n--------\n>>> is_iterable(\"1\")\nFalse\n>>> is_iterable(b\"1\")\nFalse\n>>> is_iterable(iter(\"1\"))\nTrue\n>>> is_iterable(i for i in range(1))\nTrue\n>>> is_iterable(1)\nFalse\n>>> is_iterable([])\nTrue", "source": "ibis/util.py"}
{"function": "union", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Compute the multiset (or set) union of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use multiset union (False) or set union (True). See examples.\n\nReturns\n-------\nTable\n    A new table containing the union of all input tables.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [1, 2]})\n>>> t1\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t2 = ibis.memtable({\"a\": [2, 3]})\n>>> t2\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.union(t1, t2)  # union all by default\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.union(t1, t2, distinct=True).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can union more than two tables at once.\n\n>>> ibis.union(t1, t1, t1).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     1 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "infer_column", "signature": {"args": [{"name": "cls"}, {"name": "column", "type": "Sequence"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the ibis type of a sequence.", "source": "ibis/formats/polars.py"}
{"function": "__argnames__", "signature": {"args": [{"name": "self"}], "returns": "tuple[str, Ellipsis]", "has_kwargs": false, "has_varargs": false}, "docstring": "Sequence of argument names.", "source": "ibis/common/graph.py"}
{"function": "matches_all", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Evaluate whether the pattern is guaranteed to match everything.\n\nThis can be evaluated before the matching loop starts, so eventually can\nbe eliminated from the flattened query.", "source": "ibis/common/egraph.py"}
{"function": "dfs", "signature": {"args": [{"name": "root", "type": "Node"}], "returns": "Graph", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a depth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "flatten_predicates", "signature": {"args": [{"name": "node"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Yield the expressions corresponding to the `And` nodes of a predicate.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table([(\"a\", \"int64\"), (\"b\", \"string\")], name=\"t\")\n>>> filt = (t.a == 1) & (t.b == \"foo\")\n>>> predicates = flatten_predicates(filt.op())\n>>> len(predicates)\n2\n>>> predicates[0].to_expr().name(\"left\")\nr0 := UnboundTable: t\n  a int64\n  b string\nleft: r0.a == 1\n>>> predicates[1].to_expr().name(\"right\")\nr0 := UnboundTable: t\n  a int64\n  b string\nright: r0.b == 'foo'", "source": "ibis/expr/rewrites.py"}
{"function": "consume", "signature": {"args": [{"name": "iterator", "type": "Iterator[T]"}, {"name": "n", "type": "Any"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Advance `iterator` n-steps ahead. If `n` is `None`, consume entirely.", "source": "ibis/util.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "typ", "type": "Any"}, {"name": "nullable"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a polars type to an ibis type.", "source": "ibis/formats/polars.py"}
{"function": "watermark", "signature": {"args": [{"name": "time_col", "type": "str"}, {"name": "allowed_delay", "type": "Any"}], "returns": "Watermark", "has_kwargs": false, "has_varargs": false}, "docstring": "Return a watermark object.\n\nParameters\n----------\ntime_col\n    The timestamp column that will be used to generate watermarks in event time processing.\nallowed_delay\n    Length of time that events are allowed to be late.\n\nReturns\n-------\nWatermark\n    A watermark object.", "source": "ibis/expr/api.py"}
{"function": "_to_selector", "signature": {"args": [{"name": "obj", "type": "Any"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an object to a `Selector`.", "source": "ibis/selectors.py"}
{"function": "cols", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": true}, "docstring": "Select specific column names.\n\nParameters\n----------\nnames\n    The column names to select\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table({\"a\": \"int\", \"b\": \"int\", \"c\": \"int\"})\n>>> expr = t.select(s.cols(\"a\", \"b\"))\n>>> expr.columns\n('a', 'b')\n\nSee Also\n--------\n[`index`](#ibis.selectors.cols)", "source": "ibis/selectors.py"}
{"function": "ddl_backend", "signature": {"args": [{"name": "request"}, {"name": "data_dir"}, {"name": "tmp_path_factory"}, {"name": "worker_id"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Set up the backends that are SQL-based.", "source": "ibis/backends/conftest.py"}
{"function": "if_any", "signature": {"args": [{"name": "selector", "type": "Selector"}, {"name": "predicate", "type": "Any"}], "returns": "IfAnyAll", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the **disjunction** of `predicate` applied on all `selector` columns.\n\nParameters\n----------\nselector\n    A column selector\npredicate\n    A callable or deferred object defining a predicate to apply to each\n    column from `selector`.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import selectors as s, _\n>>> ibis.options.interactive = True\n>>> penguins = ibis.examples.penguins.fetch().mutate(idx=ibis.row_number().over())\n>>> cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n>>> expr = penguins.mutate(cols).filter(s.if_any(s.endswith(\"_mm\"), _.abs() > 2))\n>>> expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() > 2)\n...     | (_.bill_depth_mm.abs() > 2)\n...     | (_.flipper_length_mm.abs() > 2)\n... )\n>>> expr.equals(expr_by_hand)\nTrue\n>>> expr.order_by(_.idx)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 float64           \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Torgersen \u2502      -0.974787 \u2502      2.050255 \u2502         -0.705121 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502       0.380628 \u2502      2.202170 \u2502         -0.491775 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Biscoe    \u2502      -1.103002 \u2502      0.733662 \u2502         -2.056307 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502      -0.297079 \u2502      2.050255 \u2502         -0.705121 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Dream     \u2502      -2.165354 \u2502     -0.836123 \u2502         -0.918466 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       0.398944 \u2502     -2.000802 \u2502          0.717181 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.113285 \u2502     -0.431017 \u2502          2.068368 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502      -0.187181 \u2502     -2.051440 \u2502          1.001641 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       2.871660 \u2502     -0.076550 \u2502          2.068368 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.900890 \u2502     -0.734846 \u2502          2.139483 \u2502 \u2026 \u2502\n\u2502 \u2026       \u2502 \u2026         \u2502              \u2026 \u2502             \u2026 \u2502                 \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "source": "ibis/selectors.py"}
{"function": "to_numpy", "signature": {"args": [{"name": "self"}], "returns": "list[tuple[str, Any]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent numpy dtypes.", "source": "ibis/expr/schema.py"}
{"function": "to_sqlglot_column_defs", "signature": {"args": [{"name": "self"}, {"name": "dialect", "type": "Any"}], "returns": "list[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert the schema to a list of SQL column definitions.\n\nParameters\n----------\ndialect\n    The SQL dialect to use.\n\nReturns\n-------\nlist[sqlglot.expressions.ColumnDef]\n    A list of SQL column definitions.\n\nExamples\n--------\n>>> import ibis\n>>> sch = ibis.schema({\"a\": \"int\", \"b\": \"!string\"})\n>>> sch\nibis.Schema {\n  a  int64\n  b  !string\n}\n>>> columns = sch.to_sqlglot_column_defs(dialect=\"duckdb\")\n>>> columns\n[ColumnDef(\n  this=Identifier(this='a', quoted=True),\n  kind=DataType(this=Type.BIGINT)), ColumnDef(\n  this=Identifier(this='b', quoted=True),\n  kind=DataType(this=Type.VARCHAR),\n  constraints=[\n    ColumnConstraint(\n      kind=NotNullColumnConstraint())])]\n\nOne use case for this method is to embed its output into a SQLGlot\n`CREATE TABLE` expression.\n\n>>> import sqlglot as sg\n>>> import sqlglot.expressions as sge\n>>> table = sg.table(\"t\", quoted=True)\n>>> ct = sge.Create(\n...     kind=\"TABLE\",\n...     this=sge.Schema(\n...         this=table,\n...         expressions=columns,\n...     ),\n... )\n>>> ct.sql(dialect=\"duckdb\")\n'CREATE TABLE \"t\" (\"a\" BIGINT, \"b\" TEXT NOT NULL)'", "source": "ibis/expr/schema.py"}
{"function": "find_below", "signature": {"args": [{"name": "self"}, {"name": "finder", "type": "FinderLike"}, {"name": "filter", "type": "Optional[FinderLike]"}, {"name": "context", "type": "Optional[dict]"}], "returns": "list[Node]", "has_kwargs": false, "has_varargs": false}, "docstring": "Find all nodes below the current node matching a given pattern in the graph.\n\nA variant of find() that only returns nodes below the current node in the graph.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use if `finder` or `filter` is a pattern.\n\nReturns\n-------\nThe list of nodes matching the given pattern.", "source": "ibis/common/graph.py"}
{"function": "contains", "signature": {"args": [{"name": "needles", "type": "Any"}, {"name": "how", "type": "Callable[Any, bool]"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return columns whose name contains `needles`.\n\nParameters\n----------\nneedles\n    One or more strings to search for in column names\nhow\n    A boolean reduction to allow the configuration of how `needles` are summarized.\n\nExamples\n--------\nSelect columns that contain either `\"a\"` or `\"b\"`\n\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(\n...     dict(a=\"int64\", b=\"string\", c=\"float\", d=\"array<int16>\", ab=\"struct<x: int>\")\n... )\n>>> expr = t.select(s.contains((\"a\", \"b\")))\n>>> expr.columns\n('a', 'b', 'ab')\n\nSelect columns that contain all of `\"a\"` and `\"b\"`, that is, both `\"a\"` and\n`\"b\"` must be in each column's name to match.\n\n>>> expr = t.select(s.contains((\"a\", \"b\"), how=all))\n>>> expr.columns\n('ab',)\n\nSee Also\n--------\n[`matches`](#ibis.selectors.matches)", "source": "ibis/selectors.py"}
{"function": "read_delta", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Lazily load a Delta Lake table.\n\nParameters\n----------\npath\n    A filesystem path or URL.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> import pandas as pd\n>>> ibis.options.interactive = True\n>>> df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": list(\"ghi\")})\n>>> df\n   a  b\n0  1  g\n1  2  h\n2  3  i\n>>> import deltalake as dl\n>>> dl.write_deltalake(\"/tmp/data.delta\", df, mode=\"overwrite\")\n>>> t = ibis.read_delta(\"/tmp/data.delta\")\n>>> t.order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 g      \u2502\n\u2502     2 \u2502 h      \u2502\n\u2502     3 \u2502 i      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "_register_in_memory_table", "signature": {"args": [{"name": "self"}, {"name": "op", "type": "Any"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Register an in-memory table associated with `op`.", "source": "ibis/backends/__init__.py"}
{"function": "do_connect", "signature": {"args": [{"name": "self"}], "returns": "None", "has_kwargs": true, "has_varargs": true}, "docstring": "Connect to database specified by `args` and `kwargs`.", "source": "ibis/backends/__init__.py"}
{"function": "across", "signature": {"args": [{"name": "selector", "type": "Any"}, {"name": "func", "type": "Any"}, {"name": "names", "type": "Any"}], "returns": "Across", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply data transformations across multiple columns.\n\nParameters\n----------\nselector\n    An expression that selects columns on which the transformation function\n    will be applied, an iterable of `str` column names or a single `str`\n    column name.\nfunc\n    A function (or dictionary of functions) to use to transform the data.\nnames\n    A lambda function or a format string to name the columns created by the\n    transformation function.\n\nReturns\n-------\nAcross\n    An `Across` selector object\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from ibis import _, selectors as s\n>>> t = ibis.examples.penguins.fetch()\n>>> t.select(s.startswith(\"bill\")).mutate(\n...     s.across(s.numeric(), dict(centered=_ - _.mean()), names=\"{fn}_{col}\")\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 bill_length_mm \u2503 bill_depth_mm \u2503 centered_bill_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 float64        \u2502 float64       \u2502 float64                 \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502           39.1 \u2502          18.7 \u2502                -4.82193 \u2502 \u2026 \u2502\n\u2502           39.5 \u2502          17.4 \u2502                -4.42193 \u2502 \u2026 \u2502\n\u2502           40.3 \u2502          18.0 \u2502                -3.62193 \u2502 \u2026 \u2502\n\u2502           NULL \u2502          NULL \u2502                    NULL \u2502 \u2026 \u2502\n\u2502           36.7 \u2502          19.3 \u2502                -7.22193 \u2502 \u2026 \u2502\n\u2502           39.3 \u2502          20.6 \u2502                -4.62193 \u2502 \u2026 \u2502\n\u2502           38.9 \u2502          17.8 \u2502                -5.02193 \u2502 \u2026 \u2502\n\u2502           39.2 \u2502          19.6 \u2502                -4.72193 \u2502 \u2026 \u2502\n\u2502           34.1 \u2502          18.1 \u2502                -9.82193 \u2502 \u2026 \u2502\n\u2502           42.0 \u2502          20.2 \u2502                -1.92193 \u2502 \u2026 \u2502\n\u2502              \u2026 \u2502             \u2026 \u2502                       \u2026 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "source": "ibis/selectors.py"}
{"function": "__args__", "signature": {"args": [{"name": "self"}], "returns": "tuple[Any, Ellipsis]", "has_kwargs": false, "has_varargs": false}, "docstring": "Sequence of arguments to traverse.", "source": "ibis/common/graph.py"}
{"function": "dialect", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "The sqlglot dialect for this backend, where applicable.\n\nReturns None if the backend is not a SQL backend.", "source": "ibis/backends/__init__.py"}
{"function": "all_of", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": true}, "docstring": "Include columns satisfying all of `predicates`.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.all_of(s.endswith(\"id\"), s.startswith(\"m\")))\n>>> expr.columns\n('model_id',)", "source": "ibis/selectors.py"}
{"function": "extract", "signature": {"args": [{"name": "self"}, {"name": "node", "type": "Node"}], "returns": "Node", "has_kwargs": false, "has_varargs": false}, "docstring": "Extract a node from the egraph.\n\nThe node is converted to an enode which recursively gets converted to an\nenode having the lowest cost according to equivalence classes. Currently\nthe cost function is hardcoded as the depth of the enode.\n\nParameters\n----------\nnode :\n    The node to extract from the egraph.\n\nReturns\n-------\nnode :\n    The extracted node.", "source": "ibis/common/egraph.py"}
{"function": "dereference", "signature": {"args": [{"name": "self"}], "returns": "Iterator[Any]", "has_kwargs": false, "has_varargs": true}, "docstring": "Dereference values to target relations.\n\nAlso check for ambiguous field references. If a field reference is found\nwhich is marked as ambiguous, then raise an error.\n\nParameters\n----------\nvalues\n    Expression values to dereference.\n\nReturns\n-------\ntuple[ops.Value]\n    The dereferenced values.", "source": "ibis/expr/rewrites.py"}
{"function": "to_pyarrow", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute expression to a pyarrow object.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresult\n    If the passed expression is a Table, a pyarrow table is returned.\n    If the passed expression is a Column, a pyarrow array is returned.\n    If the passed expression is a Scalar, a pyarrow scalar is returned.", "source": "ibis/backends/__init__.py"}
{"function": "__and__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Selector"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Compute the logical conjunction of two `Selector`s.\n\nParameters\n----------\nother\n    Another selector", "source": "ibis/common/selectors.py"}
{"function": "_from_url", "signature": {"args": [{"name": "self"}, {"name": "url", "type": "ParseResult"}], "returns": "BaseBackend", "has_kwargs": true, "has_varargs": false}, "docstring": "Connect to the backend with empty url.\n\nParameters\n----------\nurl : str\n    The URL with which to connect to the backend. This parameter is not used\n    in this method but is kept for consistency.\nkwargs\n    Additional keyword arguments.\n\nReturns\n-------\nBaseBackend\n    A backend instance", "source": "ibis/backends/__init__.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "dtype", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an ibis type to a polars type.", "source": "ibis/formats/polars.py"}
{"function": "find", "signature": {"args": [{"name": "self"}, {"name": "id", "type": "K"}], "returns": "K", "has_kwargs": false, "has_varargs": false}, "docstring": "Find the root of the class that the given id is in.\n\nAlso called as the canonicalized id or the representative id.\n\nParameters\n----------\nid :\n    The id to find the canonicalized id for.\n\nReturns\n-------\nid:\n    The canonicalized id for the given id.", "source": "ibis/common/egraph.py"}
{"function": "infer_column", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "C"}], "returns": "DataType", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the Ibis datatype of a format-specific column.\n\nParameters\n----------\nobj\n    The format-specific column to infer the Ibis datatype of.\n\nReturns\n-------\nIbis datatype corresponding to the given format-specific column.", "source": "ibis/formats/__init__.py"}
{"function": "connect", "signature": {"args": [], "returns": "BaseBackend", "has_kwargs": true, "has_varargs": false}, "docstring": "Connect to `resource`, inferring the backend automatically.\n\nThe general pattern for `ibis.connect` is\n\n```python\ncon = ibis.connect(\"backend://connection-parameters\")\n```\n\nWith many backends that looks like\n\n```python\ncon = ibis.connect(\"backend://user:password@host:port/database\")\n```\n\nSee the connection syntax for each backend for details about URL connection\nrequirements.\n\nParameters\n----------\nresource\n    A URL or path to the resource to be connected to.\nkwargs\n    Backend specific keyword arguments\n\nExamples\n--------\nConnect to an in-memory DuckDB database:\n\n>>> import ibis\n>>> con = ibis.connect(\"duckdb://\")\n\nConnect to an on-disk SQLite database:\n\n>>> con = ibis.connect(\"sqlite://relative.db\")\n>>> con = ibis.connect(\n...     \"sqlite:///absolute/path/to/data.db\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nConnect to a PostgreSQL server:\n\n>>> con = ibis.connect(\n...     \"postgres://user:password@hostname:5432\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nConnect to BigQuery:\n\n>>> con = ibis.connect(\n...     \"bigquery://my-project/my-dataset\"\n... )  # quartodoc: +SKIP # doctest: +SKIP", "source": "ibis/backends/__init__.py"}
{"function": "_get_backends_to_test", "signature": {"args": [{"name": "keep", "type": "tuple[str, Ellipsis]"}, {"name": "discard", "type": "tuple[str, Ellipsis]"}], "returns": "list[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Get a list of `TestConf` classes of the backends to test.", "source": "ibis/backends/conftest.py"}
{"function": "__children__", "signature": {"args": [{"name": "self"}], "returns": "tuple[Node, Ellipsis]", "has_kwargs": false, "has_varargs": false}, "docstring": "Sequence of children nodes.", "source": "ibis/common/graph.py"}
{"function": "to_polars", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute expression and return results in as a polars DataFrame.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to polars.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments\n\nReturns\n-------\ndataframe\n    A polars DataFrame holding the results of the executed expression.", "source": "ibis/backends/__init__.py"}
{"function": "all", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return every column from a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.all())\n>>> expr.columns\n('model_id', 'model_name', 'user_id')", "source": "ibis/selectors.py"}
{"function": "row_number", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an analytic function expression for the current row number.\n\n::: {.callout-note}\n`row_number` is normalized across backends to start at 0\n:::\n\nReturns\n-------\nIntegerColumn\n    A column expression enumerating rows\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rownum=ibis.row_number())\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rownum \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502      0 \u2502\n\u2502      2 \u2502      1 \u2502\n\u2502      1 \u2502      2 \u2502\n\u2502      2 \u2502      3 \u2502\n\u2502      3 \u2502      4 \u2502\n\u2502      2 \u2502      5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "lower_stringslice", "signature": {"args": [{"name": "_"}], "returns": null, "has_kwargs": true, "has_varargs": false}, "docstring": "Rewrite StringSlice in terms of Substring.", "source": "ibis/expr/rewrites.py"}
{"function": "to_pandas", "signature": {"args": [{"name": "self"}], "returns": "list[tuple[str, Any]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent pandas datatypes.", "source": "ibis/expr/schema.py"}
{"function": "assert_decompile_roundtrip", "signature": {"args": [{"name": "expr", "type": "Any"}, {"name": "snapshot"}, {"name": "eq", "type": "Callable[Any, bool]"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Assert that an ibis expression remains the same after decompilation.\n\nParameters\n----------\nexpr\n    The expression to decompile.\nsnapshot\n    A snapshot fixture.\neq\n    A callable that returns whether two Ibis expressions are equal.\n    Defaults to `ibis.expr.types.Expr.equals`. Use this to adjust\n    comparison behavior for expressions that contain `SelfReference`\n    operations from table.view() calls, or other relations whose equality\n    is difficult to roundtrip.", "source": "ibis/tests/util.py"}
{"function": "read_parquet", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Lazily load a parquet file or set of parquet files.\n\nThis function delegates to the `read_parquet` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. For the DuckDB\n    backend used by default, please refer to:\n\n    * Parquet: https://duckdb.org/docs/data/parquet\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> import pandas as pd\n>>> ibis.options.interactive = True\n>>> df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": list(\"ghi\")})\n>>> df\n   a  b\n0  1  g\n1  2  h\n2  3  i\n>>> df.to_parquet(\"/tmp/data.parquet\")\n>>> t = ibis.read_parquet(\"/tmp/data.parquet\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 g      \u2502\n\u2502     2 \u2502 h      \u2502\n\u2502     3 \u2502 i      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "_filter_with_like", "signature": {"args": [{"name": "values", "type": "Iterable[str]"}, {"name": "like", "type": "Any"}], "returns": "list[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "Filter names with a `like` pattern (regex).\n\nThe methods `list_databases` and `list_tables` accept a `like`\nargument, which filters the returned tables with tables that match the\nprovided pattern.\n\nWe provide this method in the base backend, so backends can use it\ninstead of reinventing the wheel.\n\nParameters\n----------\nvalues\n    Iterable of strings to filter\nlike\n    Pattern to use for filtering names\n\nReturns\n-------\nlist[str]\n    Names filtered by the `like` pattern.", "source": "ibis/backends/__init__.py"}
{"function": "rows_window", "signature": {"args": [{"name": "preceding"}, {"name": "following"}, {"name": "group_by"}, {"name": "order_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a rows-based window clause for use with window functions.\n\nThis ROWS window clause aggregates rows based upon differences in row\nnumber.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "Schema"}], "returns": "S", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an Ibis Schema to a format-specific schema object.\n\nParameters\n----------\nschema\n    The Ibis Schema to convert.\n\nReturns\n-------\nFormat-specific schema object.", "source": "ibis/formats/__init__.py"}
{"function": "backend_sensitive", "signature": {"args": [], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Indicate that an API may be sensitive to a backend.", "source": "ibis/util.py"}
{"function": "match", "signature": {"args": [{"name": "self"}, {"name": "pattern", "type": "Pattern"}], "returns": "dict[ENode, dict[str, Any]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Match a pattern in the egraph.\n\nThe pattern is converted to a conjunctive query (list of flat patterns) and\nmatched against the relations represented by the egraph. This is called the\nrelational e-matching.\n\nParameters\n----------\npattern :\n    The pattern to match in the egraph.\n\nReturns\n-------\nmatches :\n    A dictionary mapping the matched enodes to their substitutions.", "source": "ibis/common/egraph.py"}
{"function": "_finalize_cached_table", "signature": {"args": [{"name": "self"}, {"name": "name", "type": "str"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Release a cached table given its name.\n\nThis is a no-op if the cached table is already released.\n\nParameters\n----------\nname\n    The name of the cached table.", "source": "ibis/backends/__init__.py"}
{"function": "read_json", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Lazily load newline-delimited JSON data.\n\nThis function delegates to the `read_json` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. See\n    https://duckdb.org/docs/extensions/json.html for details.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lines = '''\n... {\"a\": 1, \"b\": \"d\"}\n... {\"a\": 2, \"b\": null}\n... {\"a\": null, \"b\": \"f\"}\n... '''\n>>> with open(\"/tmp/lines.json\", mode=\"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = ibis.read_json(\"/tmp/lines.json\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 d      \u2502\n\u2502     2 \u2502 NULL   \u2502\n\u2502  NULL \u2502 f      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "match", "signature": {"args": [{"name": "pat", "type": "Pattern"}, {"name": "value", "type": "AnyType"}, {"name": "context", "type": "Optional[dict[str, AnyType]]"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Match a value against a pattern.\n\nParameters\n----------\npat\n    The pattern to match against.\nvalue\n    The value to match.\ncontext\n    Arbitrary mapping of values to be used while matching.\n\nReturns\n-------\nThe matched value if the pattern matches, otherwise :obj:`NoMatch`.\n\nExamples\n--------\n>>> assert match(Any(), 1) == 1\n>>> assert match(1, 1) == 1\n>>> assert match(1, 2) is NoMatch\n>>> assert match(1, 1, context={\"x\": 1}) == 1\n>>> assert match(1, 2, context={\"x\": 1}) is NoMatch\n>>> assert match([1, int], [1, 2]) == [1, 2]\n>>> assert match([1, int, \"a\" @ InstanceOf(str)], [1, 2, \"three\"]) == [\n...     1,\n...     2,\n...     \"three\",\n... ]", "source": "ibis/common/patterns.py"}
{"function": "_load_parquet", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Load an example Apache Parquet file.", "source": "ibis/backends/__init__.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "S"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a format-specific schema object to an Ibis Schema.\n\nParameters\n----------\nobj\n    The format-specific schema object to convert.\n\nReturns\n-------\nIbis Schema.", "source": "ibis/formats/__init__.py"}
{"function": "name_at_position", "signature": {"args": [{"name": "self"}, {"name": "i", "type": "int"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the name of a schema column at position `i`.\n\nParameters\n----------\ni\n    The position of the column\n\nReturns\n-------\nstr\n    The name of the column in the schema at position `i`.\n\nExamples\n--------\n>>> import ibis\n>>> sch = ibis.Schema({\"a\": \"int\", \"b\": \"string\"})\n>>> sch.name_at_position(0)\n'a'\n>>> sch.name_at_position(1)\n'b'", "source": "ibis/expr/schema.py"}
{"function": "pattern", "signature": {"args": [{"name": "obj", "type": "AnyType"}], "returns": "Pattern", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a pattern from various types.\n\nNot that if a Coercible type is passed as argument, the constructed pattern\nwon't attempt to coerce the value during matching. In order to allow type\ncoercions use `Pattern.from_typehint()` factory method.\n\nParameters\n----------\nobj\n    The object to create a pattern from. Can be a pattern, a type, a callable,\n    a mapping, an iterable or a value.\n\nExamples\n--------\n>>> assert pattern(Any()) == Any()\n>>> assert pattern(int) == InstanceOf(int)\n>>>\n>>> @pattern\n... def as_int(x, context):\n...     return int(x)\n>>>\n>>> assert as_int.match(1, {}) == 1\n\nReturns\n-------\nThe constructed pattern.", "source": "ibis/common/patterns.py"}
{"function": "_convert_kwargs", "signature": {"args": [{"name": "kwargs", "type": "MutableMapping"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Manipulate keyword arguments to `.connect` method.", "source": "ibis/backends/__init__.py"}
{"function": "ifelse", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a ternary conditional expression.\n\nParameters\n----------\ncondition\n    A boolean expression\ntrue_expr\n    Expression to return if `condition` evaluates to `True`\nfalse_expr\n    Expression to return if `condition` evaluates to `False` or `NULL`\n\nReturns\n-------\nValue : ir.Value\n    The value of `true_expr` if `condition` is `True` else `false_expr`\n\nSee Also\n--------\n[`BooleanValue.ifelse()`](./expression-numeric.qmd#ibis.expr.types.logical.BooleanValue.ifelse)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"condition\": [True, False, True, None]})\n>>> ibis.ifelse(t.condition, \"yes\", \"no\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 IfElse(condition, 'yes', 'no') \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2502 yes                            \u2502\n\u2502 no                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "memoize", "signature": {"args": [{"name": "func", "type": "Callable"}], "returns": "Callable", "has_kwargs": false, "has_varargs": false}, "docstring": "Memoize a function.", "source": "ibis/common/caching.py"}
{"function": "from_string", "signature": {"args": [{"name": "cls"}, {"name": "text", "type": "str"}, {"name": "nullable", "type": "bool"}], "returns": "DataType", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a backend-specific string representation into an Ibis DataType.\n\nParameters\n----------\ntext\n    The backend-specific string representation to convert.\nnullable\n    Whether the Ibis DataType should be nullable.\n\nReturns\n-------\nIbis DataType.", "source": "ibis/formats/__init__.py"}
{"function": "current_catalog", "signature": {"args": [{"name": "self"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "The name of the current catalog in the backend.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n\nReturns\n-------\nstr\n    The name of the current catalog.", "source": "ibis/backends/__init__.py"}
{"function": "from_sqlglot", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "Any"}, {"name": "dialect", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct an Ibis Schema from a SQLGlot Schema.\n\nParameters\n----------\nschema\n    A SQLGlot Schema containing column definitions.\ndialect\n    Optional dialect to use for type conversion.\n\nReturns\n-------\nSchema\n    An Ibis Schema.\n\nExamples\n--------\n>>> import ibis\n>>> import sqlglot as sg\n>>> import sqlglot.expressions as sge\n>>> columns = [\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"a\", quoted=True),\n...         kind=sge.DataType(this=sge.DataType.Type.BIGINT),\n...     ),\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"b\", quoted=True),\n...         kind=sge.DataType(this=sge.DataType.Type.VARCHAR),\n...         constraints=[sge.ColumnConstraint(kind=sge.NotNullColumnConstraint())],\n...     ),\n... ]\n>>> schema_expr = sge.Schema(expressions=columns)\n>>> sch = ibis.Schema.from_sqlglot(schema_expr)\n>>> sch\nibis.Schema {\n  a  int64\n  b  !string\n}\n\nDifferent source dialects are supported using the `dialect` keyword argument.\n\n>>> columns = [\n...     sge.ColumnDef(\n...         this=sg.to_identifier(\"a\", quoted=True),\n...         kind=sge.DataType(\n...             this=sge.DataType.Type.ARRAY,\n...             expressions=[sge.DataType(this=sge.DataType.Type.BIGINT, nested=False)],\n...             nested=True,\n...         ),\n...     )\n... ]\n>>> schema_expr = sge.Schema(expressions=columns)\n>>> snowflake_schema = ibis.Schema.from_sqlglot(schema_expr, dialect=\"snowflake\")\n>>> snowflake_schema\nibis.Schema {\n  a  array<json>\n}\n>>> bigquery_schema = ibis.Schema.from_sqlglot(schema_expr, dialect=\"bigquery\")\n>>> bigquery_schema\nibis.Schema {\n  a  array<int64>\n}", "source": "ibis/expr/schema.py"}
{"function": "from_node", "signature": {"args": [{"name": "cls"}, {"name": "node", "type": "Any"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an `ibis.common.graph.Node` to an `ENode`.", "source": "ibis/common/egraph.py"}
{"function": "_load_csv", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Load an example CSV file.", "source": "ibis/backends/__init__.py"}
{"function": "least", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Compute the smallest value among the supplied arguments.\n\nParameters\n----------\narg\n    First argument\nargs\n    Remaining arguments\n\nReturns\n-------\nValue\n    Minimum of the passed arguments\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.least(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502\n\u2514\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "TupleOf", "signature": {"args": [{"name": "pattern"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Match a variable-length tuple of items matching the given pattern.", "source": "ibis/common/patterns.py"}
{"function": "list_tables", "signature": {"args": [{"name": "self"}], "returns": "list[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "The table names that match `like` in the given `database`.\n\nFor some backends, the tables may be files in a directory,\nor other equivalent entities in a SQL database.\n\nParameters\n----------\nlike\n    A pattern in Python's regex format.\ndatabase\n    The database, or (catalog, database) from which to list tables.\n\n    For backends that support a single-level table hierarchy,\n    you can pass in a string like `\"bar\"`.\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.\n    If not provided, the current database\n    (and catalog, if applicable for this backend) is used.\n\n    See the\n    [Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\n    for more info.\n\nReturns\n-------\nlist[str]\n    The list of the table names that match the pattern `like`.\n\nExamples\n--------\nThis example uses the DuckDB backend, but the list_tables API\nworks the same for other backends.\n\n>>> import ibis\n>>> con = ibis.duckdb.connect()\n>>> foo = con.create_table(\"foo\", schema=ibis.schema(dict(a=\"int\")))\n>>> con.list_tables()\n['foo']\n>>> bar = con.create_view(\"bar\", foo)\n>>> con.list_tables()\n['bar', 'foo']\n>>> con.create_database(\"my_database\")\n>>> con.list_tables(database=\"my_database\")\n[]\n>>> con.raw_sql(\"CREATE TABLE my_database.baz (a INTEGER)\")  # doctest: +ELLIPSIS\n<duckdb.duckdb.DuckDBPyConnection object at 0x...>\n>>> con.list_tables(database=\"my_database\")\n['baz']", "source": "ibis/backends/__init__.py"}
{"function": "apply_projections", "signature": {"args": [{"name": "table"}, {"name": "step"}, {"name": "catalog"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Applies a SELECT projection, if applicable.", "source": "ibis/expr/sql.py"}
{"function": "_coerce_finder", "signature": {"args": [{"name": "obj", "type": "FinderLike"}, {"name": "context", "type": "Optional[dict]"}], "returns": "Finder", "has_kwargs": false, "has_varargs": false}, "docstring": "Coerce an object into a callable finder function.\n\nParameters\n----------\nobj\n    A callable accepting the node, a pattern or a type to match on.\ncontext\n    Optional context to use if the finder is a pattern.\n\nReturns\n-------\nA callable finder function which can be used to match nodes.", "source": "ibis/common/graph.py"}
{"function": "to_delta", "signature": {"args": [{"name": "path", "type": "Any"}], "returns": "None", "has_kwargs": true, "has_varargs": false}, "docstring": "Write the results of executing the given expression to a Delta Lake table.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to Delta Lake table.\npath\n    The data source. A string or Path to the Delta Lake table.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments passed to deltalake.writer.write_deltalake method", "source": "ibis/backends/__init__.py"}
{"function": "_recursive_lookup", "signature": {"args": [{"name": "obj", "type": "Any"}, {"name": "dct", "type": "dict"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Recursively replace objects in a nested structure with values from a dict.\n\nSince we treat common collection types inherently traversable, so we need to\ntraverse them implicitly and replace the values given a result mapping.\n\nParameters\n----------\nobj\n    Object to replace.\ndct\n    Mapping of objects to replace with their values.\n\nReturns\n-------\nObject with replaced values.\n\nExamples\n--------\n>>> from ibis.common.collections import frozendict\n>>> from ibis.common.grounds import Concrete\n>>> from ibis.common.graph import Node\n>>>\n>>> class MyNode(Concrete, Node):\n...     number: int\n...     string: str\n...     children: tuple[Node, ...]\n>>> a = MyNode(4, \"a\", ())\n>>>\n>>> b = MyNode(3, \"b\", ())\n>>> c = MyNode(2, \"c\", (a, b))\n>>> d = MyNode(1, \"d\", (c,))\n>>>\n>>> dct = {a: \"A\", b: \"B\"}\n>>> _recursive_lookup(a, dct)\n'A'\n>>> _recursive_lookup((a, b), dct)\n('A', 'B')\n>>> _recursive_lookup({1: a, 2: b}, dct)\n{1: 'A', 2: 'B'}\n>>> _recursive_lookup((a, frozendict({1: c})), dct)\n('A', {1: MyNode(number=2, ...)})", "source": "ibis/common/graph.py"}
{"function": "add", "signature": {"args": [{"name": "self"}, {"name": "id", "type": "K"}], "returns": "K", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a new id to the disjoint set.\n\nIf the id is not in the disjoint set, it will be added to the disjoint set\nalong with a new class containing only the given id.\n\nParameters\n----------\nid :\n    The id to add to the disjoint set.\n\nReturns\n-------\nid:\n    The id that was added to the disjoint set.", "source": "ibis/common/egraph.py"}
{"function": "backtrack", "signature": {"args": [{"name": "cls"}, {"name": "value"}], "returns": "Iterator[tuple[Any, int]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Backtrack the field in the relation hierarchy.\n\nThe field is traced back until no modification is made, so only follow\nops.Field nodes not arbitrary values.\n\nParameters\n----------\nvalue : ops.Value\n    The value to backtrack.\n\nYields\n------\ntuple[ops.Field, int]\n    The value node and the distance from the original value.", "source": "ibis/expr/rewrites.py"}
{"function": "convert_table", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "T"}, {"name": "schema", "type": "Schema"}], "returns": "T", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a format-specific table to the given ibis schema.\n\nParameters\n----------\nobj\n    The format-specific table-like object to convert.\nschema\n    The Ibis schema to convert to.\n\nReturns\n-------\nFormat specific table-like object corresponding to the given Ibis schema.", "source": "ibis/formats/__init__.py"}
{"function": "_to_snake_case", "signature": {"args": [{"name": "camel_case"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a camelCase string to snake_case.", "source": "ibis/expr/decompile.py"}
{"function": "is_function", "signature": {"args": [{"name": "v", "type": "Any"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Check if the given object is a function.\n\nReturns\n-------\nbool\n    Whether `v` is a function", "source": "ibis/util.py"}
{"function": "if_all", "signature": {"args": [{"name": "selector", "type": "Selector"}, {"name": "predicate", "type": "Any"}], "returns": "IfAnyAll", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the **conjunction** of `predicate` applied on all `selector` columns.\n\nParameters\n----------\nselector\n    A column selector\npredicate\n    A callable or deferred object defining a predicate to apply to each\n    column from `selector`.\n\nExamples\n--------\n>>> import ibis\n>>> from ibis import selectors as s, _\n>>> ibis.options.interactive = True\n>>> penguins = ibis.examples.penguins.fetch()\n>>> cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n>>> expr = penguins.mutate(cols).filter(s.if_all(s.endswith(\"_mm\"), _.abs() > 1))\n>>> expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() > 1)\n...     & (_.bill_depth_mm.abs() > 1)\n...     & (_.flipper_length_mm.abs() > 1)\n... )\n>>> expr.equals(expr_by_hand)\nTrue\n>>> expr\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\n\u2503 species \u2503 island    \u2503 bill_length_mm \u2503 bill_depth_mm \u2503 flipper_length_mm \u2503 \u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 string    \u2502 float64        \u2502 float64       \u2502 float64           \u2502 \u2026 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502 Dream     \u2502      -1.157951 \u2502      1.088129 \u2502         -1.416272 \u2502 \u2026 \u2502\n\u2502 Adelie  \u2502 Torgersen \u2502      -1.231217 \u2502      1.138768 \u2502         -1.202926 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.149917 \u2502     -1.443781 \u2502          1.214987 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.040019 \u2502     -1.089314 \u2502          1.072757 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.131601 \u2502     -1.089314 \u2502          1.712792 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.241499 \u2502     -1.089314 \u2502          1.570562 \u2502 \u2026 \u2502\n\u2502 Gentoo  \u2502 Biscoe    \u2502       1.351398 \u2502     -1.494420 \u2502          1.214987 \u2502 \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518", "source": "ibis/selectors.py"}
{"function": "from_tuples", "signature": {"args": [{"name": "cls"}, {"name": "values", "type": "Iterable[tuple[str, Any]]"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a `Schema` from an iterable of pairs.\n\nParameters\n----------\nvalues\n    An iterable of pairs of name and type.\n\nReturns\n-------\nSchema\n    A new schema\n\nExamples\n--------\n>>> import ibis\n>>> ibis.Schema.from_tuples([(\"a\", \"int\"), (\"b\", \"string\")])\nibis.Schema {\n  a  int64\n  b  string\n}", "source": "ibis/expr/schema.py"}
{"function": "verify", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Verify that the disjoint set is not corrupted.\n\nCheck that each id's canonicalized id's class. In general corruption\nshould not happen if the public API is used, but this is a sanity check\nto make sure that the internal data structures are not corrupted.\n\nReturns\n-------\nverified:\n    True if the disjoint set is not corrupted, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "trailing_range_window", "signature": {"args": [{"name": "preceding"}, {"name": "order_by"}, {"name": "group_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a trailing range window for use with window functions.\n\nParameters\n----------\npreceding\n    A value expression\norder_by\n    Ordering key\ngroup_by\n    Grouping key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "convert_scalar", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "S"}, {"name": "dtype", "type": "DataType"}], "returns": "S", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a format-specific scalar to the given ibis datatype.\n\nParameters\n----------\nobj\n    The format-specific scalar value to convert.\ndtype\n    The Ibis datatype to convert to.\n\nReturns\n-------\nFormat specific scalar corresponding to the given Ibis datatype.", "source": "ibis/formats/__init__.py"}
{"function": "__dir__", "signature": {"args": [], "returns": "list[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "Adds tab completion for ibis backends to the top-level module.", "source": "ibis/__init__.py"}
{"function": "con_no_data", "signature": {"args": [{"name": "backend_no_data"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return an Ibis backend instance, with no data loaded.", "source": "ibis/backends/conftest.py"}
{"function": "_register_udfs", "signature": {"args": [{"name": "self"}, {"name": "expr", "type": "Any"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Register UDFs contained in `expr` with the backend.", "source": "ibis/backends/__init__.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "dict[str, Any]"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a polars schema to a schema.", "source": "ibis/formats/polars.py"}
{"function": "__contains__", "signature": {"args": [{"name": "self"}, {"name": "id"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Check if the given id is in the disjoint set.\n\nParameters\n----------\nid :\n    The id to check.\n\nReturns\n-------\nined:\n    True if the id is in the disjoint set, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "_grab_qmd_functions", "signature": {"args": [{"name": "lines"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Quartodoc generated files have top-level function headers that look like.\n\n      # connect { #ibis.connect }\n\n     `ibis.connect(resource, **kwargs)`\n\n      Connect to `resource`, inferring the backend automatically.\n\nor similar. These don't get scraped by `quarto` (yet) because it doesn't\nknow about `quartodoc`.\n\nWe grab the functions using a regex, then grab the text between that\nfunction line and the next `#` sign and take that as the \"content\" of the\nrecord. This is a rough heuristic, but it works better than the previous\nnothing.", "source": ".github/workflows/algolia/upload-algolia-api.py"}
{"function": "replace", "signature": {"args": [{"name": "self"}, {"name": "replacer", "type": "ReplacerLike"}, {"name": "filter", "type": "Optional[FinderLike]"}, {"name": "context", "type": "Optional[dict]"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Match and replace nodes in the graph according to a given pattern.\n\nThe pattern matching system is used to match nodes in the graph and replace them\nwith the results of the pattern.\n\nParameters\n----------\nreplacer\n    A `Pattern`, `Mapping` or Callable taking the original unrewritten\n    node, and a mapping of attribute name to value of its rewritten\n    children (or None if no children were rewritten).\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nThe root node of the graph with the replaced nodes.", "source": "ibis/common/graph.py"}
{"function": "to_sql", "signature": {"args": [{"name": "expr", "type": "Any"}, {"name": "dialect", "type": "Any"}, {"name": "pretty", "type": "bool"}], "returns": "SQLString", "has_kwargs": true, "has_varargs": false}, "docstring": "Return the formatted SQL string for an expression.\n\nParameters\n----------\nexpr\n    Ibis expression.\ndialect\n    SQL dialect to use for compilation.\npretty\n    Whether to use pretty formatting.\nkwargs\n    Scalar parameters\n\nReturns\n-------\nstr\n    Formatted SQL string\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table({\"a\": \"int\", \"b\": \"int\"}, name=\"t\")\n>>> expr = t.mutate(c=t.a + t.b)\n>>> ibis.to_sql(expr)  # doctest: +SKIP\nSELECT\n  \"t0\".\"a\",\n  \"t0\".\"b\",\n  \"t0\".\"a\" + \"t0\".\"b\" AS \"c\"\nFROM \"t\" AS \"t0\"\n\nYou can also specify the SQL dialect to use for compilation:\n>>> ibis.to_sql(expr, dialect=\"mysql\")  # doctest: +SKIP\nSELECT\n  `t0`.`a`,\n  `t0`.`b`,\n  `t0`.`a` + `t0`.`b` AS `c`\nFROM `t` AS `t0`\n\nSee Also\n--------\n[`Table.compile()`](./expression-tables.qmd#ibis.expr.types.relations.Table.compile)", "source": "ibis/expr/sql.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "dtype", "type": "DataType"}], "returns": "T", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an Ibis DataType to a format-specific type object.\n\nParameters\n----------\ndtype\n    The Ibis DataType to convert.\n\nReturns\n-------\nFormat-specific type object.", "source": "ibis/formats/__init__.py"}
{"function": "dfs_while", "signature": {"args": [{"name": "root", "type": "Node"}, {"name": "filter", "type": "Finder"}], "returns": "Graph", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a depth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A callable which returns a boolean given a node. The traversal will only\n    visit nodes that match the given filter and stop otherwise.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "bfs", "signature": {"args": [{"name": "root", "type": "Node"}], "returns": "Graph", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a breadth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "db_identity", "signature": {"args": [{"name": "self"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the identity of the database.\n\nMultiple connections to the same\ndatabase will return the same value for `db_identity`.\n\nThe default implementation assumes connection parameters uniquely\nspecify the database.\n\nReturns\n-------\nHashable\n    Database identity", "source": "ibis/backends/__init__.py"}
{"function": "flatten", "signature": {"args": [{"name": "self"}, {"name": "var"}, {"name": "counter"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Recursively flatten the pattern to a join of selections.\n\n`Pattern(Add, (Pattern(Mul, ($x, 1)), $y))` is turned into a join of\nselections by introducing auxiliary variables where each selection gets\nexecuted as a dictionary lookup.\n\nIn SQL terms this is equivalent to the following query:\nSELECT m.0 AS $x, a.1 AS $y FROM Add a JOIN Mul m ON a.0 = m.id WHERE m.1 = 1\n\nParameters\n----------\nvar : Variable\n    The variable to assign to the flattened pattern.\ncounter : Iterator[int]\n    The counter to generate unique variable names for auxiliary variables\n    connecting the selections.\n\nYields\n------\n(var, pattern) : tuple[Variable, Pattern]\n    The variable and the flattened pattern where the flattened pattern\n    cannot contain any patterns just variables.", "source": "ibis/common/egraph.py"}
{"function": "__iter__", "signature": {"args": [{"name": "self"}], "returns": "Iterator[K]", "has_kwargs": false, "has_varargs": false}, "docstring": "Iterate over the ids in the disjoint set.", "source": "ibis/common/egraph.py"}
{"function": "to_pyarrow", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent pyarrow schema.", "source": "ibis/expr/schema.py"}
{"function": "range_window", "signature": {"args": [{"name": "preceding"}, {"name": "following"}, {"name": "group_by"}, {"name": "order_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a range-based window clause for use with window functions.\n\nThis RANGE window clause aggregates rows based upon differences in the\nvalue of the order-by expression.\n\nAll window frames / ranges are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "to_pyarrow_dataset", "signature": {"args": [{"name": "self"}, {"name": "schema", "type": "Schema"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the dataset object itself.\n\nUse with backends that can perform pushdowns into dataset objects.", "source": "ibis/formats/pyarrow.py"}
{"function": "infer_scalar", "signature": {"args": [{"name": "cls"}, {"name": "scalar", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the ibis type of a scalar.", "source": "ibis/formats/polars.py"}
{"function": "trailing_rows_window", "signature": {"args": [{"name": "preceding"}, {"name": "group_by"}, {"name": "order_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a trailing window for use with aggregate window functions.\n\nParameters\n----------\npreceding\n    The number of preceding rows\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "__rich_repr__", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Support for rich reprerentation of the node.", "source": "ibis/common/graph.py"}
{"function": "create_view", "signature": {"args": [{"name": "obj", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a new view from an expression.\n\nParameters\n----------\nname\n    Name of the new view.\nobj\n    An Ibis table expression that will be used to create the view.\ndatabase\n    Name of the database where the view will be created, if not\n    provided the database's default is used.\noverwrite\n    Whether to clobber an existing view with the same name\n\nReturns\n-------\nir.Table\n    The view that was created.", "source": "ibis/backends/__init__.py"}
{"function": "read_csv", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Lazily load a CSV or set of CSVs.\n\nThis function delegates to the `read_csv` method on the current default\nbackend (DuckDB or `ibis.config.default_backend`).\n\nParameters\n----------\npaths\n    A filesystem path or URL or list of same.  Supports CSV and TSV files.\ntable_name\n    A name to refer to the table.  If not provided, a name will be generated.\nkwargs\n    Backend-specific keyword arguments for the file type. For the DuckDB\n    backend used by default, please refer to:\n\n    * CSV/TSV: https://duckdb.org/docs/data/csv/overview.html#parameters.\n\nReturns\n-------\nir.Table\n    Table expression representing a file\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> lines = '''a,b\n... 1,d\n... 2,\n... ,f\n... '''\n>>> with open(\"/tmp/lines.csv\", mode=\"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = ibis.read_csv(\"/tmp/lines.csv\")\n>>> t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503 b      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 d      \u2502\n\u2502     2 \u2502 NULL   \u2502\n\u2502  NULL \u2502 f      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "_get_backend_from_parts", "signature": {"args": [{"name": "parts", "type": "tuple[str, Ellipsis]"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the backend part of a test file's path parts.\n\nExamples\n--------\n>>> _get_backend_from_parts((\"/\", \"ibis\", \"backends\", \"sqlite\", \"tests\"))\n\"sqlite\"", "source": "ibis/backends/conftest.py"}
{"function": "_from_url", "signature": {"args": [{"name": "self"}, {"name": "url", "type": "ParseResult"}], "returns": "BaseBackend", "has_kwargs": true, "has_varargs": false}, "docstring": "Connect to a backend using a URL `url`.\n\nParameters\n----------\nurl\n    URL with which to connect to a backend.\nkwargs\n    Additional keyword arguments\n\nReturns\n-------\nBaseBackend\n    A backend instance", "source": "ibis/backends/__init__.py"}
{"function": "matches_none", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Evaluate whether the pattern is guaranteed to match nothing.\n\nThis can be evaluated before the matching loop starts, so eventually can\nbe eliminated from the flattened query.", "source": "ibis/common/egraph.py"}
{"function": "adjust_backend_custom_attributes", "signature": {"args": [{"name": "backend_records"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Adjusts attributes of the Algolia records.\n\nTwo custom attribute changes:\n    One is the name of the backend, which we can possibly use for grouping\n    or filtering results.\n\n    The other is a marker of whether the record is part of the core\n    expression API, which we can use to sort results so that generic table\n    expressions appear above backend-specific ones in the case of\n    name-collisions.\n\nWe also strip out the \"text\" attribute if it's empty", "source": ".github/workflows/algolia/upload-algolia-api.py"}
{"function": "bfs_while", "signature": {"args": [{"name": "root", "type": "Node"}, {"name": "filter", "type": "Finder"}], "returns": "Graph", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a breadth-first search.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A callable which returns a boolean given a node. The traversal will only\n    visit nodes that match the given filter and stop otherwise.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "to_pyarrow_batches", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute expression and return a RecordBatchReader.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    Ibis expression to export to pyarrow\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nchunk_size\n    Maximum number of rows in each returned record batch.\nkwargs\n    Keyword arguments\n\nReturns\n-------\nresults\n    RecordBatchReader", "source": "ibis/backends/__init__.py"}
{"function": "percent_rank", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the relative rank of the values in the column.\n\nReturns\n-------\nFloatingColumn\n    The percent rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(pct_rank=ibis.percent_rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 pct_rank \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502      0.0 \u2502\n\u2502      1 \u2502      0.0 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      2 \u2502      0.4 \u2502\n\u2502      3 \u2502      1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "expand", "signature": {"args": [{"name": "self"}, {"name": "table", "type": "Any"}], "returns": "Sequence[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Expand `table` into value expressions that match the selector.\n\nParameters\n----------\ntable\n    An ibis table expression\n\nReturns\n-------\nSequence[Value]\n    A sequence of value expressions that match the selector", "source": "ibis/common/selectors.py"}
{"function": "lazy_singledispatch", "signature": {"args": [{"name": "func"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "A `singledispatch` implementation that supports lazily registering implementations.", "source": "ibis/common/dispatch.py"}
{"function": "any_of", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": true}, "docstring": "Include columns satisfying any of `predicates`.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.any_of(s.endswith(\"id\"), s.startswith(\"m\")))\n>>> expr.columns\n('model_id', 'model_name', 'user_id')", "source": "ibis/selectors.py"}
{"function": "_as_enode", "signature": {"args": [{"name": "self"}, {"name": "node", "type": "Node"}], "returns": "ENode", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a node to an enode.", "source": "ibis/common/egraph.py"}
{"function": "__len__", "signature": {"args": [{"name": "self"}], "returns": "int", "has_kwargs": false, "has_varargs": false}, "docstring": "Get the number of ids in the disjoint set.", "source": "ibis/common/egraph.py"}
{"function": "timestamp", "signature": {"args": [{"name": "timezone"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a timestamp scalar or column.\n\nParameters\n----------\nvalue_or_year\n    Either a string value or `datetime.datetime` to coerce to a timestamp,\n    or an integral value representing the timestamp year component.\nmonth\n    The timestamp month component; required if `value_or_year` is a year.\nday\n    The timestamp day component; required if `value_or_year` is a year.\nhour\n    The timestamp hour component; required if `value_or_year` is a year.\nminute\n    The timestamp minute component; required if `value_or_year` is a year.\nsecond\n    The timestamp second component; required if `value_or_year` is a year.\ntimezone\n    The timezone name, or none for a timezone-naive timestamp.\n\nReturns\n-------\nTimestampValue\n    A timestamp expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a timestamp scalar from a string\n\n>>> ibis.timestamp(\"2023-01-02T03:04:05\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 03:04:05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a timestamp scalar from components\n\n>>> ibis.timestamp(2023, 1, 2, 3, 4, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 03:04:05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a timestamp column from components\n\n>>> t = ibis.memtable({\"y\": [2001, 2002], \"m\": [1, 4], \"d\": [2, 5], \"h\": [3, 6]})\n>>> ibis.timestamp(t.y, t.m, t.d, t.h, 0, 0).name(\"timestamp\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp           \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2001-01-02 03:00:00 \u2502\n\u2502 2002-04-05 06:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "to_parquet", "signature": {"args": [{"name": "path", "type": "Any"}], "returns": "None", "has_kwargs": true, "has_varargs": false}, "docstring": "Write the results of executing the given expression to a parquet file.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\npath\n    The data source. A string or Path to the parquet file.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.parquet.ParquetWriter\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetWriter.html", "source": "ibis/backends/__init__.py"}
{"function": "find_topmost", "signature": {"args": [{"name": "self"}, {"name": "finder", "type": "FinderLike"}, {"name": "context", "type": "Optional[dict]"}], "returns": "list[Node]", "has_kwargs": false, "has_varargs": false}, "docstring": "Find all topmost nodes matching a given pattern in the graph.\n\nA more advanced version of find, this method stops the traversal at the first\nnode that matches the given pattern and does not descend into its children.\n\nParameters\n----------\nfinder\n    A type, tuple of types, a pattern or a callable to match upon.\ncontext\n    Optional context to use if `finder` is a pattern.\n\nReturns\n-------\nThe list of topmost nodes matching the given pattern.", "source": "ibis/common/graph.py"}
{"function": "equivalent", "signature": {"args": [{"name": "self"}, {"name": "node1", "type": "Node"}, {"name": "node2", "type": "Node"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Check if two nodes are equivalent.\n\nThe nodes are converted to enodes and checked for equivalence: they are\nequivalent if they are in the same equivalence class.\n\nParameters\n----------\nnode1 :\n    The first node.\nnode2 :\n    The second node.\n\nReturns\n-------\nequivalent :\n    True if the nodes are equivalent, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "from_typehint", "signature": {"args": [{"name": "cls"}, {"name": "annot", "type": "type"}, {"name": "allow_coercion", "type": "bool"}], "returns": "Pattern", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a validator from a python type annotation.\n\nParameters\n----------\nannot\n    The typehint annotation to construct the pattern from. This must be\n    an already evaluated type annotation.\nallow_coercion\n    Whether to use coercion if the typehint is a Coercible type.\n\nReturns\n-------\nA pattern that matches the given type annotation.", "source": "ibis/common/patterns.py"}
{"function": "from_bfs", "signature": {"args": [{"name": "cls"}, {"name": "root", "type": "Node"}, {"name": "filter", "type": "Optional[FinderLike]"}, {"name": "context", "type": "Optional[dict]"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a breadth-first search.\n\nThe traversal is implemented in an iterative fashion using a queue.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "version", "signature": {"args": [{"name": "self"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the version of the backend engine.\n\nFor database servers, return the server version.\n\nFor others such as SQLite and pandas return the version of the\nunderlying library or application.\n\nReturns\n-------\nstr\n    The backend version", "source": "ibis/backends/__init__.py"}
{"function": "union", "signature": {"args": [{"name": "self"}, {"name": "id1"}, {"name": "id2"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Merge the classes that the given ids are in.\n\nIf the ids are already in the same class, this will return False. Otherwise\nit will merge the classes and return True.\n\nParameters\n----------\nid1 :\n    The first id to merge the classes for.\nid2 :\n    The second id to merge the classes for.\n\nReturns\n-------\nmerged:\n    True if the classes were merged, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "intersect", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Compute the set (or multiset) intersection of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set intersect (True) or multiset intersect (False). See examples.\n\nReturns\n-------\nTable\n    A new table containing the intersection of all input tables.\n\nSee Also\n--------\n[`Table.intersect`](./expression-tables.qmd#ibis.expr.types.relations.Table.intersect)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> two_a = ibis.memtable({\"x\": [\"a\", \"a\", \"b\"]})\n>>> three_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"b\"]})\n>>> four_a = ibis.memtable({\"x\": [\"a\", \"a\", \"a\", \"a\", \"c\"]})\n\nWith `distinct=True`, the intersection will return one row for each row that appears in all input tables.\nThis is equivalent to a set intersection.\nSo even though the source tables have multiple `\"a\"` values, the result will only have one:\n\n>>> ibis.intersect(two_a, three_a).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the intersection will return all rows that appear in all input tables.\nThis is equivalent to a multiset intersection.\nSince the smallest number of appearances of `\"a\"` is 2, the result will have two `\"a\"` values:\n\n>>> ibis.intersect(two_a, three_a, distinct=False).order_by(\"x\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2502      b \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMore than two table expressions can be intersected at once.\n- Since `\"a\"` appears at minimum one time, it appears once in the result.\n- Since `\"b\"` doesn't appear in `two_a` or `three_a`, it is not included.\n- Since `\"c\"` does not appear in `one_a`, it is not included.\n\n>>> ibis.intersect(two_a, three_a, four_a)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> ibis.intersect(two_a, three_a, four_a, distinct=False)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      a \u2502\n\u2502      a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "matches", "signature": {"args": [{"name": "regex", "type": "Any"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return columns whose name matches the regular expression `regex`.\n\nParameters\n----------\nregex\n    A string or `re.Pattern` object\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(ab=\"string\", abc=\"int\", be=\"array<string>\"))\n>>> expr = t.select(s.matches(r\"ab+\"))\n>>> expr.columns\n('ab', 'abc')\n\nSee Also\n--------\n[`contains`](#ibis.selectors.contains)", "source": "ibis/selectors.py"}
{"function": "schema", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Validate and return a [`Schema`](./schemas.qmd#ibis.expr.schema.Schema) object.\n\nParameters\n----------\npairs\n    List or dictionary of name, type pairs. Mutually exclusive with `names`\n    and `types` arguments.\nnames\n    Field names. Mutually exclusive with `pairs`.\ntypes\n    Field types. Mutually exclusive with `pairs`.\n\nReturns\n-------\nSchema\n    An ibis schema\n\nExamples\n--------\n>>> from ibis import schema, Schema\n>>> sc = schema([(\"foo\", \"string\"), (\"bar\", \"int64\"), (\"baz\", \"boolean\")])\n>>> sc = schema(names=[\"foo\", \"bar\", \"baz\"], types=[\"string\", \"int64\", \"boolean\"])\n>>> sc = schema({\"nullable-str\": \"string\", \"non-nullable-str\": \"!string\"})\n>>> sc = schema(dict(foo=\"string\"))\n>>> sc = schema(Schema(dict(foo=\"string\")))  # no-op", "source": "ibis/expr/api.py"}
{"function": "equals", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Schema"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Return whether `other` is equal to `self`.\n\nThe order of fields in the schema is taken into account when computing equality.\n\nParameters\n----------\nother\n    Schema to compare `self` to.\n\nExamples\n--------\n>>> import ibis\n>>> xy = ibis.schema({\"x\": int, \"y\": str})\n>>> xy2 = ibis.schema({\"x\": int, \"y\": str})\n>>> yx = ibis.schema({\"y\": str, \"x\": int})\n>>> xy_float = ibis.schema({\"x\": float, \"y\": str})\n>>> assert xy.equals(xy2)\n>>> assert not xy.equals(yx)\n>>> assert not xy.equals(xy_float)", "source": "ibis/expr/schema.py"}
{"function": "replace_parameter", "signature": {"args": [{"name": "_"}, {"name": "params"}], "returns": null, "has_kwargs": true, "has_varargs": false}, "docstring": "Replace scalar parameters with their values.", "source": "ibis/expr/rewrites.py"}
{"function": "to_scale", "signature": {"args": [{"name": "unit", "type": "str"}], "returns": "int", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert to number of digits after decimal (eg \"ms\" -> 3).", "source": "ibis/common/temporal.py"}
{"function": "map", "signature": {"args": [{"name": "self"}, {"name": "fn", "type": "Callable"}, {"name": "filter", "type": "Optional[Finder]"}], "returns": "dict[Node, Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply a function to all nodes in the graph.\n\nThe traversal is done in a topological order, so the function receives the\nresults of its immediate children as keyword arguments.\n\nParameters\n----------\nfn\n    Function to apply to each node. It receives the node as the first argument,\n    the results as the second and the results of the children as keyword\n    arguments.\nfilter\n    Pattern-like object to filter out nodes from the traversal. The traversal\n    will only visit nodes that match the given pattern and stop otherwise.\n\nReturns\n-------\nA mapping of nodes to their results.", "source": "ibis/common/graph.py"}
{"function": "__invert__", "signature": {"args": [{"name": "self"}], "returns": "Not", "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar for matching the inverse of the pattern.", "source": "ibis/common/patterns.py"}
{"function": "list_catalogs", "signature": {"args": [{"name": "self"}], "returns": "list[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "List existing catalogs in the current connection.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nlike\n    A pattern in Python's regex format to filter returned catalog names.\n\nReturns\n-------\nlist[str]\n    The catalog names that exist in the current connection, that match\n    the `like` pattern if provided.", "source": "ibis/backends/__init__.py"}
{"function": "to_pandas", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\n::: {.callout-note}\nThis method is a wrapper around `execute`.\n:::\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "source": "ibis/backends/__init__.py"}
{"function": "infer_scalar", "signature": {"args": [{"name": "cls"}, {"name": "scalar", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the ibis type of a scalar.", "source": "ibis/formats/pyarrow.py"}
{"function": "memtable", "signature": {"args": [], "returns": "Table", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct an ibis table expression from in-memory data.\n\nParameters\n----------\ndata\n    A table-like object (`pandas.DataFrame`, `pyarrow.Table`, or\n    `polars.DataFrame`), or any data accepted by the `pandas.DataFrame`\n    constructor (e.g. a list of dicts).\n\n    Note that ibis objects (e.g. `MapValue`) may not be passed in as part\n    of `data` and will result in an error.\n\n    Do not depend on the underlying storage type (e.g., pyarrow.Table),\n    it's subject to change across non-major releases.\ncolumns\n    Optional [](`typing.Iterable`) of [](`str`) column names. If provided,\n    must match the number of columns in `data`.\nschema\n    Optional [`Schema`](./schemas.qmd#ibis.expr.schema.Schema).\n    The functions use `data` to infer a schema if not passed.\n\nReturns\n-------\nTable\n    A table expression backed by in-memory data.\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.memtable([{\"a\": 1}, {\"a\": 2}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a\n      0  1\n      1  2\n\n>>> t = ibis.memtable([{\"a\": 1, \"b\": \"foo\"}, {\"a\": 2, \"b\": \"baz\"}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n\nCreate a table literal without column names embedded in the data and pass\n`columns`\n\n>>> t = ibis.memtable([(1, \"foo\"), (2, \"baz\")], columns=[\"a\", \"b\"])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n\nCreate a table literal without column names embedded in the data. Ibis\ngenerates column names if none are provided.\n\n>>> t = ibis.memtable([(1, \"foo\"), (2, \"baz\")])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         col0 col1\n      0     1  foo\n      1     2  baz", "source": "ibis/expr/api.py"}
{"function": "cume_dist", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the cumulative distribution over a window.\n\nReturns\n-------\nFloatingColumn\n    The cumulative distribution\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(dist=ibis.cume_dist().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 dist     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502 0.333333 \u2502\n\u2502      1 \u2502 0.333333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      2 \u2502 0.833333 \u2502\n\u2502      3 \u2502 1.000000 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "copy", "signature": {"args": [{"name": "self"}], "returns": "DisjointSet", "has_kwargs": false, "has_varargs": false}, "docstring": "Make a copy of the disjoint set.\n\nReturns\n-------\ncopy:\n    A copy of the disjoint set.", "source": "ibis/common/egraph.py"}
{"function": "today", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an expression that will compute the current date.\n\nReturns\n-------\nDateScalar\n    An expression representing the current date.", "source": "ibis/expr/api.py"}
{"function": "deferrable", "signature": {"args": [{"name": "func"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Wrap a top-level expr function to support deferred arguments.\n\nWhen a deferrable function is called, the args & kwargs are traversed to\nlook for `Deferred` values (through builtin collections like\n`list`/`tuple`/`set`/`dict`). If any `Deferred` arguments are found, then\nthe result is also `Deferred`. Otherwise the function is called directly.\n\nParameters\n----------\nfunc\n    A callable to make deferrable\nrepr\n    An optional fixed string to use when repr-ing the deferred expression,\n    instead of the usual. This is useful for complex deferred expressions\n    where the arguments don't necessarily make sense to be user facing\n    in the repr.", "source": "ibis/common/deferred.py"}
{"function": "replace", "signature": {"args": [{"name": "matcher"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "More convenient syntax for replacing a value with the output of a function.", "source": "ibis/common/patterns.py"}
{"function": "difference", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Compute the set (or multiset) difference of multiple table expressions.\n\nThe input tables must have identical schemas.\n\nParameters\n----------\ntable\n    A table expression\n*rest\n    Additional table expressions\ndistinct\n    Use set difference (True) or multiset difference (False). See examples.\n\nSee Also\n--------\n[`ibis.difference`](./expression-tables.qmd#ibis.difference)\n\nReturns\n-------\nTable\n    The rows present in `self` that are not present in `tables`.\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t1 = ibis.memtable({\"a\": [7, 8, 8, 9, 9, 9]})\n>>> t2 = ibis.memtable({\"a\": [8, 9]})\n\nWith `distinct=True`, if a row ever appears in any of `*rest`,\nit will not appear in the result.\nSo here, all appearances of 8 and 9 are removed:\n\n>>> t1.difference(t2)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `distinct=False`, the algorithm is a [multiset](https://en.wikipedia.org/wiki/Multiset) difference.\nThis means, that since 8 and 9 each appear once in `t2`,\nthe result will be the input with a single instance of each removed:\n\n>>> t1.difference(t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     8 \u2502\n\u2502     9 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith multiple tables in `*rest`, we apply the operation consecutively.\nHere, we remove two eights and two nines:\n\n>>> t1.difference(t2, t2, distinct=False).order_by(\"a\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 a     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     7 \u2502\n\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "_make_memtable_finalizer", "signature": {"args": [{"name": "self"}, {"name": "name", "type": "str"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Make a finalizer for an in-memory table.", "source": "ibis/backends/__init__.py"}
{"function": "data_dir", "signature": {"args": [], "returns": "Path", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the test data directory.\n\nReturns\n-------\nPath\n    Test data directory", "source": "ibis/conftest.py"}
{"function": "__or__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Pattern"}], "returns": "AnyOf", "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar for matching either of the patterns.\n\nParameters\n----------\nother\n    The other pattern to match against.\n\nReturns\n-------\nNew pattern that matches if either of the patterns match.", "source": "ibis/common/patterns.py"}
{"function": "nodes", "signature": {"args": [{"name": "self"}], "returns": "KeysView[Node]", "has_kwargs": false, "has_varargs": false}, "docstring": "Return all unique nodes in the graph.", "source": "ibis/common/graph.py"}
{"function": "flatten_iterable", "signature": {"args": [{"name": "iterable"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Recursively flatten the iterable `iterable`.", "source": "ibis/util.py"}
{"function": "__getitem__", "signature": {"args": [{"name": "self"}, {"name": "id"}], "returns": "set[K]", "has_kwargs": false, "has_varargs": false}, "docstring": "Get the set of ids that are in the same class as the given id.\n\nParameters\n----------\nid :\n    The id to get the class for.\n\nReturns\n-------\nclass:\n    The set of ids that are in the same class as the given id, including\n    the given id.", "source": "ibis/common/egraph.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "Schema"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a schema to a pyarrow schema.", "source": "ibis/formats/pyarrow.py"}
{"function": "_make_memtable_finalizer", "signature": {"args": [{"name": "self"}, {"name": "name", "type": "str"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "No-op because temporary tables are automatically cleaned up.", "source": "ibis/backends/__init__.py"}
{"function": "to_torch", "signature": {"args": [], "returns": "dict[str, Any]", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute an expression and return results as a dictionary of torch tensors.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Parameters to substitute into the expression.\nlimit\n    An integer to effect a specific row limit. A value of `None` means no limit.\nkwargs\n    Keyword arguments passed into the backend's `to_torch` implementation.\n\nReturns\n-------\ndict[str, torch.Tensor]\n    A dictionary of torch tensors, keyed by column name.", "source": "ibis/backends/__init__.py"}
{"function": "_coerce_replacer", "signature": {"args": [{"name": "obj", "type": "ReplacerLike"}, {"name": "context", "type": "Optional[dict]"}], "returns": "Replacer", "has_kwargs": false, "has_varargs": false}, "docstring": "Coerce an object into a callable replacer function.\n\nParameters\n----------\nobj\n    A Pattern, Mapping, or Callable.\ncontext\n    Optional context to use if the replacer is a pattern.\n\nReturns\n-------\nA callable replacer function which can be used to replace nodes.", "source": "ibis/common/graph.py"}
{"function": "DictOf", "signature": {"args": [{"name": "key_pattern"}, {"name": "value_pattern"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Match a dictionary with keys and values matching the given patterns.", "source": "ibis/common/patterns.py"}
{"function": "when", "signature": {"args": [{"name": "self"}, {"name": "case_expr", "type": "Any"}, {"name": "result_expr", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a new condition and result to the `CASE` expression.\n\nParameters\n----------\ncase_expr\n    Expression to equality-compare with base expression. Must be\n    comparable with the base.\nresult_expr\n    Value when the case predicate evaluates to true.", "source": "ibis/expr/builders.py"}
{"function": "__rmatmul__", "signature": {"args": [{"name": "self"}, {"name": "name"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar to create a named pattern.", "source": "ibis/common/egraph.py"}
{"function": "_get_backend_cls", "signature": {"args": [{"name": "backend_str", "type": "str"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a backend string to the test class for the backend.", "source": "ibis/backends/conftest.py"}
{"function": "trailing_window", "signature": {"args": [{"name": "preceding"}, {"name": "group_by"}, {"name": "order_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a trailing window for use with window functions.\n\nParameters\n----------\npreceding\n    The number of preceding rows\ngroup_by\n    Grouping key\norder_by\n    Ordering key\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "__or__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Selector"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Compute the logical disjunction of two `Selector`s.\n\nParameters\n----------\nother\n    Another selector", "source": "ibis/common/selectors.py"}
{"function": "udf_backend", "signature": {"args": [{"name": "request"}, {"name": "data_dir"}, {"name": "tmp_path_factory"}, {"name": "worker_id"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Runs the UDF-supporting backends.", "source": "ibis/backends/conftest.py"}
{"function": "create_catalog", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a new catalog.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the new catalog.\nforce\n    If `False`, an exception is raised if the catalog already exists.", "source": "ibis/backends/__init__.py"}
{"function": "when", "signature": {"args": [{"name": "self"}, {"name": "case_expr", "type": "Any"}, {"name": "result_expr", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a new condition and result to the `CASE` expression.\n\nParameters\n----------\ncase_expr\n    Predicate expression to use for this case.\nresult_expr\n    Value when the case predicate evaluates to true.", "source": "ibis/expr/builders.py"}
{"function": "of_type", "signature": {"args": [{"name": "dtype", "type": "Any"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Select columns of type `dtype`.\n\nParameters\n----------\ndtype\n    `DataType` instance, `str` or `DataType` class\n\nExamples\n--------\nSelect according to a specific `DataType` instance\n\n>>> import ibis\n>>> import ibis.expr.datatypes as dt\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(name=\"string\", siblings=\"array<string>\", parents=\"array<int64>\"))\n>>> expr = t.select(s.of_type(dt.Array(dt.string)))\n>>> expr.columns\n('siblings',)\n\nStrings are also accepted\n\n>>> expr = t.select(s.of_type(\"array<string>\"))\n>>> expr.columns\n('siblings',)\n\nAbstract/unparametrized types may also be specified by their string name\n(e.g. \"integer\" for any integer type), or by passing in a `DataType` class\ninstead. The following options are equivalent.\n\n>>> expr1 = t.select(s.of_type(\"array\"))\n>>> expr2 = t.select(s.of_type(dt.Array))\n>>> expr1.equals(expr2)\nTrue\n>>> expr2.columns\n('siblings', 'parents')\n\nSee Also\n--------\n[`numeric`](#ibis.selectors.numeric)", "source": "ibis/selectors.py"}
{"function": "convert_unit", "signature": {"args": [{"name": "value"}, {"name": "unit"}, {"name": "to"}, {"name": "floor", "type": "bool"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a value between different units.\n\nConvert `value`, is assumed to be in units of `unit`, to units of `to`.\nIf `floor` is true, then use floor division on `value` if necessary.\n\nParameters\n----------\nvalue\n    Number or numeric ibis expression\nunit\n    Unit of `value`\nto\n    Unit to convert to\nfloor\n    Whether or not to use floor division on `value` if necessary.\n\nReturns\n-------\nUnion[numbers.Integral, ibis.expr.types.NumericValue]\n    Integer converted unit\n\nExamples\n--------\n>>> one_second = 1000\n>>> x = convert_unit(one_second, \"ms\", \"s\")\n>>> x\n1\n>>> one_second = 1\n>>> x = convert_unit(one_second, \"s\", \"ms\")\n>>> x\n1000\n>>> x = convert_unit(one_second, \"s\", \"s\")\n>>> x\n1\n>>> x = convert_unit(one_second, \"s\", \"M\")\nTraceback (most recent call last):\n    ...\nValueError: Cannot convert to or from unit ... to unit ...", "source": "ibis/util.py"}
{"function": "to_pyarrow", "signature": {"args": [{"name": "self"}, {"name": "schema", "type": "Schema"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert this input to a PyArrow Table.", "source": "ibis/formats/__init__.py"}
{"function": "assert_equal", "signature": {"args": [{"name": "left"}, {"name": "right"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Assert that two ibis objects are equal.", "source": "ibis/tests/util.py"}
{"function": "_connect", "signature": {"args": [{"name": "self"}], "returns": "BaseBackend", "has_kwargs": true, "has_varargs": false}, "docstring": "Connect to the backend and return a client object.\n\nThis method is invoked when `st.connection` is called and pulls\ninformation from streamlit secrets. `_connect` is part of the streamlit\nconnection API to be implemented by developers of specific connection\ntypes.\n\nHere's an example not-so-secret configuration:\n\n```toml\n[connections.ch]\nurl = \"clickhouse://play:clickhouse@play.clickhouse.com:9440/?secure=1\"\n```\n\nAlternatively, you can specify individual arguments under a connection\nwhose name matches the backend type. For example:\n\n```toml\n[connections.clickhouse]\nuser = \"play\"\npassword = \"clickhouse\"\nhost = \"play.clickhouse.com\"\nport = 9440\nsecure = 1\n```\n\nThis file can be placed at `~/.streamlit/secrets.toml`.\n\nYou can then connect to the backend using:\n\n```python\nimport streamlit as st\n\nfrom ibis.streamlit import IbisConnection\n\ncon = st.connection(\"ch\", type=IbisConnection)\n\n# Now you can use `con` as if it were an ibis backend\ncon.list_tables()\n```", "source": "ibis/streamlit/__init__.py"}
{"function": "__argnames__", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Implementation for the `ibis.common.graph.Node` protocol.", "source": "ibis/common/egraph.py"}
{"function": "from_numpy", "signature": {"args": [{"name": "cls"}, {"name": "numpy_schema"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent ibis schema.", "source": "ibis/expr/schema.py"}
{"function": "endswith", "signature": {"args": [{"name": "suffixes", "type": "Any"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Select columns whose name ends with one of `suffixes`.\n\nParameters\n----------\nsuffixes\n    Suffixes to compare column names against\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.endswith(\"id\"))\n>>> expr.columns\n('model_id', 'user_id')\n\nSee Also\n--------\n[`startswith`](#ibis.selectors.startswith)", "source": "ibis/selectors.py"}
{"function": "log", "signature": {"args": [{"name": "msg", "type": "str"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Log `msg` using `options.verbose_log` if set, otherwise `print`.", "source": "ibis/util.py"}
{"function": "__rshift__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Deferred"}], "returns": "Replace", "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar for replacing a value.\n\nParameters\n----------\nother\n    The deferred to use for constructing the replacement value.\n\nReturns\n-------\nNew replace pattern.", "source": "ibis/common/patterns.py"}
{"function": "create_table", "signature": {"args": [{"name": "obj", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a new table.\n\nParameters\n----------\nname\n    Name of the new table.\nobj\n    An Ibis table expression or pandas table that will be used to\n    extract the schema and the data of the new table. If not provided,\n    `schema` must be given.\nschema\n    The schema for the new table. Only one of `schema` or `obj` can be\n    provided.\ndatabase\n    Name of the database where the table will be created, if not the\n    default.\ntemp\n    Whether a table is temporary or not\noverwrite\n    Whether to clobber existing data\n\nReturns\n-------\nTable\n    The table that was created.", "source": "ibis/backends/__init__.py"}
{"function": "decompile", "signature": {"args": [{"name": "expr", "type": "Any"}, {"name": "render_import", "type": "bool"}, {"name": "assign_result_to", "type": "str"}, {"name": "format", "type": "bool"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Decompile an ibis expression into Python source code.\n\nParameters\n----------\nexpr\n    node or expression to decompile\nrender_import\n    Whether to add `import ibis` to the result.\nassign_result_to\n    Variable name to store the result at, pass None to avoid assignment.\nformat\n    Whether to format the generated code using black code formatter.\n\nReturns\n-------\nstr\n    Equivalent Python source code for `node`.", "source": "ibis/expr/decompile.py"}
{"function": "asc", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a ascending sort key from `asc` or column name.\n\nParameters\n----------\nexpr\n    The expression or column name to use for sorting\nnulls_first\n    Bool to indicate whether to put NULL values first or not.\n\nSee Also\n--------\n[`Value.asc()`](./expression-generic.qmd#ibis.expr.types.generic.Value.asc)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(ibis.asc(\"year\")).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 species \u2503 year  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2502 Adelie  \u2502  2007 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturns\n-------\nir.ValueExpr\n    An expression", "source": "ibis/expr/api.py"}
{"function": "__rmatmul__", "signature": {"args": [{"name": "self"}, {"name": "name", "type": "str"}], "returns": "Capture", "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar for capturing a value.\n\nParameters\n----------\nname\n    The name of the capture.\n\nReturns\n-------\nNew capture pattern.", "source": "ibis/common/patterns.py"}
{"function": "register_options", "signature": {"args": [{"name": "cls"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Register custom backend options.", "source": "ibis/backends/__init__.py"}
{"function": "type_info", "signature": {"args": [{"name": "datatype"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Format `datatype` for display next to a column.", "source": "ibis/expr/format.py"}
{"function": "temp_table", "signature": {"args": [{"name": "con"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return a temporary table name.\n\nParameters\n----------\ncon : ibis.backends.Client\n\nYields\n------\nname : string\n    Random table name for a temporary usage.", "source": "ibis/backends/conftest.py"}
{"function": "apply", "signature": {"args": [{"name": "self"}, {"name": "rewrites", "type": "list[Rewrite]"}], "returns": "int", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply the given rewrites to the egraph.\n\nIteratively match the patterns and apply the rewrites to the graph. The returned\nnumber of changes is the number of eclasses that were merged. This is the\nnumber of changes made to the egraph. The egraph is saturated if the number of\nchanges is zero.\n\nParameters\n----------\nrewrites :\n    A list of rewrites to apply.\n\nReturns\n-------\nn_changes\n    The number of changes made to the egraph.", "source": "ibis/common/egraph.py"}
{"function": "window", "signature": {"args": [{"name": "preceding"}, {"name": "following"}, {"name": "order_by"}, {"name": "group_by"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Create a window clause for use with window functions.\n\nThe `ROWS` window clause includes peer rows based on differences in row\n**number** whereas `RANGE` includes rows based on the differences in row\n**value** of a single `order_by` expression.\n\nAll window frame bounds are inclusive.\n\nParameters\n----------\npreceding\n    Number of preceding rows in the window\nfollowing\n    Number of following rows in the window\ngroup_by\n    Grouping key\norder_by\n    Ordering key\nrows\n    Whether to use the `ROWS` window clause\nrange\n    Whether to use the `RANGE` window clause\nbetween\n    Automatically infer the window kind based on the boundaries\n\nReturns\n-------\nWindow\n    A window frame", "source": "ibis/expr/api.py"}
{"function": "match", "signature": {"args": [{"name": "self"}, {"name": "value", "type": "AnyType"}, {"name": "context", "type": "dict[str, AnyType]"}], "returns": "AnyType", "has_kwargs": false, "has_varargs": false}, "docstring": "Match a value against the pattern.\n\nParameters\n----------\nvalue\n    The value to match the pattern against.\ncontext\n    A dictionary providing arbitrary context for the pattern matching.\n\nReturns\n-------\nThe result of the pattern matching. If the pattern doesn't match\nthe value, then it must return the `NoMatch` sentinel value.", "source": "ibis/common/patterns.py"}
{"function": "backend_entry_points", "signature": {"args": [], "returns": "list[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Get the list of installed `ibis.backend` entrypoints.", "source": "ibis/util.py"}
{"function": "infer", "signature": {"args": [{"name": "value", "type": "Any"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the corresponding ibis schema for a python object.", "source": "ibis/expr/schema.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "Schema"}], "returns": "dict[str, Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a schema to a polars schema.", "source": "ibis/formats/polars.py"}
{"function": "backend_no_data", "signature": {"args": [{"name": "request"}, {"name": "data_dir"}, {"name": "tmp_path_factory"}, {"name": "worker_id"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return an instance of BackendTest, with no data loaded.", "source": "ibis/backends/conftest.py"}
{"function": "traverse", "signature": {"args": [{"name": "fn", "type": "Callable[Any, tuple[Any, Any]]"}, {"name": "node", "type": "Any"}], "returns": "Iterator[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Utility for generic expression tree traversal.\n\nParameters\n----------\nfn\n    A function applied on each expression. The first element of the tuple controls\n    the traversal, and the second is the result if its not `None`.\nnode\n    The Node expression or a list of expressions.", "source": "ibis/common/graph.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "schema", "type": "Any"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a pyarrow schema to a schema.", "source": "ibis/formats/pyarrow.py"}
{"function": "param", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a deferred parameter of a given type.\n\nParameters\n----------\ntype\n    The type of the unbound parameter, e.g., double, int64, date, etc.\n\nReturns\n-------\nScalar\n    A scalar expression backend by a parameter\n\nExamples\n--------\n>>> from datetime import date\n>>> import ibis\n>>> start = ibis.param(\"date\")\n>>> t = ibis.memtable(\n...     {\n...         \"date_col\": [date(2013, 1, 1), date(2013, 1, 2), date(2013, 1, 3)],\n...         \"value\": [1.0, 2.0, 3.0],\n...     },\n... )\n>>> expr = t.filter(t.date_col >= start).value.sum()\n>>> expr.execute(params={start: date(2013, 1, 1)})\n6.0\n>>> expr.execute(params={start: date(2013, 1, 2)})\n5.0\n>>> expr.execute(params={start: date(2013, 1, 3)})\n3.0", "source": "ibis/expr/api.py"}
{"function": "map_nodes", "signature": {"args": [{"name": "self"}, {"name": "fn", "type": "Callable"}, {"name": "filter", "type": "Optional[Finder]"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Apply a function to all nodes in the graph more memory efficiently.\n\nAlternative implementation of `map` passing only node results to the function\nas positional arguments. This method is useful for calculations where the\nnodes don't need to be reconstructed.", "source": "ibis/common/graph.py"}
{"function": "create_database", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a database named `name` in `catalog`.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nname\n    Name of the database to create.\ncatalog\n    Name of the catalog in which to create the database. If `None`, the\n    current catalog is used.\nforce\n    If `False`, an exception is raised if the database exists.", "source": "ibis/backends/__init__.py"}
