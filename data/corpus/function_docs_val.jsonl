{"function": "_cached_table", "signature": {"args": [{"name": "self"}, {"name": "table", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a Table to a CachedTable.\n\nParameters\n----------\ntable\n    Table expression to cache\n\nReturns\n-------\nTable\n    Cached table", "source": "ibis/backends/__init__.py"}
{"function": "else_", "signature": {"args": [{"name": "self"}, {"name": "result_expr", "type": "Any"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Add a default value for the `CASE` expression.\n\nParameters\n----------\nresult_expr\n    Value to use when all case predicates evaluate to false.", "source": "ibis/expr/builders.py"}
{"function": "date", "signature": {"args": [], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a date scalar or column.\n\nParameters\n----------\nvalue_or_year\n    Either a string value or `datetime.date` to coerce to a date, or\n    an integral value representing the date year component.\nmonth\n    The date month component; required if `value_or_year` is a year.\nday\n    The date day component; required if `value_or_year` is a year.\n\nReturns\n-------\nDateValue\n    A date expression\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nCreate a date scalar from a string\n\n>>> ibis.date(\"2023-01-02\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a date scalar from year, month, and day\n\n>>> ibis.date(2023, 1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2023-01-02 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCreate a date column from year, month, and day\n\n>>> t = ibis.memtable(dict(year=[2001, 2002], month=[1, 3], day=[2, 4]))\n>>> ibis.date(t.year, t.month, t.day).name(\"my_date\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 my_date    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 date       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2001-01-02 \u2502\n\u2502 2002-03-04 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "to_sqlglot", "signature": {"args": [{"name": "self"}, {"name": "dialect", "type": "Any"}], "returns": "list[Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "DEPRECATED: use `to_sqlglot_column_defs()` instead.", "source": "ibis/expr/schema.py"}
{"function": "read_delta", "signature": {"args": [], "returns": null, "has_kwargs": true, "has_varargs": false}, "docstring": "Register a Delta Lake table in the current database.\n\nParameters\n----------\npath\n    The data source. Must be a directory containing a Delta Lake table.\ntable_name\n    An optional name to use for the created table. This defaults to\n    a sequentially generated name.\n**kwargs\n    Additional keyword arguments passed to the underlying backend or library.\n\nReturns\n-------\nir.Table\n    The just-registered table.", "source": "ibis/backends/__init__.py"}
{"function": "list_databases", "signature": {"args": [{"name": "self"}], "returns": "list[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "List existing databases in the current connection.\n\n::: {.callout-note}\n## Ibis does not use the word `schema` to refer to database hierarchy.\n\nA collection of `table` is referred to as a `database`.\nA collection of `database` is referred to as a `catalog`.\n\nThese terms are mapped onto the corresponding features in each\nbackend (where available), regardless of the terminology the backend uses.\n\nSee the\n[Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\nfor more info.\n:::\n\nParameters\n----------\nlike\n    A pattern in Python's regex format to filter returned database\n    names.\ncatalog\n    The catalog to list databases from. If `None`, the current catalog\n    is searched.\n\nReturns\n-------\nlist[str]\n    The database names that exist in the current connection, that match\n    the `like` pattern if provided.", "source": "ibis/backends/__init__.py"}
{"function": "ListOf", "signature": {"args": [{"name": "pattern"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Match a list of items matching the given pattern.", "source": "ibis/common/patterns.py"}
{"function": "gen_name", "signature": {"args": [{"name": "namespace", "type": "str"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a unique identifier.", "source": "ibis/util.py"}
{"function": "set_backend", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Set the default Ibis backend.\n\nParameters\n----------\nbackend\n    May be a backend name or URL, or an existing backend instance.\n\nExamples\n--------\nYou can pass the backend as a name:\n\n>>> import ibis\n>>> ibis.set_backend(\"polars\")\n\nOr as a URI\n\n>>> ibis.set_backend(\n...     \"postgres://user:password@hostname:5432\"\n... )  # quartodoc: +SKIP # doctest: +SKIP\n\nOr as an existing backend instance\n\n>>> ibis.set_backend(ibis.duckdb.connect())", "source": "ibis/expr/api.py"}
{"function": "to_ibis", "signature": {"args": [{"name": "cls"}, {"name": "typ", "type": "T"}, {"name": "nullable", "type": "bool"}], "returns": "DataType", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a format-specific type object to an Ibis DataType.\n\nParameters\n----------\ntyp\n    The format-specific type object to convert.\nnullable\n    Whether the Ibis DataType should be nullable.\n\nReturns\n-------\nIbis DataType.", "source": "ibis/formats/__init__.py"}
{"function": "backend_cls", "signature": {"args": [{"name": "request"}], "returns": "BaseBackend", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the uninstantiated backend class, unconnected.\n\nThis is used for signature checking and nothing should be executed.", "source": "ibis/backends/conftest.py"}
{"function": "execute", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Execute an Ibis expression and return a pandas `DataFrame`, `Series`, or scalar.\n\nParameters\n----------\nexpr\n    Ibis expression to execute.\nparams\n    Mapping of scalar parameter expressions to value.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nkwargs\n    Keyword arguments", "source": "ibis/backends/__init__.py"}
{"function": "__eq__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "object"}], "returns": "bool", "has_kwargs": false, "has_varargs": false}, "docstring": "Check if the disjoint set is equal to another disjoint set.\n\nParameters\n----------\nother :\n    The other disjoint set to compare to.\n\nReturns\n-------\nequal:\n    True if the disjoint sets are equal, False otherwise.", "source": "ibis/common/egraph.py"}
{"function": "coalesce", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Return the first non-null value from `args`.\n\nParameters\n----------\narg\n    First argument from which to choose the first non-null value\nargs\n    Arguments from which to choose the first non-null value\n\nReturns\n-------\nValue\n    Coalesced expression\n\nSee Also\n--------\n[`Value.coalesce()`](#ibis.expr.types.generic.Value.coalesce)\n[`Value.fill_null()`](#ibis.expr.types.generic.Value.fill_null)\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.coalesce(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502\n\u2514\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "__args__", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Implementation for the `ibis.common.graph.Node` protocol.", "source": "ibis/common/egraph.py"}
{"function": "_get_backend_names", "signature": {"args": [], "returns": "frozenset[str]", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the set of known backend names.\n\nParameters\n----------\nexclude\n    Exclude these backend names from the result\n\nNotes\n-----\nThis function returns a frozenset to prevent cache pollution.\n\nIf a `set` is used, then any in-place modifications to the set\nare visible to every caller of this function.", "source": "ibis/backends/__init__.py"}
{"function": "warn_deprecated", "signature": {"args": [{"name": "name"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Warn about deprecated usage.\n\nThe message includes a stacktrace and what to do instead.", "source": "ibis/util.py"}
{"function": "greatest", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Compute the largest value among the supplied arguments.\n\nParameters\n----------\narg\n    First argument\nargs\n    Remaining arguments\n\nReturns\n-------\nValue\n    Maximum of the passed arguments\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> ibis.greatest(None, 4, 5)\n\u250c\u2500\u2500\u2500\u2510\n\u2502 5 \u2502\n\u2514\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "temp_view", "signature": {"args": [{"name": "ddl_con"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Return a temporary view name.\n\nParameters\n----------\nddl_con : backend connection\n\nYields\n------\nname : string\n    Random view name for a temporary usage.", "source": "ibis/backends/conftest.py"}
{"function": "con", "signature": {"args": [{"name": "backend"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Instance of a backend client.", "source": "ibis/backends/conftest.py"}
{"function": "disconnect", "signature": {"args": [{"name": "self"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Close the connection to the backend.", "source": "ibis/backends/__init__.py"}
{"function": "pytest_runtest_call", "signature": {"args": [{"name": "item"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Dynamically add various custom markers.", "source": "ibis/backends/conftest.py"}
{"function": "range", "signature": {"args": [{"name": "start"}, {"name": "stop"}, {"name": "step"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Generate a range of values.\n\nInteger ranges are supported, as well as timestamp ranges.\n\n::: {.callout-note}\n`start` is inclusive and `stop` is exclusive, just like Python's builtin\n[](`range`).\n\nWhen `step` equals 0, however, this function will return an empty array.\n\nPython's `range` will raise an exception when `step` is zero.\n:::\n\nParameters\n----------\nstart\n    Lower bound of the range, inclusive.\nstop\n    Upper bound of the range, exclusive.\nstep\n    Step value. Optional, defaults to 1.\n\nReturns\n-------\nArrayValue\n    An array of values\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n\nRange using only a stop argument\n\n>>> ibis.range(5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [0, 1, ... +3] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSimple range using start and stop\n\n>>> ibis.range(1, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [1, 2, ... +2] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nGenerate an empty range\n\n>>> ibis.range(0)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\nNegative step values are supported\n\n>>> ibis.range(10, 4, -2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [10, 8, ... +1] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n`ibis.range` behaves the same as Python's range ...\n\n>>> ibis.range(0, 7, -1)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\n... except when the step is zero, in which case `ibis.range` returns an\nempty array\n\n>>> ibis.range(0, 5, 0)\n\u250c\u2500\u2500\u2500\u2500\u2510\n\u2502 [] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2518\n\nBecause the resulting expression is array, you can unnest the values\n\n>>> ibis.range(5).unnest().name(\"numbers\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 numbers \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int8    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       0 \u2502\n\u2502       1 \u2502\n\u2502       2 \u2502\n\u2502       3 \u2502\n\u2502       4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTimestamp ranges are also supported\n\n>>> expr = ibis.range(\"2002-01-01\", \"2002-02-01\", ibis.interval(days=2)).name(\"ts\")\n>>> expr\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [                                        \u2502\n\u2502     datetime.datetime(2002, 1, 1, 0, 0), \u2502\n\u2502     datetime.datetime(2002, 1, 3, 0, 0), \u2502\n\u2502     ... +14                              \u2502\n\u2502 ]                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> expr.unnest()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 ts                  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2002-01-01 00:00:00 \u2502\n\u2502 2002-01-03 00:00:00 \u2502\n\u2502 2002-01-05 00:00:00 \u2502\n\u2502 2002-01-07 00:00:00 \u2502\n\u2502 2002-01-09 00:00:00 \u2502\n\u2502 2002-01-11 00:00:00 \u2502\n\u2502 2002-01-13 00:00:00 \u2502\n\u2502 2002-01-15 00:00:00 \u2502\n\u2502 2002-01-17 00:00:00 \u2502\n\u2502 2002-01-19 00:00:00 \u2502\n\u2502 \u2026                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "interval", "signature": {"args": [{"name": "value", "type": "Any"}, {"name": "unit", "type": "str"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an interval literal expression.\n\nParameters\n----------\nvalue\n    Interval value.\nunit\n    Unit of `value`\nyears\n    Number of years\nquarters\n    Number of quarters\nmonths\n    Number of months\nweeks\n    Number of weeks\ndays\n    Number of days\nhours\n    Number of hours\nminutes\n    Number of minutes\nseconds\n    Number of seconds\nmilliseconds\n    Number of milliseconds\nmicroseconds\n    Number of microseconds\nnanoseconds\n    Number of nanoseconds\n\nReturns\n-------\nIntervalScalar\n    An interval expression\n\nExamples\n--------\n>>> from datetime import datetime\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(\n...     {\n...         \"timestamp_col\": [\n...             datetime(2020, 10, 5, 8, 0, 0),\n...             datetime(2020, 11, 10, 10, 2, 15),\n...             datetime(2020, 12, 15, 12, 4, 30),\n...         ]\n...     },\n... )\n\nAdd and subtract ten days from a timestamp column.\n\n>>> ten_days = ibis.interval(days=10)\n>>> ten_days\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MonthDayNano(months=0, days=10, nanoseconds=0) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n>>> t.mutate(\n...     plus_ten_days=t.timestamp_col + ten_days,\n...     minus_ten_days=t.timestamp_col - ten_days,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp_col       \u2503 plus_ten_days       \u2503 minus_ten_days      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10-05 08:00:00 \u2502 2020-10-15 08:00:00 \u2502 2020-09-25 08:00:00 \u2502\n\u2502 2020-11-10 10:02:15 \u2502 2020-11-20 10:02:15 \u2502 2020-10-31 10:02:15 \u2502\n\u2502 2020-12-15 12:04:30 \u2502 2020-12-25 12:04:30 \u2502 2020-12-05 12:04:30 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nIntervals provide more granularity with date arithmetic.\n\n>>> t.mutate(\n...     added_interval=t.timestamp_col\n...     + ibis.interval(weeks=1, days=2, hours=3, minutes=4, seconds=5)\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 timestamp_col       \u2503 added_interval      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 timestamp           \u2502 timestamp           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020-10-05 08:00:00 \u2502 2020-10-14 11:04:05 \u2502\n\u2502 2020-11-10 10:02:15 \u2502 2020-11-19 13:06:20 \u2502\n\u2502 2020-12-15 12:04:30 \u2502 2020-12-24 15:08:35 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "infer_table", "signature": {"args": [{"name": "cls"}, {"name": "table"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the schema of a table.", "source": "ibis/formats/pyarrow.py"}
{"function": "table", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a table expression from the corresponding table in the backend.\n\nParameters\n----------\nname\n    Table name\ndatabase\n    The database, or (catalog, database) from which to get the table.\n\n    For backends that support a single-level table hierarchy,\n    you can pass in a string like `\"bar\"`.\n    For backends that support multi-level table hierarchies, you can\n    pass in a dotted string path like `\"catalog.database\"` or a tuple of\n    strings like `(\"catalog\", \"database\")`.\n    If not provided, the current database\n    (and catalog, if applicable for this backend) is used.\n\n    See the\n    [Table Hierarchy Concepts Guide](/concepts/backend-table-hierarchy.qmd)\n    for more info.\n\nReturns\n-------\nTable\n    Table expression\n\nExamples\n--------\n>>> import ibis\n>>> backend = ibis.duckdb.connect()\n\nGet the \"foo\" table from the current database\n(and catalog, if applicable for this backend):\n\n>>> backend.table(\"foo\")  # doctest: +SKIP\n\nGet the \"foo\" table from the \"bar\" database\n(in DuckDB's language they would say the \"bar\" schema,\nin SQL this would be `\"bar\".\"foo\"`)\n\n>>> backend.table(\"foo\", database=\"bar\")  # doctest: +SKIP\n\nGet the \"foo\" table from the \"bar\" database, within the \"baz\" catalog\n(in DuckDB's language they would say the \"bar\" schema, and \"baz\" database,\nin SQL this would be `\"baz\".\"bar\".\"foo\"`)\n\n>>> backend.table(\"foo\", database=(\"baz\", \"bar\"))  # doctest: +SKIP", "source": "ibis/backends/__init__.py"}
{"function": "resolve", "signature": {"args": [{"name": "self"}, {"name": "context", "type": "dict"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a new object from the context.\n\nParameters\n----------\ncontext\n    A dictionary containing all the captured values and information\n    relevant for the deferred.\n\nReturns\n-------\nThe constructed object.", "source": "ibis/common/deferred.py"}
{"function": "now", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an expression that will compute the current timestamp.\n\nReturns\n-------\nTimestampScalar\n    An expression representing the current timestamp.", "source": "ibis/expr/api.py"}
{"function": "slice_to_limit_offset", "signature": {"args": [{"name": "what", "type": "slice"}, {"name": "count", "type": "Any"}], "returns": "tuple[Any, Any]", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a Python [`slice`](slice) to a `limit`, `offset` pair.\n\nParameters\n----------\nwhat\n    The slice to convert\ncount\n    The total number of rows in the table as an expression\n\nReturns\n-------\ntuple[int | ir.IntegerScalar, int | ir.IntegerScalar]\n    The offset and limit to use in a `Table.limit` call\n\nExamples\n--------\n>>> import ibis\n>>> t = ibis.table(dict(a=\"int\", b=\"string\"), name=\"t\")\n\nFirst 10 rows\n>>> count = t.count()\n>>> what = slice(0, 10)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit\n10\n>>> offset\n0\n\nLast 10 rows\n>>> what = slice(-10, None)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit\n10\n>>> offset\nr0 := UnboundTable: t\n  a int64\n  b string\n<BLANKLINE>\nAdd(CountStar(t), -10): CountStar(r0) + -10\n\nFrom 5th row to 10th row\n>>> what = slice(5, 10)\n>>> limit, offset = slice_to_limit_offset(what, count)\n>>> limit, offset\n(5, 5)", "source": "ibis/util.py"}
{"function": "dense_rank", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Position of first element within each group of equal values.\n\nValues are returned in sorted order and duplicate values are ignored.\n\nEquivalent to SQL's `DENSE_RANK()`.\n\nReturns\n-------\nIntegerColumn\n    The rank\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=ibis.dense_rank().over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 rank  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      3 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "end", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Finish the `CASE` expression.", "source": "ibis/expr/builders.py"}
{"function": "chunks", "signature": {"args": [{"name": "n", "type": "int"}], "returns": "Iterator[tuple[int, int]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an iterator of chunk start and end indices.\n\nParameters\n----------\nn\n    The total number of elements.\nchunk_size\n    The size of each chunk.\n\nReturns\n-------\nint\n    THE start and end indices of each chunk.\n\nExamples\n--------\n>>> list(chunks(10, chunk_size=3))\n[(0, 3), (3, 6), (6, 9), (9, 10)]\n>>> list(chunks(10, chunk_size=4))\n[(0, 4), (4, 8), (8, 10)]", "source": "ibis/util.py"}
