{"function": "infer_table", "signature": {"args": [{"name": "cls"}, {"name": "obj", "type": "T"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the Ibis schema of a format-specific table.\n\nParameters\n----------\nobj\n    The format-specific table to infer the Ibis schema of.\n\nReturns\n-------\nIbis schema corresponding to the given format-specific table.", "source": "ibis/formats/__init__.py"}
{"function": "schema", "signature": {"args": [{"name": "value", "type": "Any"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct ibis schema from schema-like python objects.", "source": "ibis/expr/schema.py"}
{"function": "infer_table", "signature": {"args": [{"name": "cls"}, {"name": "table"}], "returns": "Schema", "has_kwargs": false, "has_varargs": false}, "docstring": "Infer the schema of a table.", "source": "ibis/formats/polars.py"}
{"function": "__rshift__", "signature": {"args": [{"name": "self"}, {"name": "rhs"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar to create a rewrite rule.", "source": "ibis/common/egraph.py"}
{"function": "ntile", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the integer number of a partitioning of the column values.\n\nParameters\n----------\nbuckets\n    Number of buckets to partition into\n\nExamples\n--------\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(ntile=ibis.ntile(2).over(order_by=t.values))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 values \u2503 ntile \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64  \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      1 \u2502     0 \u2502\n\u2502      1 \u2502     0 \u2502\n\u2502      2 \u2502     0 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      2 \u2502     1 \u2502\n\u2502      3 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "source": "ibis/expr/api.py"}
{"function": "import_object", "signature": {"args": [{"name": "qualname", "type": "str"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Attempt to import an object given its full qualname.\n\nExamples\n--------\n>>> ex = import_object(\"ibis.examples\")\n\nIs the same as\n\n>>> from ibis import examples as ex", "source": "ibis/util.py"}
{"function": "from_dfs", "signature": {"args": [{"name": "cls"}, {"name": "root", "type": "Node"}, {"name": "filter", "type": "Optional[FinderLike]"}, {"name": "context", "type": "Optional[dict]"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Construct a graph from a root node using a depth-first search.\n\nThe traversal is implemented in an iterative fashion using a stack.\n\nParameters\n----------\nroot\n    Root node of the graph.\nfilter\n    A type, tuple of types, a pattern or a callable to filter out nodes\n    from the traversal. The traversal will only visit nodes that match\n    the given filter and stop otherwise.\ncontext\n    Optional context to use for the pattern matching.\n\nReturns\n-------\nA graph constructed from the root node.", "source": "ibis/common/graph.py"}
{"function": "_get_backend_conf", "signature": {"args": [{"name": "backend_str", "type": "str"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert a backend string to the test class for the backend.", "source": "ibis/backends/conftest.py"}
{"function": "first", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the first column of a table.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(model_id=\"int\", model_name=\"str\", user_id=\"int\"), name=\"t\")\n>>> expr = t.select(s.first())\n>>> expr.columns\n('model_id',)", "source": "ibis/selectors.py"}
{"function": "to_string", "signature": {"args": [{"name": "cls"}, {"name": "dtype", "type": "DataType"}], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert `dtype` into a backend-specific string representation.\n\nParameters\n----------\ndtype\n    The Ibis DataType to convert.\n\nReturns\n-------\nBackend-specific string representation.", "source": "ibis/formats/__init__.py"}
{"function": "promote_list", "signature": {"args": [{"name": "val", "type": "Any"}], "returns": "list[V]", "has_kwargs": false, "has_varargs": false}, "docstring": "Ensure that the value is a list.\n\nParameters\n----------\nval\n    Value to promote\n\nReturns\n-------\nlist", "source": "ibis/util.py"}
{"function": "__invert__", "signature": {"args": [{"name": "self"}], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Compute the logical negation of a `Selector`.", "source": "ibis/common/selectors.py"}
{"function": "parse_sql", "signature": {"args": [{"name": "sqlstring"}, {"name": "catalog"}, {"name": "dialect"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Parse a SQL string into an Ibis expression.\n\nParameters\n----------\nsqlstring : str\n    SQL string to parse\ncatalog : dict\n    A dictionary mapping table names to either schemas or ibis table expressions.\n    If a schema is passed, a table expression will be created using the schema.\ndialect : str, optional\n    The SQL dialect to use with sqlglot to parse the query string.\n\nReturns\n-------\nexpr : ir.Expr", "source": "ibis/expr/sql.py"}
{"function": "toposort", "signature": {"args": [{"name": "self"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Topologically sort the graph using Kahn's algorithm.\n\nThe graph is sorted in a way that all the dependencies of a node are placed\nbefore the node itself. The graph must not contain any cycles. Especially useful\nfor mutating the graph in a way that the dependencies of a node are mutated\nbefore the node itself.\n\nReturns\n-------\nThe topologically sorted graph.", "source": "ibis/common/graph.py"}
{"function": "from_pyarrow", "signature": {"args": [{"name": "cls"}, {"name": "pyarrow_schema"}], "returns": "Self", "has_kwargs": false, "has_varargs": false}, "docstring": "Return the equivalent ibis schema.", "source": "ibis/expr/schema.py"}
{"function": "backend", "signature": {"args": [{"name": "request"}, {"name": "data_dir"}, {"name": "tmp_path_factory"}, {"name": "worker_id"}], "returns": "BackendTest", "has_kwargs": false, "has_varargs": false}, "docstring": "Return an instance of BackendTest, loaded with data.", "source": "ibis/backends/conftest.py"}
{"function": "_run_pre_execute_hooks", "signature": {"args": [{"name": "self"}, {"name": "expr", "type": "Any"}], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Backend-specific hooks to run before an expression is executed.", "source": "ibis/backends/__init__.py"}
{"function": "to_frame", "signature": {"args": [{"name": "self"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert this input to a pandas DataFrame.", "source": "ibis/formats/__init__.py"}
{"function": "table", "signature": {"args": [{"name": "schema", "type": "Any"}, {"name": "name", "type": "Any"}, {"name": "catalog", "type": "Any"}, {"name": "database", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Create a table literal or an abstract table without data.\n\nIbis uses the word database to refer to a collection of tables, and the word\ncatalog to refer to a collection of databases. You can use a combination of\n`catalog` and `database` to specify a hierarchical location for table.\n\nParameters\n----------\nschema\n    A schema for the table\nname\n    Name for the table. One is generated if this value is `None`.\ncatalog\n    A collection of database.\ndatabase\n    A collection of tables. Required if catalog is not `None`.\n\nReturns\n-------\nTable\n    A table expression\n\nExamples\n--------\nCreate a table with no data backing it\n\n>>> import ibis\n>>> ibis.options.interactive = False\n>>> t = ibis.table(schema=dict(a=\"int\", b=\"string\"), name=\"t\")\n>>> t\nUnboundTable: t\n  a int64\n  b string\n\n\nCreate a table with no data backing it in a specific location\n\n>>> import ibis\n>>> ibis.options.interactive = False\n>>> t = ibis.table(schema=dict(a=\"int\"), name=\"t\", catalog=\"cat\", database=\"db\")\n>>> t\nUnboundTable: cat.db.t\n  a int64", "source": "ibis/expr/api.py"}
{"function": "guid", "signature": {"args": [], "returns": "str", "has_kwargs": false, "has_varargs": false}, "docstring": "Return a uuid4 hexadecimal value.", "source": "ibis/util.py"}
{"function": "get_subclasses", "signature": {"args": [{"name": "obj", "type": "type[T]"}], "returns": "Iterator[type[S]]", "has_kwargs": false, "has_varargs": false}, "docstring": "Recursively compute all subclasses of `obj`.\n\n::: {.callout-note}\n## The resulting iterator does **not** include the input type object.\n:::\n\nParameters\n----------\nobj\n    Any type object\n\nExamples\n--------\n>>> class Base: ...\n>>> class Subclass1(Base): ...\n>>> class Subclass2(Base): ...\n>>> class TransitiveSubclass(Subclass2): ...\n\nEverything inherits `Base` (directly or transitively)\n\n>>> list(get_subclasses(Base))\n[<class 'ibis.util.Subclass1'>, <class 'ibis.util.Subclass2'>, <class 'ibis.util.TransitiveSubclass'>]\n\nNothing inherits from `Subclass1`\n\n>>> list(get_subclasses(Subclass1))\n[]\n\nOnly `TransitiveSubclass` inherits from `Subclass2`\n\n>>> list(get_subclasses(Subclass2))\n[<class 'ibis.util.TransitiveSubclass'>]\n\nNothing inherits from `TransitiveSubclass`\n\n>>> list(get_subclasses(TransitiveSubclass))\n[]", "source": "ibis/util.py"}
{"function": "drop_view", "signature": {"args": [], "returns": "None", "has_kwargs": false, "has_varargs": false}, "docstring": "Drop a view.\n\nParameters\n----------\nname\n    Name of the view to drop.\ndatabase\n    Name of the database where the view exists, if not the default.\nforce\n    If `False`, an exception is raised if the view does not exist.", "source": "ibis/backends/__init__.py"}
{"function": "apply_limit", "signature": {"args": [{"name": "table"}, {"name": "step"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Applies a LIMIT, if applicable.", "source": "ibis/expr/sql.py"}
{"function": "from_ibis", "signature": {"args": [{"name": "cls"}, {"name": "dtype", "type": "Any"}], "returns": "Any", "has_kwargs": false, "has_varargs": false}, "docstring": "Convert an ibis type to a pyarrow type.", "source": "ibis/formats/pyarrow.py"}
{"function": "numeric", "signature": {"args": [], "returns": "Selector", "has_kwargs": false, "has_varargs": false}, "docstring": "Return numeric columns.\n\nExamples\n--------\n>>> import ibis\n>>> import ibis.selectors as s\n>>> t = ibis.table(dict(a=\"int\", b=\"string\", c=\"array<string>\"), name=\"t\")\n>>> t.columns\n('a', 'b', 'c')\n>>> expr = t.select(s.numeric())  # `a` has integer type, so it's numeric\n>>> expr.columns\n('a',)\n\nSee Also\n--------\n[`of_type`](#ibis.selectors.of_type)", "source": "ibis/selectors.py"}
{"function": "tables", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "An accessor for tables in the database.\n\nTables may be accessed by name using either index or attribute access:\n\nExamples\n--------\n>>> con = ibis.sqlite.connect(\"example.db\")\n>>> people = con.tables[\"people\"]  # access via index\n>>> people = con.tables.people  # access via attribute", "source": "ibis/backends/__init__.py"}
{"function": "__and__", "signature": {"args": [{"name": "self"}, {"name": "other", "type": "Pattern"}], "returns": "AllOf", "has_kwargs": false, "has_varargs": false}, "docstring": "Syntax sugar for matching both of the patterns.\n\nParameters\n----------\nother\n    The other pattern to match against.\n\nReturns\n-------\nNew pattern that matches if both of the patterns match.", "source": "ibis/common/patterns.py"}
{"function": "_apply_replacements", "signature": {"args": [{"name": "obj", "type": "Any"}, {"name": "replacements", "type": "dict"}], "returns": "tuple[Any, bool]", "has_kwargs": false, "has_varargs": false}, "docstring": "Replace nodes in a possibly nested object.\n\nParameters\n----------\nobj\n    The object to traverse.\nreplacements\n    A mapping of replacement values.\n\nReturns\n-------\ntuple[Any, bool]\n    A tuple of the replaced object and whether any replacements were made.", "source": "ibis/common/graph.py"}
{"function": "compile", "signature": {"args": [], "returns": "Any", "has_kwargs": true, "has_varargs": false}, "docstring": "Compile `expr` to a SQL string (for SQL backends) or a LazyFrame (for the polars backend).\n\nParameters\n----------\nexpr\n    An ibis expression to compile.\nlimit\n    An integer to effect a specific row limit. A value of `None` means\n    no limit. The default is in `ibis/config.py`.\nparams\n    Mapping of scalar parameter expressions to value.\nkwargs\n    Additional keyword arguments", "source": "ibis/backends/__init__.py"}
{"function": "to_parquet_dir", "signature": {"args": [{"name": "directory", "type": "Any"}], "returns": "None", "has_kwargs": true, "has_varargs": false}, "docstring": "Write the results of executing the given expression to a parquet file in a directory.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to parquet.\ndirectory\n    The data source. A string or Path to the directory where the parquet file will be written.\nparams\n    Mapping of scalar parameter expressions to value.\n**kwargs\n    Additional keyword arguments passed to pyarrow.dataset.write_dataset\n\nhttps://arrow.apache.org/docs/python/generated/pyarrow.dataset.write_dataset.html", "source": "ibis/backends/__init__.py"}
{"function": "or_", "signature": {"args": [], "returns": "Any", "has_kwargs": false, "has_varargs": true}, "docstring": "Combine multiple predicates using `|`.\n\nParameters\n----------\npredicates\n    Boolean value expressions\n\nReturns\n-------\nBooleanValue\n    A new predicate that evaluates to True if any composing predicates are\n    True. If no predicates were provided, returns False.", "source": "ibis/expr/api.py"}
{"function": "to_json", "signature": {"args": [{"name": "path", "type": "Any"}], "returns": "None", "has_kwargs": true, "has_varargs": false}, "docstring": "Write the results of `expr` to a json file of [{column -> value}, ...] objects.\n\nThis method is eager and will execute the associated expression\nimmediately.\n\nParameters\n----------\nexpr\n    The ibis expression to execute and persist to Delta Lake table.\npath\n    The data source. A string or Path to the Delta Lake table.\nkwargs\n    Additional, backend-specifc keyword arguments.", "source": "ibis/backends/__init__.py"}
{"function": "to_node", "signature": {"args": [{"name": "self"}], "returns": null, "has_kwargs": false, "has_varargs": false}, "docstring": "Convert the ENode back to an `ibis.common.graph.Node`.", "source": "ibis/common/egraph.py"}
